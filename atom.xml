<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zoomdong&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zoomdong.site/"/>
  <updated>2020-05-27T03:10:32.940Z</updated>
  <id>http://zoomdong.site/</id>
  
  <author>
    <name>zoomdong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 0 开始，成为 Ant-Design Contributor</title>
    <link href="http://zoomdong.site/2020/05/27/how-to-be-antd-contributor/"/>
    <id>http://zoomdong.site/2020/05/27/how-to-be-antd-contributor/</id>
    <published>2020-05-27T03:06:17.000Z</published>
    <updated>2020-05-27T03:10:32.940Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是 zoomdong，一名大三的学生，目前在北京实习。想给大家分享一下我最近给 Ant-design贡献代码的经历，同时也希望能引导大家来一起参与其中，一起为开源世界来贡献自己的力量！</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 <a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant-Desgin</a>，我想不用我做过多的介绍，大家或多或少有对其有所耳闻。作为一个顶级的“设计语言和研发框架”，antd 在国内乃至全世界都是十分受欢迎的。截止到这篇文章完成之前，antd 的 <a href="https://github.com/ant-design/ant-design/" target="_blank" rel="noopener">star</a> 数也成功突破了 60k 这一关口，master 分支的 commit 数目也高达 1万8千多，这反映了 antd 的受欢迎程度以及核心贡献者们对 issue 处理的效率之高。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527000338.png" alt="image-20200527000338797"></p><p>我是从大二学习前端时在学长的推荐下开始使用这个框架的，在校时使用 react + antd + dva 完成了许许多多的项目。同时，就在今年，我也开始加入到了 antd 这个项目的贡献中去，在这个月第一次给 antd <a href="https://github.com/ant-design/ant-design/issues/24206" target="_blank" rel="noopener">修复了bug</a>，成功成为了一名 antd 的contributor了。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526235101.png" alt="image-20200526235100981"></p><h2 id="贡献-Pull-Request-的流程"><a href="#贡献-Pull-Request-的流程" class="headerlink" title="贡献 Pull Request 的流程"></a>贡献 Pull Request 的流程</h2><p>再开始做出贡献之前，建议先去 antd 官网的参考一下项目的<a href="https://ant.design/docs/react/contributing-cn" target="_blank" rel="noopener">贡献流程</a>。</p><p>Ant-design 的代码目前全部开源在 <a href="https://github.com/ant-design/ant-design" target="_blank" rel="noopener">GitHub</a>,遵循 MIT 开源协议。如果想为 antd 贡献自己的代码需要做以下几方面的工作：</p><h3 id="1、拷贝-fork-过来的项目"><a href="#1、拷贝-fork-过来的项目" class="headerlink" title="1、拷贝 fork 过来的项目"></a>1、拷贝 fork 过来的项目</h3><p>先将antd的代码 fork 一份到自己的仓库，然后 clone 下来，并添加主代码库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将 fork 过来的仓库 <span class="built_in">clone</span> 到本地</span><br><span class="line">// <span class="built_in">clone</span> 速度太慢可以尝试配置代理</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/&#123;username&#125;/ant-design.git</span><br><span class="line"><span class="built_in">cd</span> ant-design</span><br><span class="line">// 添加主代码库</span><br><span class="line">git remote add upstream https://github.com/ant-design/ant-design.git</span><br></pre></td></tr></table></figure><h3 id="2、分支管理"><a href="#2、分支管理" class="headerlink" title="2、分支管理"></a>2、分支管理</h3><p>antd 的贡献流程里面有提过：<strong>修复 bug 反馈到 master 分支；新增 feature 反馈到 feature 分支</strong>。</p><p>基于我们之前有添加主仓库，如果我们想与主仓库对应的分支保持同步的话，使用 git rebase 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 拉去主仓库的代码</span><br><span class="line">git fetch upstream</span><br><span class="line">// 同步对应分支的代码</span><br><span class="line">git rebase upstream/master</span><br><span class="line">git rebase upstream/feature</span><br></pre></td></tr></table></figure><p>以我之前的一次 <a href="https://github.com/ant-design/ant-design/pull/24385" target="_blank" rel="noopener">pr</a> 作为例子: 这次 pr 因为是新增了 feature，因此我们从 feature 分支切一个分支出来即可:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先从 master 切换至 <span class="built_in">feature</span></span><br><span class="line">git checkout <span class="built_in">feature</span></span><br><span class="line">// 然后从 <span class="built_in">feature</span> 上切一个新的分支出来</span><br><span class="line">git checkout -b <span class="built_in">feature</span>-xxx</span><br></pre></td></tr></table></figure><p>然后我们在这个feature 分支完成开发即可，同步之前提交使用 git rebase 即可。</p><h3 id="3、提交-pr"><a href="#3、提交-pr" class="headerlink" title="3、提交 pr"></a>3、提交 pr</h3><p>我们先将自己的修改提交到自己 fork 过来的仓库相对应的分支上面去。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add 修改文件</span><br><span class="line">git commit -m <span class="string">"xxx"</span></span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">feature</span>-xxx</span><br></pre></td></tr></table></figure><p>这里要注意 commit 信息的规范，可以参考<a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰老师博客</a>。</p><p>在提交成功之后，我们直接到 github 上面提交这份 pr，antd 的 pr 是会<a href="https://github.com/ant-design/ant-design/blob/master/.github/PULL_REQUEST_TEMPLATE.md" target="_blank" rel="noopener">自动生成模版</a>的，跟着模块相关的信息去填写即可，注意这里 pr 给 antd 的分支时同样要注意是 master 还是 feature 分支。</p><h3 id="4、修改-pr"><a href="#4、修改-pr" class="headerlink" title="4、修改 pr"></a>4、修改 pr</h3><p>如果有大佬 review 了你的提交并给出了修改意见，因为很大部分的 pr 其实都会被指出意见，我们这里虚心去接受大佬的指导然后做出修改即可:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add 修改文件</span><br><span class="line">git commit -m <span class="string">"fix: xxxx"</span></span><br><span class="line">git fetch upstream</span><br><span class="line">// 这里注意分支</span><br><span class="line">git rebase upstream/<span class="built_in">feature</span></span><br><span class="line">// 然后将修改提交到之前到分支，这时候github会自动帮你把提交同步过去的</span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">feature</span>-xxx</span><br></pre></td></tr></table></figure><h2 id="贡献实战"><a href="#贡献实战" class="headerlink" title="贡献实战"></a>贡献实战</h2><p>这里结合我前几天自己的一次贡献经历来给大家实际展现一个具体的贡献流程是怎么样的～</p><h3 id="1-找到-issue-并分析"><a href="#1-找到-issue-并分析" class="headerlink" title="1. 找到 issue 并分析"></a>1. 找到 issue 并分析</h3><p>之前也有说过，antd 一般有两种 pr：修复一个 bug 或者贡献一个新的feature。第一次参加某个开源项目一般都是从这个项目的 <code>good First Issue</code>入手，同样在 antd 里面这样的 <a href="[https://github.com/ant-design/ant-design/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22](https://github.com/ant-design/ant-design/issues?q=is%3Aissue+is%3Aopen+label%3A&quot;good+first+issue&quot;">issue</a>) 可以提供给开发者去解决。同样也会有一些 <code>help wanted</code> 标签的 issue 给开发者去解决，这样的问题一般都会有用户提供复现的连接，我们可以从这方面来开始入手，于是我找到了这样的一个 issue:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527005736.png" alt="image-20200527005736401"></p><p>这是去年的一个issue，我看到这个 issue 问题的问题的时候，里面已经有大佬关于这个 issue 做了一些讨论。</p><p>实际上，我并没有使用过 Typography 这个组件，于是我去 ant-design 的官网查阅了相关的 <a href="https://ant.design/components/typography-cn/" target="_blank" rel="noopener">api 文档</a>，大概知道了这是个用于做文章排版的组件，报告人对当前改组件里面一个 Paragraph 设置的自动隐藏的按钮并不是特别满意，他希望能提供出一个 api 供他自己去定制这个省略的按钮。</p><p>这个时候我们就大概知道了报告人希望改善的地方在哪里了，然后参考了下面大佬的一些讨论，我需要在 Typography.Paragraph 里面提供一个 <code>symblol</code> 参数来让他去自定义省略展开按钮的样式。同时这个参数的类型应该是 <code>React.ReactNode</code>。</p><h3 id="2-编写代码并提交-pr"><a href="#2-编写代码并提交-pr" class="headerlink" title="2. 编写代码并提交 pr"></a>2. 编写代码并提交 pr</h3><p>于是按照上面的逻辑打开了 antd 的源码，从 feature  分支切出一个新的 feature-typography 分支。找到我们要修改的组件所在的文件夹，一般组件名都会在 components 下面有个对应的文件，找到这个文件即可，这里就是 <code>typography</code>。</p><p>这里我大概分析出来了我要加的地方之后，然后先在本地启动 antd。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装项目依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">// 本地开启端口访问</span></span><br><span class="line">npm <span class="built_in">run</span> start</span><br></pre></td></tr></table></figure><p> 一般项目都运行在本地的<code>8000</code> 端口上，我们直接去访问即可。我们在<code>typography</code>里面对应的代码逻辑里面添加了相应的逻辑之后，这时我们想看看自己的修改是否生效，这里就可以使用 <code>antd</code> 本地跑起来的官网上的 <code>demo</code> 来做测试用例。</p><p>我们可以看到：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527100031.png" alt="image-20200527100031436"></p><p>最开始的省略号是默认的“展开”字符，这里我们通过新增的 api 往里面传递我们自己的参数：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527100231.png" alt="image-20200527100231242"></p><p>那么这个地方就可以是用户自定义的了。看上去一切都大功告成了，于是我按照上面提交 pr 的逻辑开了 pr 到 antd 的主仓库。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527100522.png" alt="image-20200527100522037"></p><p>注意这里我提交pr的分支是 feature 分支，同时按照 antd 的 template 填好相关的信息。大概过一段时间之后就会有核心贡献者来 review 你的pr，不得不说 antd 的贡献者们都是极其活跃的，不一会儿 pr 就有人 review 了。</p><h3 id="3-代码-review-并做出修改"><a href="#3-代码-review-并做出修改" class="headerlink" title="3. 代码 review 并做出修改"></a>3. 代码 review 并做出修改</h3><p>没过多久 afc163 大佬就看到了我的 pr,然后做了review：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527101513.png" alt="image-20200527101513702"></p><p>因为是第一次提交，我只在本地跑过了 <code>Typography</code> 这个组件的测试就开了pr,发现有个 <code>lint</code> 检查是没有通过的。于是这里要注意的时，<strong>本地提交之前要先运行好 <code>npm run test</code> 和 <code>npm run lint</code> 以确保所有的代码检验都通过</strong>。</p><p>在本地修改了 <code>lint error</code> 的代码逻辑之后，我重新提交了代码，然后再次收到了 afc163 的建议：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527103746.png" alt="image-20200527103746439"></p><p>注意，<strong>加测试其实是一个很重要的步骤</strong>，尤其是对于这种组件库代码而言，之前我在修复<a href="https://github.com/react-component/input-number/pull/246" target="_blank" rel="noopener">另外一个bug</a>的时候,afc163 大佬也有给过建议。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527103936.png" alt="image-20200527103936510"></p><p>这里我们就直接去 <code>Typography</code> 组件下的<code>tests</code>目录去加上对应的测试用例:</p><p>然后加完之后确保测试用例通过运行可以使用：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span> <span class="comment">运行指定的</span> <span class="comment">Typography</span> <span class="comment">组件测试代码</span></span><br><span class="line"><span class="comment">npm</span> <span class="comment">test</span> -- --<span class="comment">watch</span> <span class="comment">Typography</span></span><br></pre></td></tr></table></figure><p>等样例都运行通过之后再去提交新一轮的代码。最后 afc163 大佬给了一个 api 文档的描述错误，我简单做了修改之后这次pr，就被成功的合并了。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527104506.png" alt="image-20200527104506319"></p><p>到这一步的时候，就已经成功成为一名 antd 的 contributor了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我看来，开源其实一直是一个重在参与、或者说是图一乐的事情。在我大二那年的时候，我发现了 github 这个世界最庞大的开源社区，便沉迷于此不可自拔，<strong>这真的是一件很有意义且有意思的事情</strong>，不过是阅读大佬的代码还是在社区修一些力所能及的bug。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527105419.png" alt="image-20200527105419056"></p><p>希望能用这篇文章，给更多想参加开源却不知道从何下手的人做一个简单的入门讲解。开源并不是一件很困难的事情，入门也远没有你所想象的那么困难。一个项目的发展，抑或是一个生态的形成，项目的核心贡献者们固然起到了重要的作用，但同样也离不开像我们这样的使用项目并去给拓展项目生态的人，经过无数次的修改，一个真正能够造福使用者的项目或者是生态才能够成形。</p><p>让我们一起加入其中吧～</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://zhuanlan.zhihu.com/p/123367842" target="_blank" rel="noopener">如何快速的成为 Ant Design 的 contributor</a></p><p><a href="https://zhuanlan.zhihu.com/p/27932211" target="_blank" rel="noopener">为 Node.js 贡献你的力量</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好，我是 zoomdong，一名大三的学生，目前在北京实习。想给大家分享一下我最近给 Ant-design贡献代码的经历，同时也希望能引导大家来一起参与其中，一起为开源世界来贡献自己的力量！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口解题技巧</title>
    <link href="http://zoomdong.site/2020/05/26/siliding-window/"/>
    <id>http://zoomdong.site/2020/05/26/siliding-window/</id>
    <published>2020-05-26T03:20:59.000Z</published>
    <updated>2020-05-26T03:21:37.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>在字符串 S 中使用双指针的左右指针技巧，初始化 left = right = 0,索引闭区间 [left, right] 称为一个窗口</li><li>先不断增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符串）</li><li>此时，停止增加 right,转而不断增加 left 指针来缩小窗口 [left, right]，直到窗口中的字符串不再符合要求 (不包含 T 中的所有字符了)。同时，每次增加 left，都要更新一轮结果。</li><li>重复 2 - 3 ,直到 right 到达尽头。</li></ul><a id="more"></a><h3 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> res = s;</span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  window.add(s[right])</span><br><span class="line">  right ++;</span><br><span class="line">  <span class="comment">// 如果符合要求，移动left缩小窗口</span></span><br><span class="line">  <span class="keyword">while</span> (window 符合要求) &#123;</span><br><span class="line">    <span class="comment">// 如果这个窗口的子串更短，则更新res</span></span><br><span class="line">    res = minLen(res, window);</span><br><span class="line">    window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>那么我们要如何判断window即子串 <code>s[left...right]</code> 是否符合要求，是否包含 <code>t</code> 的所有字符呢？</p><p>可以用两个hash表来做计数器，一个记录t的字符以及出现次数，另一个window则记录当前窗口所包含的字符及出现的次数，如果window包含所有needs中的键，且这些键对应的值都大于等于needs中的值，那么就可以知道当前窗口符合要求了，可以开始移动<code>left</code>指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">stirng s, t;</span><br><span class="line"><span class="comment">// 在s中找t的最小覆盖子串</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> res = s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于两个计数器</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; needs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">  needs[c] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 window 中已经有多少字符符合要求了</span></span><br><span class="line"><span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="keyword">char</span> c1 = s[right];</span><br><span class="line">  <span class="keyword">if</span> (needs.count(c1)) &#123;</span><br><span class="line">    <span class="comment">// 加入window</span></span><br><span class="line">    window[c1] ++;</span><br><span class="line">    <span class="keyword">if</span> (window[c1] === needs[c1]) &#123;</span><br><span class="line">      <span class="comment">// 字符c1点出现符合次数了</span></span><br><span class="line">      match ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  right ++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// window 中的字符已符合 needs 的要求了</span></span><br><span class="line">  <span class="keyword">while</span> (match === needs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 更新结果res</span></span><br><span class="line">    res = minLen(res, window);</span><br><span class="line">    <span class="keyword">char</span> c2 = s[left];</span><br><span class="line">    <span class="keyword">if</span> (needs.count(c2)) &#123;</span><br><span class="line">      <span class="comment">// 移出 window</span></span><br><span class="line">      window[c2] --;</span><br><span class="line">      <span class="keyword">if</span> (window[c2] &lt; needs[c2]) &#123;</span><br><span class="line">        <span class="comment">// 字符 c2 出现次数不再符合要求</span></span><br><span class="line">        match --;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h3 id="lc76-最小覆盖子串"><a href="#lc76-最小覆盖子串" class="headerlink" title="lc76 最小覆盖子串"></a>lc76 最小覆盖子串</h3><p>这题可以套一套我们上面的板子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// s中能覆盖t的最小子串</span></span><br><span class="line"><span class="comment">// s = "ADOBECODEBANC",t = "ABC"</span></span><br><span class="line"><span class="comment">// res = "BNAC"</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  s = s.split(<span class="string">''</span>)</span><br><span class="line">  t = t.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">let</span> tMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">window</span> = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">    tMap.set(t[i], tMap.has(t[i]) ? tMap.get(t[i]) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> match = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (r &lt; s.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> c1 = s[r]</span><br><span class="line">    <span class="keyword">if</span> (tMap.has(c1)) &#123;</span><br><span class="line">      <span class="built_in">window</span>.set(c1, <span class="built_in">window</span>.has(c1) ? <span class="built_in">window</span>.get(c1) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.get(c1) === tMap.get(c1)) &#123;</span><br><span class="line">        match++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r++</span><br><span class="line">    <span class="comment">// 如果window中的串已经符合要求了,开始移动左边，找符合条件的最小值</span></span><br><span class="line">    <span class="keyword">while</span> (match === tMap.size) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r - l &lt; min) &#123;</span><br><span class="line">        start = l</span><br><span class="line">        min = r - l</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  更新一下最短的字符串</span></span><br><span class="line">      <span class="keyword">let</span> c2 = s[l]</span><br><span class="line">      <span class="keyword">if</span> (tMap.has(c2)) &#123;</span><br><span class="line">        <span class="built_in">window</span>.set(c2, <span class="built_in">window</span>.get(c2) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.get(c2) &lt; tMap.get(c2)) &#123;</span><br><span class="line">          match--</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      l++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min === <span class="built_in">Number</span>.MAX_SAFE_INTEGER ? <span class="string">''</span> : s.join(<span class="string">''</span>).slice(start, start + min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(minWindow('ADOBECODEBANC', 'ABC'))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在字符串 S 中使用双指针的左右指针技巧，初始化 left = right = 0,索引闭区间 [left, right] 称为一个窗口&lt;/li&gt;
&lt;li&gt;先不断增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符串）&lt;/li&gt;
&lt;li&gt;此时，停止增加 right,转而不断增加 left 指针来缩小窗口 [left, right]，直到窗口中的字符串不再符合要求 (不包含 T 中的所有字符了)。同时，每次增加 left，都要更新一轮结果。&lt;/li&gt;
&lt;li&gt;重复 2 - 3 ,直到 right 到达尽头。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dp技巧学习</title>
    <link href="http://zoomdong.site/2020/05/26/dp-1/"/>
    <id>http://zoomdong.site/2020/05/26/dp-1/</id>
    <published>2020-05-26T03:16:12.000Z</published>
    <updated>2020-05-26T03:16:48.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最优子结构详解"><a href="#最优子结构详解" class="headerlink" title="最优子结构详解"></a>最优子结构详解</h3><p>最优子结构：从子问题的最优结果推出更大规模的问题的最优结果。</p><a id="more"></a><p>例如，假设学校有10个班级，已经每个班级的最高分，要求全校的最高分。</p><p>这个问题就符合最优子结构:可以从子问题的最优结果推出更大规模问题的最优结果。计算每个班的最高分就是子问题。</p><p>这么简单的问题都具有最优子结构，但是因为没有重叠子问题，因此不用动态规划来解决。</p><p>再例如，假设学校有10个班级，已经每个班级都最大分数差，求出全校学生的最大分差。这个问题可以想办法算，但是肯定不能根据已知的最大分差来进行推，因为10个班的最大分差就不一定是全校的最大分差，有可能是 3 班的最高分和 6 班的最低分之差。</p><p>那么这次的这个问题就<strong>不符合最优子结构</strong>。没办法根据每个班的最优值推出规模更大问题的最优值。因为要想满足最优子结构，那么子问题之间必须要相互独立。最大分差可能出现在两个班级，子问题并不独立，所以这个问题不符合。</p><p>遇到这种情况，我们就需要对问题进行一个改造。先写一段暴力代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a: school) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Student b: school) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a is b) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="built_in">max</span> (result, <span class="built_in">abs</span>(a - b))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把问题来一波等价转换：最大分数差等价于最高分数和最低分数的差，这样不就具备有最优子结构了吗？</p><p>再举一个常见的例子，求一颗二叉树的最大值(假设节点中都是非负数):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxVal</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  let left = maxVal(root.left);</span><br><span class="line">  let right = maxVal(root.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题其实也符合最优子结构，以 <code>root</code> 为根的树的最大值，可以通过两边子树(子问题)的最大值推导出来。</p><p>但这也不是dp问题，最优子结构并不是dp独有的一种性质，能求最值的问题大部分都具备这个性质；但是反过来，最优子结构性质作为dp问题的必要条件，一定是用来求最值的。</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以观察是否出现重复的子问题，有的话就优化。</p><h3 id="dp数组遍历的方向"><a href="#dp数组遍历的方向" class="headerlink" title="dp数组遍历的方向"></a>dp数组遍历的方向</h3><p>以二维dp作为例子，有时候是正向遍历:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="comment">// 计算dp[i][j]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候反向:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m- <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">    <span class="comment">// 计算dp[i][j]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以斜着遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l&lt;=n;l++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n-l;i++) &#123;</span><br><span class="line">   <span class="keyword">int</span> j = l + i - <span class="number">2</span>;</span><br><span class="line">    dp[i][j] = ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果仔细观察的话，只需要掌握以下两点即可:</p><ul><li>遍历过程中，所需要的状态已经被计算出来了</li><li>遍历的终点必须是存储结果的那个位置</li></ul><p>以编辑距离这个题目作为例子，对dp数组的定义，确定的base的数组值是<code>dp[...][0]</code>和<code>dp[o][...]</code>，最终的答案是<code>dp[m][n]</code>;而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>、<code>dp[i][j-1]</code>、<code>dp[i-1][j-1]</code>转移而来，如下图:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525165038.png" alt="image-20200525165037985"></p><p>参考之前的原则，那么这里我们肯定会去正向遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (let j = <span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="comment">// 通过 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] -&gt; dp[i][j]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再参考回文子序列问题，可以参考前面的”子序列问题模版”，通过对dp数组的定义，确定了base case处于中间的对角线,<code>dp[i][j]</code> 需要从<code>dp[i+1][j]</code>、<code>dp[i][j-1]</code>、<code>dp[i+1][j-1]</code>转移而来。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525165748.png" alt="image-20200525165748819"></p><p>根据刚才的两个原则，就可以有两种正确的遍历方式:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525165901.png" alt="image-20200525165901880"></p><p>要么从左到右斜着遍历，要么从下到上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>到左边、下边、左下角已经计算完成，得到了正确的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最优子结构详解&quot;&gt;&lt;a href=&quot;#最优子结构详解&quot; class=&quot;headerlink&quot; title=&quot;最优子结构详解&quot;&gt;&lt;/a&gt;最优子结构详解&lt;/h3&gt;&lt;p&gt;最优子结构：从子问题的最优结果推出更大规模的问题的最优结果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-从输入URL到页面渲染</title>
    <link href="http://zoomdong.site/2020/05/25/broswer-4/"/>
    <id>http://zoomdong.site/2020/05/25/broswer-4/</id>
    <published>2020-05-24T16:35:43.000Z</published>
    <updated>2020-05-24T16:36:28.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>完整示意图为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200524225634.png" alt></p><p>整个过程需要进程的配合。结合之前的浏览器进程架构以及上面的示意图，整个过程的大概描述如下:</p><ul><li>首先，浏览器进程接收用户输入的 <code>URL</code>请求，浏览器进程便将该 URL 转发给网络进程。</li><li>然后，在网络进程中发起真正的 URL 请求</li><li>接着网络进程接收到了响应头数据，解析响应头数据，将数据转发给网络进程。</li><li>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航(<code>CommitNavigation</code>)”消息到渲染进程</li><li>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道</li><li>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程:“已经准备好接受和解析页面数据”</li><li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态</li></ul><a id="more"></a><p>其中，用户发出 URL 请求到页面开始解析到这个过程，就叫做导航。</p><h2 id="输入-URL-到页面显示"><a href="#输入-URL-到页面显示" class="headerlink" title="输入 URL 到页面显示"></a>输入 URL 到页面显示</h2><h3 id="1-用户输入"><a href="#1-用户输入" class="headerlink" title="1.用户输入"></a>1.用户输入</h3><p>用户在地址栏中输入一个查询关键字时，地址栏会判断输入到关键字是搜索内容，还是<strong>请求的 URL</strong>。</p><ul><li>搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带关键字的 URL。</li><li>如果判断输入内容符合 URL 规则，比如输入 <code>time.geekbang.org</code>，地址栏会根据规则，把这段内容加上协议，合成完成的 URL。</li></ul><p>当用户输入关键字并键入回车之后，当前页面即将被替换为新的页面，不过在这个流程继续之前，浏览器还是给当前页面一次执行 <code>beforeunload</code> 事件的机会。</p><p><code>beforeunload</code>事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否离开当前页面，比如表单当前还未完成，用户可以通过 <code>beforeunload</code> 事件来取消导航，让浏览器不再执行任何后序工作。</p><p>当前页面没有监听 <code>beforeunload</code> 事件或者同意了继续后续流程，那么浏览器便进入了下面状态:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200524233018.png" alt="image-20200524233018101"></p><p>RT，浏览器刚开始加载一个地址之后，标签页上的图标就进入了加载状态。但此时图中页面显示的仍然是之前打开的页面内容，并没有立即替换掉。因为需要等待提交文档阶段，页面内容才会被替换。</p><h3 id="2-URL请求流程"><a href="#2-URL请求流程" class="headerlink" title="2. URL请求流程"></a>2. URL请求流程</h3><p>首先，网络线查找本地是否有缓存，如果有，返回缓存资源给浏览器进程;如果在缓存中没有该资源，那就进入网络请求流程，第一步是先进行 <code>DNS</code> 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p><p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行，请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头，然后向服务器发送构建的请求信息。</p><p>服务端收到后，会生成响应数据(包括响应头，响应行，响应体等信息)，并发给网络进程。网络进程接收后，就开始解析响应头内容。</p><h4 id="1-重定向"><a href="#1-重定向" class="headerlink" title="(1) 重定向"></a>(1) 重定向</h4><p>在接收到服务端返回响应头之后，网络进程开始解析响应头，如果返回到状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 <code>Location</code> 字符里读取重定向地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重新开始。</p><p>利用我们用<code>curl</code>去请求<code>http://time.geekbang.org/</code> 会发现极客时间会通过重定向的方式把所有的 <code>HTTP</code> 请求转换为 <code>HTTPS</code> 请求。也就是说你用 <code>HTTP</code> 向极客时间服务器做请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头 location 字段换成 HTTPS 请求的地址。</p><p>如果请求 https 的，就会直接返回200了。</p><p>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p><h4 id="2-响应数据类型处理"><a href="#2-响应数据类型处理" class="headerlink" title="(2)响应数据类型处理"></a>(2)响应数据类型处理</h4><p>处理完跳转信息之后，浏览器会根据 <code>Content-Type</code> 来区分返回的数据类型(下载类型或者html页面)。</p><p>例如<code>Content-Type</code>字段是<code>text/html</code>，告诉浏览器服务器返回的数据是 HTML 格式。</p><p>不同 <code>Content-Type</code> 的后续处理流程也截然不同。如果 <code>Content-Type</code> 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 <code>URL</code> 请求的导航流程就此结束。但如果是 <code>HTML</code>，那么浏览器则会继续进行导航流程。由于 <code>Chrome</code> 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h4 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="(3)准备渲染进程"></a>(3)准备渲染进程</h4><p><code>Chrome</code> 会为每个页面分配一个渲染进程，意味着每开一个新页面都会配套创建一个新的渲染进程。</p><p>比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的 Chrome 的任务管理器截图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525000749.png" alt="image-20200525000749288"></p><p>打开这三个页面都是运行在同一个渲染进程，进程 ID 是23601。</p><p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p><p><code>Chrome</code>的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开另一个页面，并且这两个页面属于同一站点(协议和根域名都相同)的话，那么新页面就会复用父页面的渲染进程。官方把这个默认策略叫 :<code>process-per-site-instance</code></p><p>如果不属于同一个站点，那么新页面就会开一个新的渲染进程。</p><p>总结来说，打开一个新页面的渲染策略是:</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程</li><li>从A打开B,A、B同一站点，那么B复用A的渲染进程;如果是其他情况，浏览器会为B创建一个新的渲染进程</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态。因为文档还在网络进程中，还没提交给渲染进程。</p><h4 id="4-提交文档"><a href="#4-提交文档" class="headerlink" title="(4)提交文档"></a>(4)提交文档</h4><p>提交文档指的是，浏览器进程将网络进程收到的 <code>HTML</code>数据提交给渲染进程，具体流程 :</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据，会和网络进程建立传输数据的“管道”</li><li>渲染进程接收到传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程</li><li>览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>浏览器确认提交之后，更新的内容如下:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525002733.png" alt="image-20200525002733357"></p><h4 id="5-渲染阶段"><a href="#5-渲染阶段" class="headerlink" title="(5)渲染阶段"></a>(5)渲染阶段</h4><p>一旦文档被提交了，渲染进程便开始页面解析和子资源加载。一旦页面生成完成，渲染进程会发消息给浏览器进程，浏览器进程接收到消息后，会停止标签图标上的加载动画。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525003001.png" alt="image-20200525003001342"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li><li>Chrome 默认采用每个标签对应一个渲染进程，但是两个页面为同一站点，就会用一个渲染进程</li><li>浏览器的导航过程覆盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;完整示意图为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200524225634.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;整个过程需要进程的配合。结合之前的浏览器进程架构以及上面的示意图，整个过程的大概描述如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，浏览器进程接收用户输入的 &lt;code&gt;URL&lt;/code&gt;请求，浏览器进程便将该 URL 转发给网络进程。&lt;/li&gt;
&lt;li&gt;然后，在网络进程中发起真正的 URL 请求&lt;/li&gt;
&lt;li&gt;接着网络进程接收到了响应头数据，解析响应头数据，将数据转发给网络进程。&lt;/li&gt;
&lt;li&gt;浏览器进程接收到网络进程的响应头数据之后，发送“提交导航(&lt;code&gt;CommitNavigation&lt;/code&gt;)”消息到渲染进程&lt;/li&gt;
&lt;li&gt;渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道&lt;/li&gt;
&lt;li&gt;最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程:“已经准备好接受和解析页面数据”&lt;/li&gt;
&lt;li&gt;浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Node.js,来一打 Cpp 拓展》学习笔记- Node 模块原理解析 &amp;&amp; Cpp 模块优点</title>
    <link href="http://zoomdong.site/2020/05/23/cpp-node-2/"/>
    <id>http://zoomdong.site/2020/05/23/cpp-node-2/</id>
    <published>2020-05-23T05:56:34.000Z</published>
    <updated>2020-05-23T05:58:24.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要写C-拓展模块"><a href="#为什么要写C-拓展模块" class="headerlink" title="为什么要写C++拓展模块"></a>为什么要写C++拓展模块</h3><h4 id="C-比-JS-解释器高效"><a href="#C-比-JS-解释器高效" class="headerlink" title="C++ 比 JS 解释器高效"></a>C++ 比 JS 解释器高效</h4><p>相同意思的代码，在 JavaScript 解析器中执行 JavaScript 代码的效率通常比直接执行一个 C++ 编译好后的二进制文件要低。（这里指那些非并行、计算密集型的代码，因为模型不用，单线程下实现 C++ 的 Web 请求处理和有着异步 I/O 优势的 Node.js 下实现的 Web 请求处理也是不能相提并论的 —— Node.js底层使用了别的线程）</p><p>有个 <code>NBody</code>的例子，相同的代码，使用C++ 大约只需要<code>6-7s</code>，但使用<code>Node.JS</code>却需要<code>20s</code>左右，具体代码可以参看书中例子。</p><p>C++效率虽然高，但是所需要的维护成本和开发效率和 <code>Node.js</code> 也不在一个层次上。因此偶尔在一个整体使用 <code>Node.js</code> 开发的项目中使用 C++ 写一两个拓展也是一种很奇妙的体验。</p><a id="more"></a><h4 id="已有的Cpp轮子"><a href="#已有的Cpp轮子" class="headerlink" title="已有的Cpp轮子"></a>已有的Cpp轮子</h4><p>还有一种比较常见的使用Cpp拓展的原因是市面上或者手头上已经有一套C++的轮子，而且使用<code>Node</code> 再次实现一遍非常麻烦且不现实，这时就可以基于这个轮子包裹一层C++的拓展了，当然前提是项目的主体本身就是 <code>Node</code>。</p><p>综合以上两点，使用C++来写Node.js原生拓展的两大理由——性能和开发成本</p><p>对于有显著性能提升的情况，使用CPP来完成是很爽的，而对于已经存在的C++类库，那些难以迁移或者无法迁移的项目又何苦迁移，使用 Cpp 拓展也是件很有意思的事情。</p><h3 id="什么是-C-拓展"><a href="#什么是-C-拓展" class="headerlink" title="什么是 C++ 拓展"></a>什么是 C++ 拓展</h3><p>因为 Node.js 本身是基于 Chrome V8  引擎和 libuv,使用 C++ 进行开发的，因此自然能够轻松的对使用了特定 API 进行开发的 C++ 代码进行拓展，使其能够在 Node.js 中被 <code>require</code> 之后能够像调用 JavaScript 函数一样被调用。</p><h4 id="C-模块本质"><a href="#C-模块本质" class="headerlink" title="C++ 模块本质"></a>C++ 模块本质</h4><p>Node是基于C++开发的，因此所有底层头文件暴露的 API 也都是适用于 C++ 的。</p><p>当我们在Node.js中 require 一个模块的时候，其运行时会依次枚举后缀名进行一个寻址，其中就有后缀名为<code>*.node</code>的模块，这是一个 C++ 模块的二进制文件。</p><p>实际上编译好的C++模块除了后缀名是<code>*.node</code>之外，它其实就是一个系统的动态链接库。说得直白一点，这就相当于 Windows 下的 <code>*.dll</code>、Linux下的<code>*.so</code>以及 macOS 下的<code>*.dylib</code>。</p><p><strong>在 Node.js 中引入一个 C++ 模块的过程，实际上就是 Node.js 在运行时引入一个动态链接库的过程。</strong>运行的时候接受 js 代码中的调用，解析出来具体是拓展中的哪个函数需要被调用，在调用完成之后获得结果再通过运行时返回给 js 代码。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521232522.png" alt="image-20200521232522393"></p><p>调用 Node 的原生 C++ 函数和调用 C++ 拓展函数的区别就在于前者的代码会直接编译进 Node 可执行文件中，而后者的代码则位于一个动态链接库中。</p><h4 id="Node-模块加载原理"><a href="#Node-模块加载原理" class="headerlink" title="Node 模块加载原理"></a>Node 模块加载原理</h4><p>在开发 node 的经验中，Node.js 载入一个源码文件或者一个 C++ 拓展文件是通过 Node 中的 <code>require()</code> 函数实现的。这些被在于的文件单位或者粒度就是模块(<code>modules</code>)了。C++模块也被称为C++拓展了。</p><p>该函数既能载入 Node 的内部模块，也能载入 JS 模块以及 C++ 拓展。 </p><h5 id="node-js-入口"><a href="#node-js-入口" class="headerlink" title="node.js 入口"></a>node.js 入口</h5><p>Node.js在 C++ 代码层面的入口在源码<code>src/node_main.cc</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Disable stdio buffering, it interacts poorly with printf()</span></span><br><span class="line">  <span class="comment">// calls elsewhere in the program (e.g., any logging from V8.)</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> node::Start(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明进入 C++ 主函数之后直接调用了 node 这个命名空间中的 Start 函数，而这个函数位于 <code>src/node.cc</code></p><p>通过 Start 函数去层层查找,里面会有个 LoadEnviroment 函数:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521234826.png" alt="image-20200521234826877"></p><p>由于 Node 现在的代码和作者当时版本的源码有挺多的差别，因此我们直接按照书中的分析。</p><p>Node 执行 <code>lib/internal/bootstrap_node.js</code>文件来进行初始化启动，这里还没有<code>require</code>的概念。文件中的源码没有经过 <code>require()</code> 函数进行闭包操作，所以执行该文件之后得到的 <code>f_value</code> 就是 <code>bootsrap_node.js</code>文件中所实现的那个函数对象。</p><p>由于 V8 的值(包括对象、函数等)均继承自 Value 基类，所以在得到函数的 Value 实例之后需要将其转换成能用的 Function 对象，然后以 <code>env-&gt;process_object()</code> 为参数执行这个从<code>bootstap_node.js</code>中得到的函数。</p><p>那么我们就大致知道了Node的入口启动流程。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521235513.png" alt="image-20200521235513947"> </p><h5 id="process对象"><a href="#process对象" class="headerlink" title="process对象"></a>process对象</h5><p>前面提到执行 node 初始化函数时会传入 <code>env-&gt;process_object()</code>，而对应的 <code>lib/internal/bootstrap_node.js</code>文件中这个参数的含义其实就是 process 对象。</p><p>这里的这个process对象就是Node中我们经常使用的全局对象 process。这个 <code>env-&gt;process_object()</code>一些内容就是在<code>src/node.cc</code>中实现的。我们很容易查找到这个文件中的 <code>SetupProcessObject</code>函数。<img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200522000636.png" alt="image-20200522000636091"></p><p>这些列举的方法以及属性其实都基本是 <code>Node</code>文档中原本列出的 process 对象中暴露的 API 内容。</p><h5 id="几种模块的具体加载过程"><a href="#几种模块的具体加载过程" class="headerlink" title="几种模块的具体加载过程"></a>几种模块的具体加载过程</h5><p>前面说了一些 node 的入口相关文件之后，接下来将模块分为四个类型，分别介绍加载过程：</p><ul><li>C++ 核心模块</li><li>Node.js 内置模块</li><li>用户源码模块</li><li>C++拓展</li></ul><ol><li><p>C++ 核心模块</p><p>该模块在 node 源码中其实就是采用纯 Cpp 编写的，是并没有经过任何 js 代码封装的原生模块，有点类似于 C++ 拓展，区别在于之前说过的前者位于 node 的源码中并且编译进 node 的可执行二进制文件中，后者则通过动态链接库的形式存在。</p></li></ol><p>在介绍 C++ 核心模块的加载过程之前，先提一下前面出现过的 <code>process.binding</code>函数。它对应 <code>src/node.cc</code>文件中的<code>Binding</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Binding(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">  Environment* env = Environment::GetCurrent(args);</span><br><span class="line"></span><br><span class="line">  Local&lt;<span class="built_in">String</span>&gt; <span class="built_in">module</span> = args[<span class="number">0</span>]-&gt;ToString(env-&gt;isolate());</span><br><span class="line">  node::Utf8Value module_v(env-&gt;isolate(), <span class="built_in">module</span>);</span><br><span class="line"></span><br><span class="line">  Local&lt;<span class="built_in">Object</span>&gt; cache = env-&gt;binding_cache_object();</span><br><span class="line">  Local&lt;<span class="built_in">Object</span>&gt; exports;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache-&gt;Has(env-&gt;context(), <span class="built_in">module</span>).FromJust()) &#123;</span><br><span class="line">    exports = cache-&gt;Get(<span class="built_in">module</span>)-&gt;ToObject(env-&gt;isolate());</span><br><span class="line">    args.GetReturnValue().Set(exports);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append a string to process.moduleLoadList</span></span><br><span class="line">  <span class="comment">// 将一个字符串附加在 process.moduleLoadList 后面</span></span><br><span class="line">  char buf[<span class="number">1024</span>];</span><br><span class="line">  snprintf(buf, sizeof(buf), <span class="string">"Binding %s"</span>, *module_v);</span><br><span class="line"></span><br><span class="line">  Local&lt;<span class="built_in">Array</span>&gt; modules = env-&gt;module_load_list_array();</span><br><span class="line">  uint32_t l = modules-&gt;Length();</span><br><span class="line">  modules-&gt;<span class="built_in">Set</span>(l, OneByteString(env-&gt;isolate(), buf));</span><br><span class="line"></span><br><span class="line">  node_module* mod = get_builtin_module(*module_v);</span><br><span class="line">  <span class="keyword">if</span> (mod != nullptr) &#123;</span><br><span class="line">    exports = <span class="built_in">Object</span>::New(env-&gt;isolate());</span><br><span class="line">    <span class="comment">// Internal bindings don't have a "module" object, only exports.</span></span><br><span class="line">    <span class="comment">// 内置模块没有 module 对象，只有 exports</span></span><br><span class="line">    CHECK_EQ(mod-&gt;nm_register_func, nullptr);</span><br><span class="line">    CHECK_NE(mod-&gt;nm_context_register_func, nullptr);</span><br><span class="line">    Local&lt;Value&gt; unused = Undefined(env-&gt;isolate());</span><br><span class="line">    mod-&gt;nm_context_register_func(exports, unused,</span><br><span class="line">      env-&gt;context(), mod-&gt;nm_priv);</span><br><span class="line">    cache-&gt;<span class="built_in">Set</span>(<span class="built_in">module</span>, exports);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcmp(*module_v, <span class="string">"constants"</span>)) &#123;</span><br><span class="line">    exports = <span class="built_in">Object</span>::New(env-&gt;isolate());</span><br><span class="line">    DefineConstants(env-&gt;isolate(), exports);</span><br><span class="line">    cache-&gt;<span class="built_in">Set</span>(<span class="built_in">module</span>, exports);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcmp(*module_v, <span class="string">"natives"</span>)) &#123;</span><br><span class="line">    exports = <span class="built_in">Object</span>::New(env-&gt;isolate());</span><br><span class="line">    DefineJavaScript(env, exports);</span><br><span class="line">    cache-&gt;<span class="built_in">Set</span>(<span class="built_in">module</span>, exports);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    char errmsg[<span class="number">1024</span>];</span><br><span class="line">    snprintf(errmsg,</span><br><span class="line">             sizeof(errmsg),</span><br><span class="line">             <span class="string">"No such module: %s"</span>,</span><br><span class="line">             *module_v);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;ThrowError(errmsg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  args.GetReturnValue().Set(exports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>Local&lt;String&gt; module = args[0]-&gt;Tostring(env -&gt; isolate());</code>和<code>node::Utf8Value module_v(env-&gt;isolate(), module);</code> 表示从参数中获得文件标识符(或者文件名)的字符串并赋值给<code>module-v</code>。</p><p>在得到标识符字符串之后,node.js通过<code>node_module* mod = get_builtin_module(*module_v);</code> 这句代码获取<code>C++</code>核心模块，例如未经源码<code>lib</code> 目录下的 js 文件封装的<code>file</code>模块。我们注意到这里获取核心模块用的是一个<code>get_builtin_module</code>函数，这个函数的内部工作就是在一个名为<code>modlist_buildin</code>的<code>C++</code>核心模块链表上对比文件标识，从而返回相对应的模块。</p><p>追根溯源，这些 <code>C++</code> 核心模块则是在<code>node_module_register</code>函数中被逐一注册进链表的，可以参考下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> = <span class="title">reinterpret_cast</span>&lt;struct node_module*&gt;(<span class="title">m</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_BUILTIN) &#123;</span><br><span class="line">    mp-&gt;nm_link = modlist_builtin;</span><br><span class="line">    modlist_builtin = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123;</span><br><span class="line">    <span class="comment">// "Linked" modules are included as part of the node project.</span></span><br><span class="line">    <span class="comment">// Like builtins they are registered *before* node::Init runs.</span></span><br><span class="line">    mp-&gt;nm_flags = NM_F_LINKED;</span><br><span class="line">    mp-&gt;nm_link = modlist_linked;</span><br><span class="line">    modlist_linked = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    modpending = mp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct node_module* <span class="title">get_builtin_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mp = modlist_builtin; mp != <span class="literal">nullptr</span>; mp = mp-&gt;nm_link) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mp-&gt;nm_modname, name) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CHECK(mp == <span class="literal">nullptr</span> || (mp-&gt;nm_flags &amp; NM_F_BUILTIN) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>node_module_register</code>函数清晰表达了，如果传入待注册模块标示位是内置模块<code>(mp-&gt;nm_flags &amp; NM_F_BUILTIN)</code>，就将其加入 <code>C++</code>核心模块的链表中；否则认为是其他模块。</p><p>在<code>src/node.h</code>中有一个宏是用于注册 <code>C++</code>核心模块的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="string">"C"</span> &#123;                                                        \</span><br><span class="line">    <span class="keyword">static</span> node::node_module _module =                                \</span><br><span class="line">    &#123;                                                                 \</span><br><span class="line">      NODE_MODULE_VERSION,                                            \</span><br><span class="line">      flags,                                                          \</span><br><span class="line">      <span class="literal">NULL</span>,                                                           \</span><br><span class="line">      __FILE__,                                                       \</span><br><span class="line">      <span class="literal">NULL</span>,                                                           \</span><br><span class="line">      (node::addon_context_register_func) (regfunc),                  \</span><br><span class="line">      NODE_STRINGIFY(modname),                                        \</span><br><span class="line">      priv,                                                           \</span><br><span class="line">      <span class="literal">NULL</span>                                                            \</span><br><span class="line">    &#125;;                                                                \</span><br><span class="line">    NODE_C_CTOR(_register_ ## modname) &#123;                              \</span><br><span class="line">      node_module_register(&amp;_module);                                 \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE(modname, regfunc)                                 \</span></span><br><span class="line">  NODE_MODULE_X(modname, regfunc, <span class="literal">NULL</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE(modname, regfunc)                   \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, <span class="literal">NULL</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_BUILTIN(modname, regfunc)           \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, <span class="literal">NULL</span>, NM_F_BUILTIN)   \</span><br></pre></td></tr></table></figure><p>结合之前<code>node_module_register</code>函数和这个<code>src/node.h</code>中的宏定义，我们发现只要<code>Node.js</code>在<code>C++</code>源码中调用<code>NODE_MODULE_CONTEXT_AWARE_BUILTIN</code>这个宏，就有一个模块会被注册进 <code>Node.js</code> 的 <code>C++</code> 核心模块链表。</p><p>那么什么时候会调用这个宏呢？在 <code>src/node.cc</code>中会给出结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_MODULE_CONTEXT_AWARE_BUILTIN(fs, node::InitFs)</span><br></pre></td></tr></table></figure><p>这个宏展开后的结果就是 <code>NODE_MODULE_CONTEXT_AWARE_X</code></p><p>至此我们就能明白，基本上在每个 <code>C++</code> 核心模块的源码末尾都会有一个宏调用将该模块注册进 <code>C++</code> 核心模块的链表中，以供执行 <code>process.binding</code> 时获取。</p><ol start="2"><li>Node.js 内置模块</li></ol><p><code>node</code> 内置模块基本上等同于官方文档中放出的那些文档。这些模块大多是在源码 <code>lib</code> 目录下以同名 <code>JavaScript</code> 代码的形式被实现，而且很多 <code>node.js</code> 内置模块实际上都是对 <code>C++</code> 核心模块的一个封装。</p><blockquote><p>例如 <code>lib/crypto.js</code> 中就有一段 <code>const binding = process.binding(&#39;crypto&#39;);</code> 这样的代码，它里面很多内容都是基于 <code>C++</code> 核心模块中的 <code>crypto</code> 进行实现的。</p></blockquote><p>接下来先看<code>Node.js</code>的启动脚本，<code>lib/internal/bootstrap_node.js</code>中。代码最下面有一个 <code>NativeModule</code> 类的声明。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130136.png" alt="image-20200523130136554"></p><p>这个<code>NativeModule</code>类就是<code>Node.js</code>内置模块的相关处理类了，他有一个叫做<code>require</code> 的静态函数，当其参数 id 值为 ‘native_module’ 时返回的是它本身，否则进入 <code>nativeModule.compile</code> 进行编译。</p><p>进而目光转向 <code>compile</code>函数，第一行代码就是获取该模块的源码:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130535.png" alt="image-20200523130535026"> </p><p>源码是通过<code>NativeModule.getSource</code>获取的，<code>NativeModule.getSource</code>函数返回的是<code>NativeModule._source</code> 数组中的相应内容。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130647.png" alt="image-20200523130647750"></p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130727.png" alt="image-20200523130727713"></p><p>而<code>_source</code>则是通过<code>process.binging</code>这个函数获取(<code>Binding</code> 这个函数在<code>node.cc</code>中)过来的。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130900.png" alt="image-20200523130900236"></p><p>执行<code>process.binging(&#39;natives&#39;)</code>会返回<code>DefineJavaScript</code>函数中的处理内容。</p><p>而这个<code>DefineJavaScript</code>函数会遍历一遍<code>natives</code>数组中的内容，然后加入到一个对象中，对象名的 <code>key</code> 为源码文件标识符，<code>value</code>是源码本体字符串。这里我们会发现整个项目都找不到<code>natives</code> 数组。</p><p><strong>这里其实就可以知道，node中的内置模块本来在 lib 目录下，但是加载的时候却在 C++ 源码中以 natives 变量的形式存在，那么可以证明中间多了一个编译层的过程。</strong></p><p>打开<code>node-gyp</code>文件夹下面的<code>node.gyp</code>配置文件。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523132014.png" alt="image-20200523132014859"></p><p>其中有一步的目标配置是<code>node_js2c</code>，然后去看<code>js2c.py</code>文件。</p><p>这是一个 <code>py</code>脚本，主要作用是把<code>lib</code>下的<code>js</code>文件转成<code>src/node_natives.h</code>文件。</p><p>这个<code>src/node_natives.h</code>文件会在<code>node</code>编译之前完成，这样在编译到<code>src/node_javascript.cc</code>时他需要的<code>src/node_natives.h</code>有头文件就有了。</p><p><code>src/node_natives.h</code>源文件经过<code>js2c.py</code>转换后，会以一种之前说过的 <code>natives</code>对象存在。</p><p><strong>在node中调用NativeModule.require的时候，会根据传入的文件标识来返回响应的 JavaScript 源文件内容，例如<code>dgram</code> 对应<code>lib/dgram.js</code>中的js代码字符串</strong></p><p>解决了 编译进 node 二进制文件中的 js 代码的问题之后，重新回到<code>NativeModule.compile</code>函数中来，<img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523132837.png" alt="image-20200523132837343"></p><p>他会在刚获取到的内置模块js源码字符串前后用<code>(function (exports, require, module, __filename, _dirname)) {</code> 和 <code>});</code> 包裹 从而形成一段闭包代码，放在<code>vm</code>(<code>vm</code>模块用于创建独立运行的沙箱体制，通过<code>vm</code>，js源码可以被编译后立即执行或者编译保存下来稍后执行。是<code>node</code>中的核心模块，支撑了 <code>require</code>方法和<code>node</code>的运行机制。)中执行，并传入事先准备好的<code>module</code>和<code>exports</code>对象供其导出。</p><p>如此一来，内置模块就完成了加载。</p><ol start="3"><li>用户源码模块</li></ol><p>用户源码模块指用户在项目中的 node 源码，以及所使用的第三方包中的模块。<strong>非node内置模块的js源码模块话就是用户源码模块</strong></p><p>这些模块被使用时需要被<code>require()</code>函数加载。</p><p>与内置模块类似，每个用户源码模块都会被加上一个闭包的头尾，然后<code>node.js</code>执行这个闭包产生的结果。</p><p>其载入流程大概是:</p><ul><li>开发者调用<code>require()</code>(某种意义上等同于调用<code>Module._load</code>)</li><li>闭包化对应文件的源码，并传入相关参数执行(有缓存就直接返回)</li><li>通常在执行过程中<code>module.exports</code>或者<code>exports</code>会被赋值</li><li><code>Module.prototype._load</code>在最后返回这个模块的<code>exports</code>给上游</li></ul><ol start="4"><li>C++拓展</li></ol><p>​    To be continued…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要写C-拓展模块&quot;&gt;&lt;a href=&quot;#为什么要写C-拓展模块&quot; class=&quot;headerlink&quot; title=&quot;为什么要写C++拓展模块&quot;&gt;&lt;/a&gt;为什么要写C++拓展模块&lt;/h3&gt;&lt;h4 id=&quot;C-比-JS-解释器高效&quot;&gt;&lt;a href=&quot;#C-比-JS-解释器高效&quot; class=&quot;headerlink&quot; title=&quot;C++ 比 JS 解释器高效&quot;&gt;&lt;/a&gt;C++ 比 JS 解释器高效&lt;/h4&gt;&lt;p&gt;相同意思的代码，在 JavaScript 解析器中执行 JavaScript 代码的效率通常比直接执行一个 C++ 编译好后的二进制文件要低。（这里指那些非并行、计算密集型的代码，因为模型不用，单线程下实现 C++ 的 Web 请求处理和有着异步 I/O 优势的 Node.js 下实现的 Web 请求处理也是不能相提并论的 —— Node.js底层使用了别的线程）&lt;/p&gt;
&lt;p&gt;有个 &lt;code&gt;NBody&lt;/code&gt;的例子，相同的代码，使用C++ 大约只需要&lt;code&gt;6-7s&lt;/code&gt;，但使用&lt;code&gt;Node.JS&lt;/code&gt;却需要&lt;code&gt;20s&lt;/code&gt;左右，具体代码可以参看书中例子。&lt;/p&gt;
&lt;p&gt;C++效率虽然高，但是所需要的维护成本和开发效率和 &lt;code&gt;Node.js&lt;/code&gt; 也不在一个层次上。因此偶尔在一个整体使用 &lt;code&gt;Node.js&lt;/code&gt; 开发的项目中使用 C++ 写一两个拓展也是一种很奇妙的体验。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Node.js,来一打 Cpp 拓展》学习笔记-环境安装</title>
    <link href="http://zoomdong.site/2020/05/22/cpp-node-1/"/>
    <id>http://zoomdong.site/2020/05/22/cpp-node-1/</id>
    <published>2020-05-21T16:16:01.000Z</published>
    <updated>2020-05-23T07:41:09.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><ul><li><p>电脑环境: macOS 10.15.4</p></li><li><p>安装好<code>xcode</code></p></li><li>安装<code>node-gyp</code></li><li>自带<code>node</code></li></ul><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521220817.png" alt="image-20200521220817431"></p><a id="more"></a><h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><ol><li><p><code>node-gyp install</code>将 <code>Node.js</code> 源码的一些头文件下载到本地目录。</p></li><li><p>目录结构为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521221347.png" alt="image-20200521221347878"></p></li></ol><p>然后找到官方的 <a href="https://github.com/XadillaX/nyaa-nodejs-demo" target="_blank" rel="noopener">repo</a></p><p>进到<code>1.first build</code> 目录中去，可以在目录下执行下面的命令:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521221950.png" alt="image-20200521221950469"></p><ul><li><code>node-gyp configure</code>生成一些构建源码的项目文件。这一步会生成一个<code>build</code>目录出来里面有<code>Makefile</code>文件和一些必要的配置文件</li><li><code>node-gyp build</code>用于将当前所在目录的模块进行重构，将Cpp代码编译成二进制文件。这时会在<code>build/Release/</code> 目录下生成一个<code>first.node</code>文件出来</li></ul><p>然后可以在命令行工具里面使用<code>node</code>环境来引入我们构建出来的模块:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521222531.png" alt="image-20200521222531450"></p><ul><li><code>node-gyp clean</code> 用于清理生成的构建文件 &amp; <code>out</code>目录。</li></ul><p>当然有个懒人命令 <code>node-gyp rebuild</code> 能够依次去执行<code>node-gyp clean</code>、<code>node-gyp configure</code>、<code>node-gyp build</code>。</p><p><strong><code>node-gyp</code>的构建原理:在安装  C++ 原生模块时，使用 <code>GYP</code> 通过一个<code>binding.gyp</code>文件来构建各系统所需要的<code>C++</code>项目文件(mac下面是<code>makefile</code>文件)</strong>。</p><p> 基于上面的原理，其实nodejs里面其他的cpp的构建工具都大同小异，只不过<code>node-gyp</code> 是官方支持，所以不需要嵌入任何的脚本，其他构建工具需要在<code>package.json</code>的<code>scripts</code>中加入一些脚本使其在包安装阶段能够执行构建。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础环境&quot;&gt;&lt;a href=&quot;#基础环境&quot; class=&quot;headerlink&quot; title=&quot;基础环境&quot;&gt;&lt;/a&gt;基础环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;电脑环境: macOS 10.15.4&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装好&lt;code&gt;xcode&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;node-gyp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自带&lt;code&gt;node&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521220817.png&quot; alt=&quot;image-20200521220817431&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的回溯模板题目</title>
    <link href="http://zoomdong.site/2020/05/20/dfs-template/"/>
    <id>http://zoomdong.site/2020/05/20/dfs-template/</id>
    <published>2020-05-20T04:00:00.000Z</published>
    <updated>2020-05-24T16:34:50.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法解题框架"><a href="#回溯算法解题框架" class="headerlink" title="回溯算法解题框架"></a>回溯算法解题框架</h2><p>解决一个回溯问题，需要考虑以下三个问题:</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表：当前能做的选择</li><li>结束条件：达到决策树的底层无法在做出选择</li></ul><p>代码框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrap(路径，选择列表):</span><br><span class="line">  if 满足结束条件:</span><br><span class="line">    result.add(路径)</span><br><span class="line">    return</span><br><span class="line">  for 选择 in 选择列表:</span><br><span class="line">    做选择</span><br><span class="line">    backtrap(路径,选择列表)</span><br><span class="line">    撤销选择</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>核心其实就是for循环里面的递归，在递归调用之前“做出一个选择”，在递归调用之后”撤销选择“</strong>。</p><p>通过题目来做一些理解吧</p><p>明人不说暗话，直接上全排列:</p><h2 id="lc46"><a href="#lc46" class="headerlink" title="lc46"></a>lc46</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><p>这题就是一个很典型的回溯板子</p><p>因为这里我们需要撤销一下之前的走过的选项，所以<strong>就需要递归前选元素，递归之后再撤销刚才的选择</strong>。</p><p>直接看一波代码吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> temp = []</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">temp, nums</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (temp.length === nums.length) &#123;</span><br><span class="line">          res.push([...temp])</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">          <span class="keyword">if</span>(temp.includes(item)) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 做出选择</span></span><br><span class="line">          temp.push(item)</span><br><span class="line">          <span class="comment">// 回溯一波</span></span><br><span class="line">          dfs(temp, nums)</span><br><span class="line">          <span class="comment">// 回溯走完之后把选择的元素pop走</span></span><br><span class="line">          temp.pop()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], nums)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc784"><a href="#lc784" class="headerlink" title="lc784"></a>lc784</h2><p>题目链接:<a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-case-permutation/</a></p><p>这题其实也是个回溯。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">var letterCasePermutation = <span class="keyword">function</span>(S) &#123;</span><br><span class="line">   let res = []</span><br><span class="line">   S = S.split(<span class="string">''</span>)</span><br><span class="line">   let <span class="keyword">temp</span> = []</span><br><span class="line">   const dfs = (<span class="keyword">temp</span>, S,<span class="keyword">index</span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">index</span> === S.length) &#123;</span><br><span class="line">           res.push(S.<span class="keyword">join</span>(<span class="string">''</span>))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果当前字符是英文字母，那么就进行一波回溯操作</span><br><span class="line">       <span class="keyword">if</span>((<span class="string">'A'</span> &lt;=S[<span class="keyword">index</span>]&amp;&amp; S[<span class="keyword">index</span>] &lt;= <span class="string">'Z'</span>) || (<span class="string">'a'</span> &lt;= S[<span class="keyword">index</span>] &amp;&amp; S[<span class="keyword">index</span>] &lt;=<span class="string">'z'</span>)) &#123;</span><br><span class="line">           S[<span class="keyword">index</span>] = S[<span class="keyword">index</span>].toLowerCase()</span><br><span class="line">           dfs(<span class="keyword">temp</span>, S, <span class="keyword">index</span> + <span class="number">1</span>)</span><br><span class="line">           S[<span class="keyword">index</span>] = S[<span class="keyword">index</span>].toUpperCase()</span><br><span class="line">           dfs(<span class="keyword">temp</span>, S, <span class="keyword">index</span> + <span class="number">1</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           // 如果是数字，直接去递归就好了</span><br><span class="line">           dfs(<span class="keyword">temp</span>, S, <span class="keyword">index</span> + <span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   dfs(<span class="keyword">temp</span>, S, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="lc51-n皇后问题"><a href="#lc51-n皇后问题" class="headerlink" title="lc51 n皇后问题"></a>lc51 n皇后问题</h3><p>题目链接:<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><p>规则:有个 N * N 的棋盘，让你放置 N 个皇后，使他们不能互相攻击。</p><p>PS: 攻击的规则是皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上是和全排列差不多的，决策树的每一层表示棋盘上的每一行;每个节点都可以做出的选择是，在该行的任意一列放置一个皇后:</p><p>先写一波伪代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// . 表示空盘，Q表示皇后，初始化空棋盘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">      board[i][j] = <span class="string">'.'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> backtrap = <span class="function">(<span class="params">board, row</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row === board.length) &#123;</span><br><span class="line">      res.push(board)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> n = board[row].length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">      <span class="comment">// 不符合规定的选择直接pass掉</span></span><br><span class="line">      <span class="keyword">if</span> (!isValid(board, row, col)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 做出选择</span></span><br><span class="line">      board[row][col] = <span class="string">'Q'</span></span><br><span class="line">      <span class="comment">// 进入下一行决策</span></span><br><span class="line">      backtrap(board, row + <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 撤销掉之前的选择</span></span><br><span class="line">      board[row][col] = <span class="string">'.'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backtrap(board, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要部分的代码其实和全排列差不多，<code>isValid</code>函数的实现为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isvalid = <span class="function">(<span class="params">board, row, col</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = board.length</span><br><span class="line">  <span class="comment">// 检查当前列是否有皇后</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(board[i][col] === <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查右上是否有皇后</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col + <span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n;i--;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j] === <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查左上是否有皇后</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>,j=col - <span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>;i--,j--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j] === <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lc-水域大小"><a href="#lc-水域大小" class="headerlink" title="lc 水域大小"></a>lc 水域大小</h2><p>这题其实是个典型的dfs找联通块的题目，有8个方向:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">land</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pondSizes = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = grid.length</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> n = grid[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">grid, i, j, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = res</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, res)</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, res)</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j + <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j - <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j + <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j - <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, res)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(grid, i, j, res--)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        hash.set(grid[i][j], hash.has(grid[i][j]) ? hash.get(grid[i][j]) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ret = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> hash) &#123;</span><br><span class="line">    ret.push(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(</span></span><br><span class="line"><span class="comment">//   pondSizes([</span></span><br><span class="line"><span class="comment">//     [0, 2, 1, 0],</span></span><br><span class="line"><span class="comment">//     [0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">//     [1, 1, 0, 1],</span></span><br><span class="line"><span class="comment">//     [0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">//   ]),</span></span><br><span class="line"><span class="comment">// )</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回溯算法解题框架&quot;&gt;&lt;a href=&quot;#回溯算法解题框架&quot; class=&quot;headerlink&quot; title=&quot;回溯算法解题框架&quot;&gt;&lt;/a&gt;回溯算法解题框架&lt;/h2&gt;&lt;p&gt;解决一个回溯问题，需要考虑以下三个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径：也就是已经做出的选择&lt;/li&gt;
&lt;li&gt;选择列表：当前能做的选择&lt;/li&gt;
&lt;li&gt;结束条件：达到决策树的底层无法在做出选择&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码框架：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def backtrap(路径，选择列表):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if 满足结束条件:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result.add(路径)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for 选择 in 选择列表:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    做选择&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    backtrap(路径,选择列表)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    撤销选择&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-http请求流程</title>
    <link href="http://zoomdong.site/2020/05/19/broswer-3/"/>
    <id>http://zoomdong.site/2020/05/19/broswer-3/</id>
    <published>2020-05-19T12:27:08.000Z</published>
    <updated>2020-05-20T15:06:05.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-请求流程"><a href="#http-请求流程" class="headerlink" title="http 请求流程"></a>http 请求流程</h2><p>HTTP协议，正是建立在 TCP 连接的基础之上。HTTP是一种允许浏览器上服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件。http也是浏览器使用最多的最广的协议。</p><h2 id="浏览器端发起http请求"><a href="#浏览器端发起http请求" class="headerlink" title="浏览器端发起http请求"></a>浏览器端发起http请求</h2><p>如果你在浏览器里面输入一个url，浏览器会完成哪些动作呢？</p><h3 id="1-构建请求"><a href="#1-构建请求" class="headerlink" title="1.构建请求"></a>1.构建请求</h3><p>首先，浏览器构建请求行信息，构建好后浏览器发起请求。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> /<span class="keyword">index</span>.html HTTP1<span class="number">.1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-查找缓存"><a href="#2-查找缓存" class="headerlink" title="2.查找缓存"></a>2.查找缓存</h3><p>在真正发起请求之前，浏览器会先在浏览器缓存中查询是否有需要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</strong></p><p>浏览器发现请求的资源已经有缓存的副本，它会直接拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器里面去下载。这样的好处有：</p><ul><li>缓解服务端压力，提升性能(获取资源的耗时更短了)</li><li>对于网站来说，缓存时实现快速资源加载的重要组成部分</li></ul><p>如果缓存失败，就会进入网络请求过程了。</p><h3 id="3-准备-IP-地址和端口"><a href="#3-准备-IP-地址和端口" class="headerlink" title="3.准备 IP 地址和端口"></a>3.准备 IP 地址和端口</h3><p>浏览器使用HTTP作为应用层协议，用来封装请求的文本信息；并使用<strong>TCP/IP 做传输层协议</strong>将它发到网络上去</p><p>，所以在HTTP开始工作之前，浏览器需要通过TCP与服务器先建立连接。HTTP 的内容是通过TCP的<strong>传输数据阶段来实现的</strong>。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519095343.png" alt="image-20200519095343595"></p><p>在上一节中，有讲到数据包都是通过 IP 地址传输给接受方。由于 IP 地址是数学标识，比较难记，使用域名就会容易记忆，所以基于域名和IP的映射关系又出现了一套服务，负责把域名和IP地址做一一映射的关系。这套服务就叫做“域名系统”，简称<code>DNS</code>。</p><p>所以这样推导下来，<strong>第一步浏览器会请求 DNS 返回域名对应的IP。</strong>浏览器也提供DNS数据缓存服务，如果某个域名解析过了，那么浏览器就会缓存解析的结果，下次查询的时候可以直接使用。</p><p>拿到IP之后，就会去获取端口号，一般在没有指明端口的情况下，HTTP默认端口号是80。</p><h3 id="4-等待TCP队列"><a href="#4-等待TCP队列" class="headerlink" title="4.等待TCP队列"></a>4.等待TCP队列</h3><p>IP地址和端口都准备好的情况下，也不会直接建立 TCP 链接，根据<code>Chrome</code>的机制，同一个域名同时最多只能建立 6 个 TCP 连接。如果同一域名下同时有 10 个请求，其中 4 个请求就会进入排队等待状态，直到进行中的请求结束。</p><p>如果当前请求数量小于 6，就会直接进入下一步连接。</p><h3 id="5-建立TCP连接"><a href="#5-建立TCP连接" class="headerlink" title="5.建立TCP连接"></a>5.建立TCP连接</h3><p>排队等待结束之后，就可和服务器快乐握手了。过程参考上一篇文章。</p><h3 id="6-发送HTTP请求"><a href="#6-发送HTTP请求" class="headerlink" title="6.发送HTTP请求"></a>6.发送HTTP请求</h3><p>一旦建立了 TCP 链接，浏览器就可以和服务器通信了。而 HTTP 中的数据正是在这个通信过程中完成。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519200612.png" alt="image-20200519200612664"></p><p>浏览器会向服务器发送<strong>请求头</strong>，它包含了<strong>请求方法、请求 URI 和 HTTP 协议版本</strong></p><p>具体参数含义可自行百度。</p><h3 id="7-服务端处理-HTTP-请求流程"><a href="#7-服务端处理-HTTP-请求流程" class="headerlink" title="7.服务端处理 HTTP 请求流程"></a>7.服务端处理 HTTP 请求流程</h3><h4 id="1-返回请求"><a href="#1-返回请求" class="headerlink" title="1. 返回请求"></a>1. 返回请求</h4><p>服务器处理结束之后，就会把数据返回给浏览器。可以通过工具软件 <code>curl</code> 来查看返回的请求数据，具体使用方法是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">curl</span> <span class="selector-tag">-i</span> <span class="selector-tag">baidu</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>返回的数据格式为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519201116.png" alt="image-20200519201116461"></p><p>首先会返回响应行。包括有协议版本和状态码。</p><p>服务器会通过状态码告诉浏览器处理结果。</p><p>发送完响应头之后，服务器就可以继续发送响应体数据，一般里面会包括 HTML 的实际内容。</p><h4 id="2-断开连接"><a href="#2-断开连接" class="headerlink" title="2.断开连接"></a>2.断开连接</h4><p>一般情况下，服务端返回了数据后，就会关闭 TCP 连接。不过浏览器或者服务器在其头信息中加入了:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Connection</span>: <span class="meta">keep</span>-Alive</span><br></pre></td></tr></table></figure><p>这样在发送之后就仍然可以保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。<strong>保持 TCP 连接可以省去下次请求时需要连接的时间，提升资源加载速度。 </strong></p><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3.重定向"></a>3.重定向</h3><p>到这里请求流程似乎就结束了，不过还有种情况时需要考虑的，例如我们打开<code>geekbang.org</code>之后，最终的页面地址是<code>https://www.geekbang.org</code></p><p>两个url不同的原因是因为会有个重定向的操作。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="literal">I</span> geekbang.org // 大写 <span class="literal">I</span> 表示只需要响应头和响应行数据，不需要响应体</span><br></pre></td></tr></table></figure><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519202211.png" alt="image-20200519202211622"></p><p>极客时间上还有个问题解答，可以去看一看:<a href="https://time.geekbang.org/column/article/116588" target="_blank" rel="noopener">https://time.geekbang.org/column/article/116588</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http-请求流程&quot;&gt;&lt;a href=&quot;#http-请求流程&quot; class=&quot;headerlink&quot; title=&quot;http 请求流程&quot;&gt;&lt;/a&gt;http 请求流程&lt;/h2&gt;&lt;p&gt;HTTP协议，正是建立在 TCP 连接的基础之上。HTTP是一种允许浏览器上服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件。http也是浏览器使用最多的最广的协议。&lt;/p&gt;
&lt;h2 id=&quot;浏览器端发起http请求&quot;&gt;&lt;a href=&quot;#浏览器端发起http请求&quot; class=&quot;headerlink&quot; title=&quot;浏览器端发起http请求&quot;&gt;&lt;/a&gt;浏览器端发起http请求&lt;/h2&gt;&lt;p&gt;如果你在浏览器里面输入一个url，浏览器会完成哪些动作呢？&lt;/p&gt;
&lt;h3 id=&quot;1-构建请求&quot;&gt;&lt;a href=&quot;#1-构建请求&quot; class=&quot;headerlink&quot; title=&quot;1.构建请求&quot;&gt;&lt;/a&gt;1.构建请求&lt;/h3&gt;&lt;p&gt;首先，浏览器构建请求行信息，构建好后浏览器发起请求。&lt;/p&gt;
&lt;figure class=&quot;highlight pgsql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;GET&lt;/span&gt; /&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;.html HTTP1&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-网络数据包的传输</title>
    <link href="http://zoomdong.site/2020/05/18/broswer-2/"/>
    <id>http://zoomdong.site/2020/05/18/broswer-2/</id>
    <published>2020-05-18T06:23:54.000Z</published>
    <updated>2020-05-18T06:24:59.682Z</updated>
    
    <content type="html"><![CDATA[<p>衡量 Web 页面性能有个重要的指标叫做:<code>FP</code>(First Paint),是指从<strong>页面加载到首次开始绘制的时长</strong>。更少的FP意味着更多的PV，更高的参与度、以及转换率。影响其的一个很重要的因素就是<strong>网络加载速度</strong>。</p><p>想要优化网页的加载速度，需要对网络有一个深入的认识。</p><h2 id="数据包的传输过程"><a href="#数据包的传输过程" class="headerlink" title="数据包的传输过程"></a>数据包的传输过程</h2><p><strong>互联网实际是一套理论和协议组成的体系架构。</strong>其中，因为有了协议这一众所周知的规则和标准，各方都同意使用 的前提下，那么它们的通信之间将变得毫无障碍。</p><p>互联网中的数据是通过数据包来传输的。发送的数据很大的话，会被拆成很多小的包来传输。例如音频数据就并不是一个大的文件。</p><a id="more"></a><h3 id="1-IP-数据包送往目标主机"><a href="#1-IP-数据包送往目标主机" class="headerlink" title="1.IP:数据包送往目标主机"></a>1.IP:数据包送往目标主机</h3><p>如果想把数据包从主机 A 发送给 B，在传输之前，数据包会有B的IP地址信息，这样在传输过程中才能正确寻址。数据包上还会附加上A的IP信息，有了这些信息B才可以回复信息给主机A。这些信息都会放在一个叫IP头都数据结构里面，它是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等。<a href="[https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE](https://zh.wikipedia.org/wiki/传输控制协议">具体了解</a>)</p><p>为了便于理解，可以把网络简单分成三层结构：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518093817.png" alt="image-20200518093817351"></p><p>过程是这样的：</p><ul><li>上层将有“极客时间”的数据交给网络层</li><li>网络层再将IP头附加到数据包上，组成新的<strong>IP数据包</strong>，交给底层</li><li>底层通过物理网络将数据包传给B</li><li>数据包被传输到主机B的网络层，主机B拆开数据包的IP信息，并把拆开的数据部分交给上层</li><li>最后，数据就到主机B的上层了</li></ul><h3 id="UDP-数据包送到应用层序"><a href="#UDP-数据包送到应用层序" class="headerlink" title="UDP:数据包送到应用层序"></a>UDP:数据包送到应用层序</h3><p>IP是底层的协议，它只负责传送数据包到对方的电脑，但是对方电脑不知道把数据包交给哪一个程序。因此有了基于IP之上开发能和应用打交道的协议，最常见的就是<strong>“用户数据协议”(User Datagram Protocol)</strong>,简称<strong>UDP</strong>。</p><p>UDP中最重要的信号是<strong>端口号</strong>，每个想访问网络的应用程序都得绑定一个端口号。通过端口号就能把指定的数据包发给指定的应用程序，<strong>IP通过地址信息来发包到主机，UDP根据端口号来发包到应用程序。</strong>和IP头一样，端口号会被装进UDP头里面，UDP头再和原始的数据包合并成新的UDP数据包。UDP同时也包括源端口号和目标端口号。</p><p>为了支持UDP，现在的网络的三层传输结构可以扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518094858.png" alt="image-20200518094858296"></p><p>现在的过程就成了:</p><ul><li>上层将含有传输信息的数据包给传输层</li><li>传输层会在数据包上加上UDP头，组成一个UDP的数据包，再将UDP包交给网络层</li><li>网络层附加IP头，组成IP数据包给底层</li><li>数据包传输到主机B的网络层并被解析，部分数据被丢（IP）</li><li>传输层中，数据包中的UDP头被拆开，被根据UDP中提供的端口信息，把数据给应用程序</li><li>最后数据包到了B的上层应用程序</li></ul><p>使用UDP发送数据的时候，有各种因素会导致数据包出错，UDP可以校验数据是否正确，但错误的包并不会提供重发的机制，只是丢弃当前包，而且在发送之后也不知道能否达到目的地。</p><p><strong>UDP不能保证数据可靠，但是传输速度却很快。</strong></p><h3 id="TCP：数据完整送达应用程序"><a href="#TCP：数据完整送达应用程序" class="headerlink" title="TCP：数据完整送达应用程序"></a>TCP：数据完整送达应用程序</h3><p>对于一些要求数据传输可靠的应用程序，例如邮件和浏览器请求，UDP带来的问题:</p><ul><li>数据包在传输过程中容易丢失</li><li>大文件被拆成许多小的数据包来传输，小的数据包过不同的路由，不同时间到接收端，UDP协议不知道怎么组装这些数据包，从而将数据包还原成完整的组件</li></ul><p>为了解决这些问题，TCP(传输控制协议)就出现了。他是一种面向连接的、可靠的、基于字节流的传输层通信协议。优点相较于TCP有：</p><ul><li>对于数据包丢失的情况，TCP提供重传机制</li><li>TCP引入数据包排序机制，保证将乱序的数据包组合成一个完整的文件</li></ul><p>和UDP头一样，TCP头除了包含目标端口和本机端口之外，还提供了排序序列号来重排数据包。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518100357.png" alt="image-20200518100357594"></p><p>TCP 的传输模型整体上来看是和UDP差不多的。不同的地方在于，通过TCP头的信息保证了一块大的数据大传输完整性。</p><p>完成的TCP连接生命周期包括：<strong>建立连接</strong>、<strong>传输数据</strong>、<strong>断开连接</strong>。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518141751.png" alt="image-20200518141751565"></p><ul><li>建立连接。这个阶段通过“三次握手”来建立client 和server之间的通信。TCP提供面向连接的通信传输。<strong>面向连接</strong>是在数据通信开始之前先做好两端之间的准备工作。<strong>三次握手</strong>指在建立TCP，客户端和服务端要发送三个数据包以确认连接。</li><li>传输数据。这个阶段，接收端要对每个数据包进行确认操作。会返回给发送端一个确认消息，发送端没收到的话，就会启动重发机制。大的文件包也会根据TCP头中的序列号去进行一个拼接。</li><li>断开连接。数据传输完成之后，来一波四次挥手。</li></ul><p>TCP为了保证数据传输的可靠性和稳定性，牺牲了传输速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;衡量 Web 页面性能有个重要的指标叫做:&lt;code&gt;FP&lt;/code&gt;(First Paint),是指从&lt;strong&gt;页面加载到首次开始绘制的时长&lt;/strong&gt;。更少的FP意味着更多的PV，更高的参与度、以及转换率。影响其的一个很重要的因素就是&lt;strong&gt;网络加载速度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;想要优化网页的加载速度，需要对网络有一个深入的认识。&lt;/p&gt;
&lt;h2 id=&quot;数据包的传输过程&quot;&gt;&lt;a href=&quot;#数据包的传输过程&quot; class=&quot;headerlink&quot; title=&quot;数据包的传输过程&quot;&gt;&lt;/a&gt;数据包的传输过程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;互联网实际是一套理论和协议组成的体系架构。&lt;/strong&gt;其中，因为有了协议这一众所周知的规则和标准，各方都同意使用 的前提下，那么它们的通信之间将变得毫无障碍。&lt;/p&gt;
&lt;p&gt;互联网中的数据是通过数据包来传输的。发送的数据很大的话，会被拆成很多小的包来传输。例如音频数据就并不是一个大的文件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 加速 git clone</title>
    <link href="http://zoomdong.site/2020/05/17/mbp%E5%8A%A0%E9%80%9Fgit-clone/"/>
    <id>http://zoomdong.site/2020/05/17/mbp加速git-clone/</id>
    <published>2020-05-17T10:32:11.000Z</published>
    <updated>2020-05-17T10:32:34.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置-shadowsocks-代理"><a href="#配置-shadowsocks-代理" class="headerlink" title="配置 shadowsocks 代理"></a>配置 shadowsocks 代理</h2><p>即小飞机</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200517175437.png" alt="image-20200517175437615"></p><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200517175503.png" alt="image-20200517175502982"></p><p>点击高级配置一波代理：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200517181844.png" alt="image-20200517181844309"></p><p>然后在命令行里面使用如下的命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global http.proxy <span class="string">'socks5://127.0.0.1:1086'</span></span><br><span class="line">git<span class="built_in"> config </span>--global https.proxy <span class="string">'socks5://127.0.0.1:1086'</span></span><br></pre></td></tr></table></figure><p>然后就可以加速处理了。</p><h2 id="取消加速代理"><a href="#取消加速代理" class="headerlink" title="取消加速代理"></a>取消加速代理</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global --unset http.proxy</span><br><span class="line">git<span class="built_in"> config </span>--global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置-shadowsocks-代理&quot;&gt;&lt;a href=&quot;#配置-shadowsocks-代理&quot; class=&quot;headerlink&quot; title=&quot;配置 shadowsocks 代理&quot;&gt;&lt;/a&gt;配置 shadowsocks 代理&lt;/h2&gt;&lt;p&gt;即小飞机&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的 BFS 模板题目</title>
    <link href="http://zoomdong.site/2020/05/14/bfs-template/"/>
    <id>http://zoomdong.site/2020/05/14/bfs-template/</id>
    <published>2020-05-14T05:39:54.000Z</published>
    <updated>2020-05-23T13:29:28.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bfs解题框架"><a href="#bfs解题框架" class="headerlink" title="bfs解题框架"></a>bfs解题框架</h2><p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener">参考文章</a></p><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>bfs题目出现的常见场景：<strong>问题的本质实际上是在一张图里面找从 start 到 end 的最近距离</strong></p><p>广义的描述有很多的题目变形:例如走迷宫、有的格子不能走、起点到终点的最短路？有瞬间传送的门？</p><a id="more"></a><p>参考 labuladong算法笔记是可以有一个bfs的算法迭代框架的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span> <span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">  Queue&lt;Node&gt; q;</span><br><span class="line">  <span class="comment">// 用来去重的数据结构</span></span><br><span class="line">  Set&lt;Node&gt; visited;</span><br><span class="line">  <span class="comment">// 起点进入队列</span></span><br><span class="line">  q.offer(start);</span><br><span class="line">  <span class="comment">// 标记</span></span><br><span class="line">  visited.add(start);</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (q <span class="keyword">not</span> empty) &#123;</span><br><span class="line">    <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 将队列中的节点四周扩散</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">      Node cur = q.poll()</span><br><span class="line">      <span class="comment">// 边界条件，如果这个点到了终点，就返回路径的值</span></span><br><span class="line">      <span class="keyword">if</span> (cur === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不满足则将周围的点加到队列里面来</span></span><br><span class="line">      <span class="keyword">for</span> (Node x in cur.adj()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">not</span> in visited) &#123;</span><br><span class="line">          q.offer(x);</span><br><span class="line">          visited.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次走完之后更新一下路径</span></span><br><span class="line">  <span class="built_in">step</span> ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面 <code>cur.adj()</code> 就代表cur附近相邻的节点;visited的作用主要是为了防止走回头路，但一般的二叉树结构，没有子节点到父节点到指针，不会走回头路就不需要<code>visited</code>。</p><p>下面可以找一些具体的题目来使用这些框架:</p><h3 id="lc-111"><a href="#lc-111" class="headerlink" title="lc#111"></a>lc#111</h3><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">题目链接</a></p><p>这题因为是找最小的深度其实也是可以用<code>bfs</code>板子写的，其实还挺简单的hhh<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">1</span>;</span><br><span class="line">  queue.push(root)</span><br><span class="line">  <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">      <span class="keyword">if</span> (!cur.left &amp;&amp; !cur.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      cur.left &amp;&amp; queue.push(cur.left)</span><br><span class="line">      cur.right &amp;&amp; queue.push(cur.right)</span><br><span class="line">    &#125;</span><br><span class="line">    step ++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> step;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="lc-752"><a href="#lc-752" class="headerlink" title="lc#752"></a>lc#752</h3><p><a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">题目链接</a></p><p>这题虽然看上去不是很容易发现是bfs（就我自己而言不知道怎么去搜索），实际上我们以’0000’为起点去进行一个搜索，把所有的情况用bfs搜一遍，就可以了，具体思路可以参考代码里面的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">deadends</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> openLock = <span class="function"><span class="keyword">function</span> (<span class="params">deadends, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理锁的情况</span></span><br><span class="line">  <span class="keyword">const</span> plusOne = <span class="function">(<span class="params">str, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (s[index] === <span class="string">'9'</span>) &#123;</span><br><span class="line">      s[index] = <span class="string">'0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s[index] = <span class="built_in">String</span>.fromCharCode(s[index].charCodeAt() + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> minusOne = <span class="function">(<span class="params">str, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (s[index] === <span class="string">'0'</span>) &#123;</span><br><span class="line">      s[index] = <span class="string">'9'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s[index] = <span class="built_in">String</span>.fromCharCode(s[index].charCodeAt() - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录边界值</span></span><br><span class="line">  <span class="keyword">let</span> deads = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> deadends) &#123;</span><br><span class="line">    deads.set(item, deads.get(item) ? deads.get(item) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录已经走过的密码情况</span></span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  queue.push(<span class="string">'0000'</span>)</span><br><span class="line">  visited.set(<span class="string">'0000'</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">while</span> (queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">      <span class="comment">// 走重了</span></span><br><span class="line">      <span class="keyword">if</span> (deads.has(cur)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 到了</span></span><br><span class="line">      <span class="keyword">if</span> (cur === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理一下节点的遍历</span></span><br><span class="line">      <span class="comment">// 这题不好处理的地方就在这个地方。开始没有想到可以这样去访问周围的情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> up = plusOne(cur, j)</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(up)) &#123;</span><br><span class="line">          queue.push(up)</span><br><span class="line">          visited.set(up, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> down = minusOne(cur, j)</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(down)) &#123;</span><br><span class="line">          queue.push(down)</span><br><span class="line">          visited.set(down, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(queue);</span></span><br><span class="line">    step++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(openLock(['0201', '0101', '0102', '1212', '2002'], '0202'))</span></span><br></pre></td></tr></table></figure><h3 id="lc279"><a href="#lc279" class="headerlink" title="lc279"></a>lc279</h3><p>这题其实可以dp,也可以bfs,因为就相当于要找到一个类似于最短路径的概念，这里也要明白bfs这个过程是怎么进行的(这里还是使用bfs模版来搞一搞):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  queue.push(n)</span><br><span class="line">  visited.set(n, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">      <span class="comment">// 处理一下下一轮队列的情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = cur - j * j</span><br><span class="line">        <span class="keyword">if</span> (now === <span class="number">0</span>) &#123;</span><br><span class="line">          step++</span><br><span class="line">          <span class="keyword">return</span> step</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果now这个值没有被标记，送进下一轮bfs</span></span><br><span class="line">        <span class="keyword">if</span> (!visited.has(now)) &#123;</span><br><span class="line">          queue.push(now)</span><br><span class="line">          visited.set(now, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numSquares(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><h3 id="lc1284-转化为全零矩阵的最少反转次数"><a href="#lc1284-转化为全零矩阵的最少反转次数" class="headerlink" title="lc1284 转化为全零矩阵的最少反转次数"></a>lc1284 转化为全零矩阵的最少反转次数</h3><p>这题每次bfs存每次数组转换之后的状态就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">mat</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 反转指的是能够将 0-&gt; 1 1-&gt; 0 每次反转相邻边上的单元格也被翻转</span></span><br><span class="line"><span class="comment">// 求最小反转次数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1,1,1</span></span><br><span class="line"><span class="comment"> * 1,0,1 -&gt;</span></span><br><span class="line"><span class="comment"> * 0 0 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 直接使用js的map来对每一次对状态进行一个存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> minFlips = <span class="function"><span class="keyword">function</span> (<span class="params">mat</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = mat.length,</span><br><span class="line">    n = mat[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> first = <span class="built_in">JSON</span>.stringify(mat)</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  queue.push(first)</span><br><span class="line">  visited.set(first, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> judge = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用来改变单元格当前的值</span></span><br><span class="line">  <span class="keyword">const</span> changeArr = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">      arr[i][j] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[i][j] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变单元格及其周围单元格的值</span></span><br><span class="line">  <span class="keyword">const</span> change = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    arr = changeArr(arr, i, j)</span><br><span class="line">    <span class="keyword">let</span> dir = [</span><br><span class="line">      [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">      [<span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">      [<span class="number">-1</span>, <span class="number">0</span>],</span><br><span class="line">      [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        i + dir[k][<span class="number">0</span>] &lt; <span class="number">0</span> ||</span><br><span class="line">        i + dir[k][<span class="number">0</span>] &gt;= m ||</span><br><span class="line">        j + dir[k][<span class="number">1</span>] &lt; <span class="number">0</span> ||</span><br><span class="line">        j + dir[k][<span class="number">1</span>] &gt;= n</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr = changeArr(arr, i + dir[k][<span class="number">0</span>], j + dir[k][<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bfs直接搜一波的</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = queue.shift()</span><br><span class="line">      <span class="keyword">let</span> item2 = <span class="built_in">JSON</span>.parse(item)</span><br><span class="line">      <span class="comment">// bfs的终点条件</span></span><br><span class="line">      <span class="keyword">if</span> (judge(item2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 直接去搜所有的状态，然后放进去队列里面</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; m; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">          item3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(item2))</span><br><span class="line">          <span class="keyword">let</span> changeArr = <span class="built_in">JSON</span>.stringify(change(item3, x, y))</span><br><span class="line">          <span class="keyword">if</span> (visited.has(changeArr)) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.push(changeArr)</span><br><span class="line">            visited.set(changeArr, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lc301-删除无效的括号"><a href="#lc301-删除无效的括号" class="headerlink" title="lc301 删除无效的括号"></a>lc301 删除无效的括号</h3><p>这题也是一个很有意思的bfs，其实想法挺简单的，每一层都只删一个括号，然后往下去找，直到某一层有结果了直接把这一层符合条件的结果收集起来输出出去就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">var</span> removeInvalidParentheses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isvalid = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    str = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === <span class="string">'('</span>) &#123;</span><br><span class="line">        stack.push(item)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(item === <span class="string">')'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> item1 = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> (item1 !== <span class="string">'('</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="comment">// 直接遍历去删</span></span><br><span class="line">  visited.set(s, <span class="number">1</span>)</span><br><span class="line">  queue.push(s)</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = queue.shift()</span><br><span class="line">      <span class="keyword">if</span> (isvalid(item) &amp;&amp; item) &#123;</span><br><span class="line">        res.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; item.length; k++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item3 = <span class="string">''</span></span><br><span class="line">        <span class="comment">// 只用删括号</span></span><br><span class="line">        <span class="keyword">if</span> (item[k] === <span class="string">'('</span> || item[k] === <span class="string">')'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (k === <span class="number">0</span>) &#123;</span><br><span class="line">            item3 = item.slice(<span class="number">1</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k === item.length - <span class="number">1</span>) &#123;</span><br><span class="line">            item3 = item.slice(<span class="number">0</span>, k)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            item3 = item.slice(<span class="number">0</span>, k) + item.slice(k + <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited.has(item3)) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          visited.set(item3, <span class="number">1</span>)</span><br><span class="line">          queue.push(item3)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++</span><br><span class="line">    <span class="keyword">if</span> (res.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(removeInvalidParentheses('()())()'))</span></span><br><span class="line"><span class="comment">// console.log(removeInvalidParentheses("(a)())()"))</span></span><br></pre></td></tr></table></figure><p>但是注意里面字符还有不是括号的，做好特判就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;bfs解题框架&quot;&gt;&lt;a href=&quot;#bfs解题框架&quot; class=&quot;headerlink&quot; title=&quot;bfs解题框架&quot;&gt;&lt;/a&gt;bfs解题框架&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法框架&quot;&gt;&lt;a href=&quot;#算法框架&quot; class=&quot;headerlink&quot; title=&quot;算法框架&quot;&gt;&lt;/a&gt;算法框架&lt;/h3&gt;&lt;p&gt;bfs题目出现的常见场景：&lt;strong&gt;问题的本质实际上是在一张图里面找从 start 到 end 的最近距离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广义的描述有很多的题目变形:例如走迷宫、有的格子不能走、起点到终点的最短路？有瞬间传送的门？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-Chrome架构演变</title>
    <link href="http://zoomdong.site/2020/05/14/broswer-1/"/>
    <id>http://zoomdong.site/2020/05/14/broswer-1/</id>
    <published>2020-05-13T16:23:44.000Z</published>
    <updated>2020-05-13T16:31:52.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="chrome-架构"><a href="#chrome-架构" class="headerlink" title="chrome 架构"></a>chrome 架构</h2><p>一般我们使用chrome浏览器打开一个网页的时候，打开浏览器的任务管理器可以发现会发现chrome在这个时候会启用多个进程窗口。(同windows一样，chrome任务管理器也是用来展示运行中chrome使用进程信息的。)</p><p>这里就会涉及到chrome的<strong>多进程架构</strong>。</p><h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>计算机的并行处理就是指在同一时刻处理多个任务，性能是要高于正常情况下用单线程来处理的。</p><h2 id="线程-and-进程"><a href="#线程-and-进程" class="headerlink" title="线程 and 进程"></a>线程 and 进程</h2><p>多线程可以并行处理任务，但是<strong>线程不能存在的，还需要进程来启动和管理</strong>。</p><p>进程指的是一个程序的运行实例：启动一个程序时，OS会为程序创建一块内存，用来存放代码、运行中的数据、和一个执行任务的主线程，这样的一个环境就可以叫做<strong>进程</strong>。</p><p><img src="/2020/05/14/broswer-1/image-20200513225045754.png" alt="image-20200513225045754"></p><p>如图所示，线程是依附于进程的，进程中使用多线程并行处理是能够提升运行效率。</p><a id="more"></a><p>进程和线程的关系有以下几个特点:</p><ul><li>进程中的任一线程执行出错，都会导致整个进程的崩溃</li><li><p>线程之间共享进程的数据</p><ul><li>线程之间可以对进程的公共数据进行读写操作</li></ul></li><li><p>当一个进程关闭之后，操作系统会回收进程所占用的内存</p><ul><li>当一个进程关闭的时候，操作系统会回收该进程所申请的所有资源;即使线程导致的内存泄漏都会在进程退出之后进行回收</li></ul></li><li>进程之间的内容相互隔离<ul><li>进程隔离是为了保护OS中进程互不干扰的技术，每个进程都只能访问自己占有的数据</li><li>一个进程挂了，是不会影响其他进程的</li><li>进程之间进行数据通信，需要依赖IPC机制</li></ul></li></ul><h2 id="浏览器的单进程时代"><a href="#浏览器的单进程时代" class="headerlink" title="浏览器的单进程时代"></a>浏览器的单进程时代</h2><p><img src="/2020/05/14/broswer-1/image-20200513225930714.png" alt="image-20200513225930714"></p><p>RT,单进程浏览器是指浏览器所有的功能模块都运行在同一个进程里面。这些模块包括网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p><p>缺点:功能都运行在一个进程里面，会导致浏览器不稳定、不流畅、不安全的一个主要因素。</p><h3 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h3><p>浏览器的插件 &amp;&amp; 渲染引擎模块的渲染都是导致浏览器不稳定的一个因素之一。如果这些东西崩溃了，那么浏览器也会跟着崩溃。</p><h3 id="不流畅"><a href="#不流畅" class="headerlink" title="不流畅"></a>不流畅</h3><p>从上面架构图可以看出，如果写一个类似于下面的无限循环脚本:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> freeze = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'freeze'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">freeze()</span><br></pre></td></tr></table></figure><p>如果让这个脚本在单进程浏览器里面运行了，它会独占整个浏览器的运行线程，从而导致其他的模块机制没有机会去被执行。这样就会使浏览器变得卡顿。</p><p>除了上面的<strong>脚本</strong>和<strong>插件</strong>会让浏览器变得卡顿，其实<strong>页面的内存泄漏</strong>也是使得单进程变慢的一个重要的原因。</p><h3 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h3><ul><li>插件，当你的页面运行一个插件的时候，这个时候插件能够完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取账号密码、引发安全性问题</li><li>脚本，类似于XSS攻击</li></ul><p>类似于这样一个场景，一个页面的崩溃，导致了你所有的浏览器页面的崩溃。</p><h2 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h2><h3 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h3><p><img src="/2020/05/14/broswer-1/image-20200513231511743.png" alt="image-20200513231511743"></p><h3 id="不稳定？"><a href="#不稳定？" class="headerlink" title="不稳定？"></a>不稳定？</h3><p>由于进程之间是彼此相互隔离的，所以当一个页面崩溃的时候，只会影响当前的页面进程和插件进程。并不会影响到浏览器和其他页面。</p><h3 id="不流畅？"><a href="#不流畅？" class="headerlink" title="不流畅？"></a>不流畅？</h3><p>因为JS也是在渲染进程中进行渲染的，所以即使其阻塞了渲染进程，影响到的也只是当前的渲染页面。并不会影响浏览器和其他页面。</p><p>对于内存泄漏的改进: 当整个页面关闭的时候，渲染进程也会被关闭，误操作泄漏的内存也会包括在进程占有的内存中被系统回收回去。</p><h3 id="不安全？"><a href="#不安全？" class="headerlink" title="不安全？"></a>不安全？</h3><p>多进程架构的额外好处是可以使用<strong>安全沙箱</strong>，沙箱相当于是OS给进程上了一把锁，沙箱里面的程序可以运行，但不能在硬盘上写入数据，也不能在敏感位置读取任何数据，例如获取你的文档读写权限。Chrome把插件和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件里面执行了恶意程序，它也无法突破沙箱去获取系统权限。</p><h3 id="改进的多进程架构"><a href="#改进的多进程架构" class="headerlink" title="改进的多进程架构"></a>改进的多进程架构</h3><p> 随着时间的发展。目前的Chrome架构也有了许多新的变化:</p><p><img src="/2020/05/14/broswer-1/image-20200513232500284.png" alt="image-20200513232500284"></p><p>目前的 Chrome 浏览器包括:1个浏览器(Broswer)主进程、1个GPU进程、1个网络(NetWork)进程、多个渲染进程和多个插件进程。</p><ul><li>浏览器进程。负责界面显示、用户交互、子进程管理、同时提供存储功能(localstorage等)</li><li>渲染进程。核心任务是将HTML、CSS 和 JavaScript 转换成用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程里面，默认情况下，Chrome 会给每个Tab标签创建一个渲染进程。且渲染进程运行在sandbox里面。</li><li><strong>GPU进程</strong>。GPU使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的UI界面都选择采用GPU来绘制，然后GPU就成了浏览器的普遍需求。最后Chrome也在多进程架构里面引入了 GPU 进程。</li><li>网络进程。主要负责网页资源的加载。之前是作为一个模块运行在浏览器进程里面的，直到最近才独立出来，成为一个单独的进程。</li><li>插件进程。主要是负责插件的运行，因插件容易崩溃，所以需要插件进程来隔离从而保证其崩溃不会对浏览器和页面造成影响。</li></ul><p>带来的问题:</p><ul><li>更高的资源占用。因为每个结构都会包含公共基础结构的副本，意味着浏览器会消耗更多的内存资源。所以mbp在没有充电器的情况下写前端是一件非常耗电的事情。</li><li>更复杂的体系架构。各模块之间的耦合性高、拓展性差的问题，会导致现在的架构很难以适应新的需求了。</li></ul><h2 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="headerlink" title="未来面向服务的架构"></a>未来面向服务的架构</h2><p>为了解决这些问题，16年，Chrome官方使用了“面向服务的架构”(Service Oriented Architecture,简称<code>SOA</code>)的思想设计了新的Chrome架构。之后整体的架构都会往这一方面进行迁移:原来所有的模块都会被重构成独立的服务(Service)，每个服务(Service)都可在独立的进程中运行，访问服务(Service)必须使用定义好的接口，通过IPC来进行通信。最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似于OS的底层服务。</p><p>具体资料可以可以Google搜索。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从Chrome浏览器的进化视角来看，浏览器的进化历史大概可以分为:</p><p>单进程架构 -&gt; 多进程结构(早期)-&gt;多进程架构(现在)-&gt;面向服务的架构(未来)</p><p>个人认为之所以会有这方面的进化，起初可能仅仅是因为性能的问题。后面随着技术的进步与发展浏览器架构需要考虑到的问题也越来越多，例如安全，隐私，稳定，流畅等问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;chrome-架构&quot;&gt;&lt;a href=&quot;#chrome-架构&quot; class=&quot;headerlink&quot; title=&quot;chrome 架构&quot;&gt;&lt;/a&gt;chrome 架构&lt;/h2&gt;&lt;p&gt;一般我们使用chrome浏览器打开一个网页的时候，打开浏览器的任务管理器可以发现会发现chrome在这个时候会启用多个进程窗口。(同windows一样，chrome任务管理器也是用来展示运行中chrome使用进程信息的。)&lt;/p&gt;
&lt;p&gt;这里就会涉及到chrome的&lt;strong&gt;多进程架构&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;并行处理&quot;&gt;&lt;a href=&quot;#并行处理&quot; class=&quot;headerlink&quot; title=&quot;并行处理&quot;&gt;&lt;/a&gt;并行处理&lt;/h2&gt;&lt;p&gt;计算机的并行处理就是指在同一时刻处理多个任务，性能是要高于正常情况下用单线程来处理的。&lt;/p&gt;
&lt;h2 id=&quot;线程-and-进程&quot;&gt;&lt;a href=&quot;#线程-and-进程&quot; class=&quot;headerlink&quot; title=&quot;线程 and 进程&quot;&gt;&lt;/a&gt;线程 and 进程&lt;/h2&gt;&lt;p&gt;多线程可以并行处理任务，但是&lt;strong&gt;线程不能存在的，还需要进程来启动和管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程指的是一个程序的运行实例：启动一个程序时，OS会为程序创建一块内存，用来存放代码、运行中的数据、和一个执行任务的主线程，这样的一个环境就可以叫做&lt;strong&gt;进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/14/broswer-1/image-20200513225045754.png&quot; alt=&quot;image-20200513225045754&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，线程是依附于进程的，进程中使用多线程并行处理是能够提升运行效率。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ts一些技巧总结</title>
    <link href="http://zoomdong.site/2020/05/03/ts-higher-1/"/>
    <id>http://zoomdong.site/2020/05/03/ts-higher-1/</id>
    <published>2020-05-03T14:51:26.000Z</published>
    <updated>2020-05-12T16:05:38.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些学习资料"><a href="#一些学习资料" class="headerlink" title="一些学习资料"></a>一些学习资料</h2><p>一本不错的 TS 书籍，已经买了实体书:</p><ul><li><a href="https://github.com/jkchao/typescript-book-chinese" target="_blank" rel="noopener">深入理解 TypeScript</a><br>一个不错的TS练习repo:</li><li><a href="https://github.com/mdevils/typescript-exercises" target="_blank" rel="noopener">typescript exercise</a></li></ul><h2 id="interface-amp-amp-type"><a href="#interface-amp-amp-type" class="headerlink" title="interface &amp;&amp; type"></a>interface &amp;&amp; type</h2><p>两者几乎没有区别,但是 <code>interface</code> 可以合并多个相同的 <code>interface</code>,而 <code>type</code> 只能使用 <code>&amp;</code> 进行连接。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: A = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><code>typeof</code> 可以取某个值的 <code>type</code>:<br>具体使用方法:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equal to const b: number = 4</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="keyword">typeof</span> a = <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>在一些服务端项目里面，我们可以把一些需要的工具塞在<code>context</code>里面去，这个时候就需要<code>typeof</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">'./lo'</span></span><br></pre></td></tr></table></figure><h2 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h2><p><code>keyof</code> 和 <code>Object.keys</code> 有些类似，不过 <code>keyof</code> 取的是<code>interface</code>里面的键。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type keys = 'x' | 'y'</span></span><br><span class="line"><span class="comment">// 这里keys会成为一个联合类型</span></span><br><span class="line"><span class="keyword">type</span> keys = keyof Point;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>keyof</code>来实现一个<code>get</code>函数来获取它的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  hello: <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能同时兼具以下几个优点:</p><ol><li>能够确认结果的返回类型</li><li>能够对<code>key</code>值进行一个约束</li></ol><h2 id="keyof-in"><a href="#keyof-in" class="headerlink" title="keyof, in"></a>keyof, in</h2><p><code>keyof</code> 能够产生一个联合类型，<code>in</code>能够遍历枚举类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T -&gt; "name" | "age"</span></span><br><span class="line"><span class="keyword">type</span> T = keyof Foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> keys = <span class="string">'a'</span> | <span class="string">'b'</span></span><br><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj -&gt; &#123; a: any, b: any &#125;</span></span><br></pre></td></tr></table></figure></p><p>那么可以写一个将传入的属性变成可选项的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br></pre></td></tr></table></figure><p>那么使用的时候就可以这样:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = Partial&lt;Foo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能定义 name, age 中的属性，当然也可以不定义</span></span><br><span class="line"><span class="keyword">const</span> a: A = &#123;</span><br><span class="line">  name: <span class="string">'1'</span>,</span><br><span class="line">  age: <span class="string">'3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>in</code>的主要作用是取联合类型的值。主要用于数组和对象的构造。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name = <span class="string">'firstName'</span> | <span class="string">'lastName'</span></span><br><span class="line"><span class="keyword">type</span> IName = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> name]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是<code>in</code>是不能用在<code>interface</code>上面，否则会出错。</p><h2 id="ts定义函数"><a href="#ts定义函数" class="headerlink" title="ts定义函数"></a>ts定义函数</h2><p><code>ts</code>中类型系统中的函数为<code>泛型操作符</code>，最简单的方式就是使用<code>type</code>关键字:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a simple operator</span></span><br><span class="line"><span class="keyword">type</span> foo&lt;T&gt; = T;</span><br></pre></td></tr></table></figure><p>上面的代码转成<code>JavaScript</code>之后会成这个样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的类型系统中的函数还支持对入参对约束:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 T 进行约束</span></span><br><span class="line"><span class="keyword">type</span> foo&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T;</span><br></pre></td></tr></table></figure><p>这里就类似于这样的<code>ts</code>代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">T: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是能够设置默认值的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">'hello xyx'</span>&gt; = T</span><br></pre></td></tr></table></figure><p>同理:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">T: <span class="built_in">string</span> = 'hello xyx'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里是不能像<code>JS</code>里的函数一样支持剩余参数的，但是我们可以通过一些操作模拟出来。</p><h2 id="类型支持条件判断"><a href="#类型支持条件判断" class="headerlink" title="类型支持条件判断"></a>类型支持条件判断</h2><p>可以使用<code>extends</code>关键字来完成这一操作:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>结合之前的<code>type</code>这里可以用来模拟一下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> str = <span class="string">'hello xyx'</span></span><br><span class="line"><span class="keyword">type</span> INumber = N <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'yeah'</span> : <span class="string">'no'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> res1 = INumber&lt;num&gt; <span class="comment">// yeah</span></span><br><span class="line"><span class="keyword">type</span> res2 = INumber&lt;str&gt; <span class="comment">// no</span></span><br></pre></td></tr></table></figure><p>这里我们就相当于实现了一个简单的带判断逻辑的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些学习资料&quot;&gt;&lt;a href=&quot;#一些学习资料&quot; class=&quot;headerlink&quot; title=&quot;一些学习资料&quot;&gt;&lt;/a&gt;一些学习资料&lt;/h2&gt;&lt;p&gt;一本不错的 TS 书籍，已经买了实体书:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jkchao/typescript-book-chinese&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解 TypeScript&lt;/a&gt;&lt;br&gt;一个不错的TS练习repo:&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mdevils/typescript-exercises&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;typescript exercise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;interface-amp-amp-type&quot;&gt;&lt;a href=&quot;#interface-amp-amp-type&quot; class=&quot;headerlink&quot; title=&quot;interface &amp;amp;&amp;amp; type&quot;&gt;&lt;/a&gt;interface &amp;amp;&amp;amp; type&lt;/h2&gt;&lt;p&gt;两者几乎没有区别,但是 &lt;code&gt;interface&lt;/code&gt; 可以合并多个相同的 &lt;code&gt;interface&lt;/code&gt;,而 &lt;code&gt;type&lt;/code&gt; 只能使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 进行连接。&lt;br&gt;&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; B = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;区别:&lt;br&gt;&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; a: A = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>(译)JavaScript 函数式编程</title>
    <link href="http://zoomdong.site/2020/04/24/master-function-programming/"/>
    <id>http://zoomdong.site/2020/04/24/master-function-programming/</id>
    <published>2020-04-23T17:22:38.000Z</published>
    <updated>2020-04-23T17:32:44.060Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">Master the JavaScript Interview: What is Functional Programming?</a></li><li>原文作者：<a href="https://medium.com/@_ericelliott" target="_blank" rel="noopener">Eric Elliott</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md</a></li><li>译者：<a href="https://github.com/fireairforce" target="_blank" rel="noopener">zoomdong</a></li><li>校对者：<a href="https://github.com/QinRoc" target="_blank" rel="noopener">Roc</a>,<a href="https://github.com/xionglong58" target="_blank" rel="noopener">Long Xiong</a></li></ul></blockquote><p>函数式编程已经成为 JavaScript 领域中一个非常热门的话题。就在几年前，甚至很少有 JavaScript 程序员知道什么是函数式编程，但是我在过去 3 年看到的每个大型应用程序代码库中都大量使用了函数式编程思想。</p><p><strong>函数式编程</strong>（通常缩写为 FP）是通过组合<strong>纯函数</strong>，避免<strong>状态共享</strong>、<strong>可变数据</strong>和<strong>副作用</strong>来构建软件的过程。函数式编程是<strong>声明式</strong>的，而不是<strong>命令式</strong>的，应用程序状态通过纯函数流动。与面向对象编程不同，在面向对象编程中，应用程序状态通常与对象中的方法共享和协作。</p><a id="more"></a><p>函数式编程是一种<strong>编程范式</strong>，这意味着它是一种基于一些基本的、定义性的原则（如上所列）来思考软件构建的方法。其他编程范式包括面向对象编程和面向过程编程。</p><p>与命令式或面向对象的代码相比，函数式代码往往更简洁、更可预测、更易于测试 —— 但如果你不熟悉它以及与之相关的常见模式，函数式代码看起来也会密集得多，而且相关的文档对于新人来说可能是难以理解的。</p><p>如果你开始在 Google 上搜索函数式编程术语，你很快就会遇到一堵学术术语的墙，这对初学者来说是非常可怕的。说它有一个学习曲线是非常保守的说法。但是如果你已经使用 JavaScript 编程了一段时间，那么你很可能已经在实际的软件应用中使用了大量的函数式编程的概念和实用工具。</p><blockquote><p>Don’t let all the new words scare you away. It’s a lot easier than it sounds.</p></blockquote><!--more--><p>最困难的部分是吸收（或者理解）这些词汇。在你开始理解函数式编程的含义之前，上面这个看似简单的定义中有很多需要理解的概念：</p><ul><li>纯函数</li><li>函数组合</li><li>避免状态共享</li><li>避免可变数据</li><li>避免副作用</li></ul><p>换句话说，如果你想知道函数式编程在实践中意味着什么，你必须首先理解这些核心概念。</p><p><strong>纯函数</strong>指的是具有下列特征的函数：</p><ul><li>给定相同的输入，总是得到相同的输出</li><li>没有副作用</li></ul><p>纯函数有许多在函数式编程中很重要的属性，包括<strong>引用透明性</strong>（你可以使用函数一次调用的结果值代替其余对该函数的调用操作，这样并不会对程序产生影响）。阅读<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">“什么是纯函数？”</a>了解更多。</p><p><strong>组合函数</strong>是将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程。例如，<code>f . g</code> 组合（. 的意思是组合）在 JavaScript 中等价于 <code>f(g(x))</code>。理解组合函数是理解如何使用函数式编程构建软件的重要一步。阅读 <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">“什么是组合函数？”</a>了解更多。</p><h2 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h2><p><strong>状态共享</strong>是指共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。</p><p>例如，计算机游戏可能有一个主游戏对象，其中的角色和游戏项存储为该对象所拥有的属性。函数式编程避免了状态共享，而是依赖不可变的数据结构和纯计算从现有数据中派生出新数据。有关函数式软件如何处理应用程序状态的更多详细信息，请参阅<a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="noopener">“10个更好的 Redux 架构提示”</a>。</p><p>共享状态的问题在于，为了了解函数的效果，你必须要了解函数使用或影响的每个共享变量的全部历史记录。</p><p>假设你有一个需要保存的 <code>user</code> 对象。<code>saveUser()</code> 函数向服务器上的 API 发出请求。在此过程中，用户使用 <code>updateAvatar()</code> 更改他们的个人头像，并触发另一个 <code>saveUser()</code> 请求。在保存时，服务器发送回一个规范的 <code>user</code> 对象，为了同步服务端或者其他客户端 API 引起的更改，该对象应该替换掉内存中对应的对象。</p><p>不幸的是，第二个响应在第一个响应之前被接收，所以当第一个（现在已经过时了）响应被返回时，新的个人头像会在内存中被删除并替换为旧的个人头像。这就是一个竞争条件的例子 —— 与状态共享相关的非常常见的错误。</p><p>与共享状态相关的另一个常见问题是，更改调用函数的顺序可能会导致一系列故障，因为作用于共享状态的函数依赖于时序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在共享状态下，函数调用的顺序会更改函数调用的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x1 = <span class="function"><span class="params">()</span> =&gt;</span> x.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="function"><span class="params">()</span> =&gt;</span> x.val *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">x1();</span><br><span class="line">x2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x.val); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子和上面完全相同，除了对象名称</span></span><br><span class="line"><span class="keyword">const</span> y = &#123;</span><br><span class="line">  val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y1 = <span class="function"><span class="params">()</span> =&gt;</span> y.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y2 = <span class="function"><span class="params">()</span> =&gt;</span> y.val *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用的顺序被颠倒了</span></span><br><span class="line">y2();</span><br><span class="line">y1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从而改变了结果的值</span></span><br><span class="line"><span class="built_in">console</span>.log(y.val); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>当避免状态共享时，函数调用的时间和顺序不会更改调用函数的结果。对于纯函数，给定相同的输入，总是得到相同的输出。这使得函数调用时完全独立于其他函数调用，这可以从根本上简化更改和重构。一个函数的变化，或者函数调用的时间不会影响程序的其他部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x1 = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, x, &#123; <span class="attr">val</span>: x.val + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x2 = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, x, &#123; <span class="attr">val</span>: x.val * <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x1(x2(x)).val); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> y = &#123;</span><br><span class="line">  val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于不依赖于外部变量</span></span><br><span class="line"><span class="comment">// 我们不需要不同的函数来操作不同的变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处故意留空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为函数不会发生变化</span></span><br><span class="line"><span class="comment">// 所以可以按任意顺序多次调用这些函数</span></span><br><span class="line"><span class="comment">// 而不必更改其他函数调用的结果</span></span><br><span class="line">x2(y);</span><br><span class="line">x1(y);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x1(x2(y)).val); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用 <code>Object.assign()</code> 并传入一个空对象作为第一个参数来复制 <code>x</code> 的属性，而不是在原数据上进行修改。在之前的示例中，它相当于从零开始创建一个新对象，而不使用 <code>object.assign()</code>，但这是 JavaScript 中创建现有状态副本的常见模式，而不是使用突变的常见模式，我们在第一个示例中证明了这一点。</p><p>如果仔细观察这个例子中的 <code>console.log()</code>语句，你应该会注意到我已经提到的一些东西：组合函数。回想一下前面，组合函数类似这样：<code>f(g(x))</code>。在本例中，我们将组合 <code>x1 . x2</code> 中的 <code>f()</code> 和 <code>g()</code> 替换为 <code>x1()</code> 和 <code>x2()</code>。</p><p>当然，如果你改变了组合的顺序，输出结果同样会改变。操作的顺序同样很重要。<code>f(g(x))</code> 并不总是和 <code>g(f(x))</code> 相同，但不再重要的是函数外的变量发生了什么，这很重要。对于非纯函数，除非你知道函数使用或影响的每个变量的整个历史记录，否则不可能完全理解函数的作用。</p><p>移除函数调用计时依赖项，就消除了一整类的潜在 bug。</p><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p><strong>不可变</strong>对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象。</p><p>不变性是函数式编程的核心概念，因为没有它，程序中的数据流是有损的。状态历史被抛弃，奇怪的 bug 可能会潜入你的软件。更多关于不变性的意义，请参阅<a href="https://medium.com/javascript-scene/the-dao-of-immutability-9f91a70c88cd" target="_blank" rel="noopener">“不变性之道”</a>。</p><p>在 JavaScript 中，重要的是不要混淆 <code>const</code> 和不变性。<code>const</code> 创建一个变量名绑定，该绑定在创建后不能重新分配。<code>const</code> 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 <code>const</code> 创建的绑定是可变的，而不是不可变的。</p><p>不可变对象根本不能更改。通过深度冻结对象，可以使值真正不可变。JavaScript 有一种方法可以将对象冻结一层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  foo: <span class="string">'Hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span>,</span><br><span class="line">  baz: <span class="string">'!'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">'Goodbye'</span>;</span><br><span class="line"><span class="comment">// Error: Cannot assign to read only property 'foo' of object Object</span></span><br></pre></td></tr></table></figure><p>但是冻结的对象只是表面上不可变。例如，以下对象是可变的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  foo: &#123; <span class="attr">greeting</span>: <span class="string">'Hello'</span> &#125;,</span><br><span class="line">  bar: <span class="string">'world'</span>,</span><br><span class="line">  baz: <span class="string">'!'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.foo.greeting = <span class="string">'Goodbye'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; a.foo.greeting &#125;</span>, <span class="subst">$&#123; a.bar &#125;</span><span class="subst">$&#123;a.baz&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>正如你所看到的，冻结对象的顶层基本属性不能改变，但是里面的任何对象属性（包括数组等）仍然可以改变 —— 所以即使是冻结的对象也不是不可变的，除非你遍历整个对象树并冻结每个对象属性。</p><p>在许多函数式编程语言中，有一种特殊的不可变的数据结构称为 <strong>trie 数据结构</strong>（发音同“tree”），它实际上是深度冻结的 —— 这意味着无论属性处于对象层次结构中的哪个层级，都不可以改变。</p><p>Tries 使用了<strong>共享结构</strong>在不可变对象被复制之后为对象共享引用内存地址，该方法使用较少的内存，并且使得在一些操作下的性能得到提升。</p><p>例如，你可以在对象对的根节点进行一致性比较来比较两个对象是否一致。如果一致的话，你就不需要再遍历整个对象树查找差异了。</p><p>JavaScript 中有几个库使用到了 tries，包括 <a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">Immutable.js</a> 和 <a href="https://github.com/swannodette/mori" target="_blank" rel="noopener">Mori</a>。</p><p>我尝试过这两种方法，并且倾向于在需要大量不可变状态的大型项目中使用 Immutable.js。有关更多信息，请参见<a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="noopener">“10个更好的Redux架构技巧”</a>。</p><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>副作用是指任何应用程序状态的改变都是可以在被调用函数之外观察到的，除了返回值。副作用包括：</p><ul><li>修改任何外部变量或对象属性（例如，全局变量或父函数作用域链中的变量）</li><li>打印日志到控制台</li><li>写入屏幕</li><li>写入文件</li><li>写入网络</li><li>触发任何外部过程</li><li>调用其它有副作用的函数</li></ul><p>在函数式编程中，通常会避免产生副作用，这使得程序的作用更易于理解和测试。</p><p>Haskell 和其他函数语言经常使用 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="noopener"><strong>monad</strong></a>) 从纯函数中分离和封装副作用。有关 monad 的话题的深度足以写一本书来讨论，所以我们以后再谈。</p><p>你现在需要知道的是，副作用操作需要与软件的其他部分隔离开来。如果你将副作用与其他的程序逻辑隔离开，你的软件将更容易扩展、重构、调试、测试和维护。</p><p>这就是大多数前端框架鼓励用户在单独的、松散耦合的模块中管理状态和组件渲染的原因。</p><h2 id="通过高阶函数实现可重用性"><a href="#通过高阶函数实现可重用性" class="headerlink" title="通过高阶函数实现可重用性"></a>通过高阶函数实现可重用性</h2><p>函数式编程倾向于重用一组通用的函数式实用程序来处理数据。面向对象编程倾向于将方法和数据集中在对象中。这些协作方法只能对它们被设计用于操作的数据类型进行操作，而且通常只能对特定对象实例中包含的数据进行操作。</p><p>在函数式编程中，任何类型的数据都是平等的。同一个 <code>map()</code> api 可以映射对象、字符串、数字或任何其他数据类型，因为它以一个函数作为参数，该参数适当地处理给定的数据类型。FP 使用了<strong>高阶函数</strong>完成它的通用实用技巧。</p><p>JavaScript 中<strong>函数是头等公民</strong>，这些函数允许，它允许我们将函数作为数据 —— 将其赋给变量、传递给其他函数、从函数返回等等。</p><p><strong>高阶函数</strong>是那些函数作为参数、返回值为函数或两者兼有的函数。高阶函数通常用于：</p><ul><li>使用回调函数、promise、monad 等来抽象或隔离动作、效果或异步流控制。</li><li>创建可以作用于多种数据类型的工具程序</li><li>将一个函数部分地应用于它的参数，或者创建一个柯里化过的函数，以便重用或组合函数</li><li>获取一个函数列表，并返回这些输入函数的一些组合</li></ul><h4 id="容器，函子，列表，和流"><a href="#容器，函子，列表，和流" class="headerlink" title="容器，函子，列表，和流"></a>容器，函子，列表，和流</h4><p>函子是可以映射的。换句话说，它是一个容器，它有一个接口，可用于将函数应用于其中的值。当你看到函子这个词时，你应该想到“可映射”。</p><p>前面我们了解了 <code>map()</code> 工具程序可以作用于各种数据类型。它通过提升映射操作来使用函子 API 来实现这一点。<code>map()</code> 使用的重要流控制操作利用了该接口。对于 <code>array.prototype.map()</code>，容器是一个数组，但是其他数据结构也可以是函子 —— 只要它们提供了映射 API。</p><p>让我们看看 <code>Array.prototype.map()</code> 如何允许你从映射实用程序中提取数据类型，使 <code>map()</code> 可用于任何数据类型。我们将创建一个简单的 <code>double()</code> 映射，它将传入的任何值乘以 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> doubleMap = <span class="function"><span class="params">numbers</span> =&gt;</span> numbers.map(double);</span><br><span class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [ 4, 6, 8 ]</span></span><br></pre></td></tr></table></figure><p>如果我们想要在游戏中对目标进行操作以使他们所获得的点数翻倍该怎么办？我们所要做的就是对 <code>double()</code> 函数做一些细微的修改，然后将其传递给 <code>map()</code>，这样一切仍然可以正常工作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n.points * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doubleMap = <span class="function"><span class="params">numbers</span> =&gt;</span> numbers.map(double);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doubleMap([</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'ball'</span>, <span class="attr">points</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'coin'</span>, <span class="attr">points</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'candy'</span>, <span class="attr">points</span>: <span class="number">4</span>&#125;</span><br><span class="line">])); <span class="comment">// [ 4, 6, 8 ]</span></span><br></pre></td></tr></table></figure><p>为了使用通用实用函数来操作任意数量的不同数据类型，需要使用像函子和高阶函数这样的抽象，这个概念是很重要的。你将看到一个类似的概念以<a href="https://github.com/fantasyland/fantasy-land" target="_blank" rel="noopener">各种不同的方式应用</a>。</p><blockquote><h1 id="“随着时间推移表示的列表是一个流。”"><a href="#“随着时间推移表示的列表是一个流。”" class="headerlink" title="“随着时间推移表示的列表是一个流。”"></a>“随着时间推移表示的列表是一个流。”</h1></blockquote><p>现在你需要了解的是，数组和函子并不是容器和容器中的值这一概念应用的唯一方式。例如，数组只是事物的列表。随着时间的推移，一个列表是一个流，因此你可以使用相同类型的实用程序来处理传入事件的流 —— 当你开始用 FP 构建真正的软件时，你会看到很多这种情况。</p><h2 id="声明式-vs-命令式"><a href="#声明式-vs-命令式" class="headerlink" title="声明式 vs 命令式"></a>声明式 vs 命令式</h2><p>函数式编程是一种声明性的范式，这意味着程序逻辑的表达没有显式地描述流控制。</p><p><strong>命令式</strong>程序花费几行代码来描述用于实现预期结果的特定步骤 —— <strong>流控制：如何</strong>做事情。</p><p><strong>声明性</strong>程序抽象了流控制过程，花费几行代码来描述<strong>数据流：应该做什么</strong>。<strong>如何</strong>被抽象出来。</p><p>例如，这个<strong>命令式</strong>映射接受一个数字数组，并返回一个新数组，其中每个数字都被乘以2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doubleMap = <span class="function"><span class="params">numbers</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">const</span> doubled = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    doubled.push(numbers[i] * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doubled;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>这个<strong>声明式</strong>映射也做了同样的事情，但是使用<code>Array.prototype.map()</code>函数式实用程序将流控件抽象出来，它允许你更清楚地表示数据流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doubleMap = <span class="function"><span class="params">numbers</span> =&gt;</span> numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [4, 6, 8]</span></span><br></pre></td></tr></table></figure><p><strong>命令式</strong>代码经常使用语句。<strong>语句</strong>是执行某些操作的一段代码。常用的语句包括 <code>for</code>、<code>if</code>、<code>switch</code>、<code>throw</code> 等。</p><p><strong>声明式</strong>代码更多地依赖于表达式。<strong>表达式</strong>是计算某个值的一段代码。表达式通常是函数调用、值和运算符的组合，它们被用于计算出结果。</p><p>下面是表达式的一些例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="built_in">double</span>Map([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">Math.max(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通常在代码中，你会看到表达式被分配给标识符、从函数返回或传递到函数中。在被分配、返回或传递之前，表达式会先进行计算，实际使用的是其结果值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数式编程倾向于：</p><ul><li>纯函数而不是状态共享或副作用</li><li>不变性而不是可变的数据</li><li>组合函数而不是命令式流控制</li><li>大量通用的、可重用的实用程序，它们使用高阶函数来处理多种数据类型，而不是仅对位于同一位置的数据进行操作的方法</li><li>声明式代码而不是命令式代码（做什么而不是怎么做）</li><li>表达式而不是语句</li><li>容器和高阶函数而不是多态</li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>学习和练习这些函数式数组的核心功能：</p><ul><li><code>.map()</code></li><li><code>.filter()</code></li><li><code>.reduce()</code></li></ul><h4 id="探索《掌握-JavaScript-面试》系列文章"><a href="#探索《掌握-JavaScript-面试》系列文章" class="headerlink" title="探索《掌握 JavaScript 面试》系列文章"></a>探索《掌握 JavaScript 面试》系列文章</h4><ul><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.ecfskj935" target="_blank" rel="noopener">闭包是什么？</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.h96dymht1" target="_blank" rel="noopener">类和原型继承之间的区别是什么</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.4256pjcfq" target="_blank" rel="noopener">纯函数是什么？</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0#.i84zm53fb" target="_blank" rel="noopener">组合函数是什么？</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0#.jddz30xy3" target="_blank" rel="noopener">函数式编程是什么？</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261#.aa7ubggsy" target="_blank" rel="noopener">Promise 是什么？</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466" target="_blank" rel="noopener">软技能</a></li></ul><blockquote><p>This post was included in the book “Composing Software”.<strong><a href="https://leanpub.com/composingsoftware" target="_blank" rel="noopener"><br>Buy the Book</a> | <a href="https://medium.com/javascript-scene/composing-software-the-book-f31c77fc3ddc" target="_blank" rel="noopener">Index</a> | <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">\&lt; Previous</a> | <a href="https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30" target="_blank" rel="noopener">Next &gt;</a></strong></p></blockquote><hr><p><strong>Eric Elliott</strong> 是一名分布式系统专家，并且是 <a href="https://leanpub.com/composingsoftware" target="_blank" rel="noopener">《组合软件》</a>和<a href="https://ericelliottjs.com/product/programming-javascript-applications-ebook/" target="_blank" rel="noopener">《编写 JavaScript 程序》</a>这两本书的作者。作为 <a href="https://ericelliottjs.com" target="_blank" rel="noopener">EricElliottJS.com</a> 和 <a href="https://devanywhere.io/" target="_blank" rel="noopener">DevAnywhere.io</a> 的联合创始人，他教开发人员远程工作和实现工作以及生活平衡所需的技能。他创建了加密项目的开发团队，并为他们提供建议。他还在软件体验上为 <strong>Adobe 系统、Zumba Fitness、华尔街日报、ESPN、BBC</strong> 以及包括 <strong>Usher、Frank Ocean、Metallica</strong> 等在内的顶级唱片艺术家做出了贡献。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Master the JavaScript Interview: What is Functional Programming?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;https://medium.com/@_ericelliott&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eric Elliott&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文永久链接：&lt;a href=&quot;https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xitu/gold-miner/blob/master/TODO1/master-the-javascript-interview-what-is-functional-programming.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/fireairforce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zoomdong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/QinRoc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Roc&lt;/a&gt;,&lt;a href=&quot;https://github.com/xionglong58&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Long Xiong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数式编程已经成为 JavaScript 领域中一个非常热门的话题。就在几年前，甚至很少有 JavaScript 程序员知道什么是函数式编程，但是我在过去 3 年看到的每个大型应用程序代码库中都大量使用了函数式编程思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;（通常缩写为 FP）是通过组合&lt;strong&gt;纯函数&lt;/strong&gt;，避免&lt;strong&gt;状态共享&lt;/strong&gt;、&lt;strong&gt;可变数据&lt;/strong&gt;和&lt;strong&gt;副作用&lt;/strong&gt;来构建软件的过程。函数式编程是&lt;strong&gt;声明式&lt;/strong&gt;的，而不是&lt;strong&gt;命令式&lt;/strong&gt;的，应用程序状态通过纯函数流动。与面向对象编程不同，在面向对象编程中，应用程序状态通常与对象中的方法共享和协作。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>electron开发基本概念介绍</title>
    <link href="http://zoomdong.site/2020/01/10/electron-1/"/>
    <id>http://zoomdong.site/2020/01/10/electron-1/</id>
    <published>2020-01-10T07:22:48.000Z</published>
    <updated>2020-01-10T07:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习electron对于个人的好处"><a href="#学习electron对于个人的好处" class="headerlink" title="学习electron对于个人的好处"></a>学习electron对于个人的好处</h2><ul><li>Electron的基础知识，各个内置模块的熟练应用(能够开发一个小软件)</li><li>深入了解浏览器的工作原理</li><li>理解进程概念和跨进程通信的原理</li></ul><a id="more"></a><h2 id="Electron开发环境的配置"><a href="#Electron开发环境的配置" class="headerlink" title="Electron开发环境的配置"></a>Electron开发环境的配置</h2><p>我之前有写过一篇<a href="http://zoomdong.cn/2019/11/01/electron/" target="_blank" rel="noopener">文章</a>有讲过关于<code>electron</code>开发的相关内容.</p><p>直接使用<code>electron</code>官网推荐的脚手架进行一个开发就行了。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>这个前面也有谈过，同时在学习操作系统的时候也有讲过这个概念了。</p><h3 id="什么是Process-进程"><a href="#什么是Process-进程" class="headerlink" title="什么是Process-进程"></a>什么是Process-进程</h3><ul><li>An instance of a computer program that is being executed </li><li>electron最最核心的概念就是主进程和渲染进程</li></ul><p>我们听音乐看电影电脑跑两个程序这就是两个不同的进程。</p><h3 id="什么是Thread-线程"><a href="#什么是Thread-线程" class="headerlink" title="什么是Thread-线程"></a>什么是Thread-线程</h3><ul><li>线程是操作系统实际能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。(<code>JS</code>是单线程的，它是事件驱动的。)</li></ul><p>进程和线程的区别：</p><ul><li>内存使用的区别(两个进程分配的内存没有办法共享，但是线程可以)</li><li>通信机制的区别(默认情况下进程很难进行通信，但是可以通过ipc通信，线程方便通信)</li><li>量级方面的区别</li></ul><p>前端里面多线程的场景并没有那么多。</p><h2 id="主进程和渲染进程"><a href="#主进程和渲染进程" class="headerlink" title="主进程和渲染进程"></a>主进程和渲染进程</h2><p><code>Electron</code>的底层基于<code>Chromium</code>构建，<code>Chromium</code>本身就是基于多进程构建的，所以<code>Electron</code>作为一个应用程序在运行的时候并不是由多线程在构建，而是多进程(分为主进程和渲染进程，一个窗口就是一个渲染进程)。</p><h3 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h3><ul><li>可以使用和系统对接的 Electron API - 创建菜单，上传文件等等</li><li>创建渲染进程 - Renderer Process</li><li>全面支持 Node.js</li><li>只有一个作为整个程序的入口点</li></ul><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><ul><li>可以有多个，每个对应一个窗口</li><li>每个都是一个单独的进程</li><li>可以使用一部分 Electron Api</li><li>全面支持 Node 和 Dom api</li></ul><p>我们可以直接使用官网脚手架来构建一次，先删除掉<code>main.js</code>里面之前的代码，然后重新写我们自己的代码，注意<code>electron</code>因为是基于 Node 构建的，所以里面使用的规范为 common js 规范。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">        <span class="comment">// 使得可以使用node api</span></span><br><span class="line">      nodeIntegration: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  mainWindow.loadFile(<span class="string">'index.html'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们相当于创建了一个mainWindow，他就是我们启动的第一个主窗口。</p><p>添加一个附加窗口只需要在里面加代码就可以了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> secondWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">400</span>,</span><br><span class="line">    height: <span class="number">300</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      nodeIntegration: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    parent: mainWindow</span><br><span class="line">  &#125;)</span><br><span class="line">  secondWindow.loadFile(<span class="string">'second.html'</span>)</span><br></pre></td></tr></table></figure><p>里面有个<code>renderer.js</code>文件是在<code>index.html</code>里面可以引入的一个脚本文件，在里面既可以使用<code>node</code>的 api，同时也可以使用 dom 相关的 api。</p><p>不过要注意的是，使用 node 的 api 时要记得将前面进程中的配置设置为<code>true</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'node-version'</span>).innerHTML = process.version;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h3><p>自行学习<code>ipc</code>文档即可。记得去官网安装一个叫做<code>devtron</code>的调试工具。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Install Devtron</span><br><span class="line">$ npm install --save-dev devtron</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run the following from the Console tab of your app's DevTools</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'devtron'</span>).install()</span><br><span class="line"><span class="comment">// You should now see a Devtron tab added to the DevTools</span></span><br></pre></td></tr></table></figure><p>同时在主进程里面添加一个自动帮助我们打开开发者调式工具的窗口:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'devtron'</span>).install()</span><br><span class="line">  <span class="keyword">let</span> mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">1200</span>,</span><br><span class="line">    height: <span class="number">800</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      nodeIntegration: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  mainWindow.loadFile(<span class="string">'index.html'</span>);</span><br><span class="line">  mainWindow.webContents.openDevTools();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在开发者工具里面就可以找到 devtron 这个工具了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是一些<code>electron</code>基本底层概念了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习electron对于个人的好处&quot;&gt;&lt;a href=&quot;#学习electron对于个人的好处&quot; class=&quot;headerlink&quot; title=&quot;学习electron对于个人的好处&quot;&gt;&lt;/a&gt;学习electron对于个人的好处&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Electron的基础知识，各个内置模块的熟练应用(能够开发一个小软件)&lt;/li&gt;
&lt;li&gt;深入了解浏览器的工作原理&lt;/li&gt;
&lt;li&gt;理解进程概念和跨进程通信的原理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我们应该怎么学TypeScript</title>
    <link href="http://zoomdong.site/2020/01/09/ts-learn/"/>
    <id>http://zoomdong.site/2020/01/09/ts-learn/</id>
    <published>2020-01-09T05:17:57.000Z</published>
    <updated>2020-04-19T13:30:06.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前有写过一些<code>typescript</code>的基础知识，但是并没有很好的将这些知识应用到很好的开发场景里面去，而且很多知识在没有使用之后很快会遗忘，因此总结根据慕课网文章来总结一些<code>ts</code>的学习之道。</p><a id="more"></a><h2 id="学会看文档"><a href="#学会看文档" class="headerlink" title="学会看文档"></a>学会看文档</h2><p><a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">ts的英文文档</a>始终是保持更新的，一般遇到一些文档里面没有的问题，我们首先要先检查我们的<code>ts</code>版本，然后根据日志的更新记录去找到不同版本的<code>ts</code>更新记录，看下当前出问题的特性是在哪一个版本做的更新，当然如果不确定问题的话，可以考虑对<code>ts</code>降一个版本去亲自进行一个尝试。</p><p>Typescript也是有一个<a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">中文文档</a>,但是这个文档只是对英文文档的翻译，而且对于官方文档中出现的一些纰漏并没有做校验。而且可能文档的版本稍微会有些滞后。但是也很感谢这些译者所做的贡献，这对于英文不好的开发者有很大的帮助。</p><h2 id="学会看报错"><a href="#学会看报错" class="headerlink" title="学会看报错"></a>学会看报错</h2><p>ts的报错一般会有多种。</p><p>首先是<code>tslint</code>的报错，在对项目进行构建的时候，我们会使用<code>Tslint</code>对代码风格进行一个规范校验，根据<code>Tslint</code>配置的不同，提示对教过也不一样。如果我们配置当书写的代码不符合规范，使用<code>error</code>级别来提示时，会和<code>TypeScript</code>编译报错一样，在问题代码的下面用红色波浪线标出，鼠标放上去会有错误提示。所以我们使用<code>Tslint</code>的时候，遇到报错的时候，首先要区分的是<code>Tslint</code>报错还是<code>TS</code>报错，区分这两者的关键在于鼠标放上去的提示方框中，会标识<code>tslint</code>，说明是TSLint报了错。</p><p><img src="http://q91ex1jyl.bkt.clouddn.com/ts-1.png" alt></p><p>后面括号是导致这条报错产生的原因，具体的规则<code>no-console</code>可以在<code>tslint</code>的配置文件里面对这条规则去进行一个修改。</p><p><img src="http://q91ex1jyl.bkt.clouddn.com/ts-2.png" alt></p><p>上面这个代码报错是由于<code>ts</code>编译器报的错误。在我们写代码的时候，通过强类型系统，编译器可以在这个阶段检测到我们的一些错误。后面括号里面的是错误代码，所有的错误代码都可以在文档里面的<a href="https://www.tslang.cn/docs/handbook/error.html" target="_blank" rel="noopener">错误消息列表</a>查到。<br>还有一种运行时的错误，可以通过<code>F12</code>在<code>console</code>控制台看到。这个就懒得说了。</p><h2 id="学会看声明文件"><a href="#学会看声明文件" class="headerlink" title="学会看声明文件"></a>学会看声明文件</h2><p>在原来没有<code>TypeScript</code>的时候，有很多<code>JS</code>插件和<code>JS</code>库，如果使用<code>TS</code>进行开发再使用这些 <code>JS</code> 编写的插件和库，就得不到类型提示等特性的支持了，所以<code>TypeScript</code>支持为<code>JS</code>库添加声明文件，以此来提供声明信息。我们使用<code>TypeScript</code>编写的库和插件编译后也是<code>JS</code>文件，所以在编译的时候就可以选择声明文件，这样再去进行发布，使用者依然能得到<code>TypeScript</code>的特性支持。一些<code>JS</code>库的作者已经使用<code>TS</code>进行了重写，有些提供了声明文件，一些是没有的，大部分库都有社区的人补充了声明文件，如果使用了自身没有提供声明文件的库的时候，可以使用<code>npm install @types/{模块名}</code>来进行安装，当然我们也可以自行来为他补充。</p><p>看这些库的声明文件能够帮你提高对 <code>TypeScript</code> 的了解程度。因为可能你在实际开发中所接触的场景不是很复杂，运用到的 <code>TypeScript</code> 语法点也不是很全面，所以就会导致经常用的你很熟悉，不经常用的慢慢就忘掉了，甚至有的自始至终你都没有使用过。很多知识你只看理论知识，或者看简单的例子，是没法真正理解并深刻记忆的，只有在实际场景中去使用一下，才能加深理解。所以我们可以从这些库的声明文件入手，还有就是从<code>TypeScript</code>内置的<code>lib</code>声明文件入手。</p><h2 id="学会搜问题和提问"><a href="#学会搜问题和提问" class="headerlink" title="学会搜问题和提问"></a>学会搜问题和提问</h2><h3 id="途径1-百度-or-google"><a href="#途径1-百度-or-google" class="headerlink" title="途径1:百度 or google"></a>途径1:百度 or google</h3><p>自行学习。</p><h3 id="途径2-看issue"><a href="#途径2-看issue" class="headerlink" title="途径2:看issue"></a>途径2:看issue</h3><p><code>ts</code>的问答目前要比很多框架和基础只是少很多，如果<code>途径1</code>找不到答案的话，可以去<code>github</code>上面<code>ts</code>的官方<code>repo</code>的<code>issue</code>里面去找对应的答案。</p><h3 id="途径3-去提问"><a href="#途径3-去提问" class="headerlink" title="途径3.去提问"></a>途径3.去提问</h3><p>如果上面两个途径都没有找到答案，那你就可以自行去提问了，这也是个造福后人的方法。国内可以试试<code>segmentfault</code>，国外可以试试<code>stackoverflow</code>.当然也可以自己去<code>github</code>上面开<code>issue</code>。</p><h2 id="看优秀项目的源码"><a href="#看优秀项目的源码" class="headerlink" title="看优秀项目的源码"></a>看优秀项目的源码</h2><p>去<code>github</code>上面按照关键单词去搜索就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前有写过一些&lt;code&gt;typescript&lt;/code&gt;的基础知识，但是并没有很好的将这些知识应用到很好的开发场景里面去，而且很多知识在没有使用之后很快会遗忘，因此总结根据慕课网文章来总结一些&lt;code&gt;ts&lt;/code&gt;的学习之道。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js设计模式Notes--工厂模式(1)</title>
    <link href="http://zoomdong.site/2020/01/08/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/"/>
    <id>http://zoomdong.site/2020/01/08/js设计模式-1/</id>
    <published>2020-01-08T05:54:50.000Z</published>
    <updated>2020-01-08T05:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式之道"><a href="#设计模式之道" class="headerlink" title="设计模式之道"></a>设计模式之道</h2><h3 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h3><ul><li>单一功能原则(<code>Single Responsibility Principle</code>)</li><li>开放封闭原则(<code>Opened Closed Principle</code>)</li><li>里式替换原则(<code>Liskov Substitution Principle</code>)</li><li>接口隔离原则(<code>Interface Segregation Principle</code>)</li><li>依赖反转原则(<code>Dependency Inversion Principle</code>)</li></ul><p>在<code>JS</code>里面主要还是围绕着“单一功能”和“开放封闭”来展开。</p><a id="more"></a><h3 id="设计模式的核心思想–封装变化"><a href="#设计模式的核心思想–封装变化" class="headerlink" title="设计模式的核心思想–封装变化"></a>设计模式的核心思想–封装变化</h3><p>在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响<strong>最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定</strong>。</p><p>这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码。</p><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>例如在动态构建公司员工数据(在员工人数较多的时候)的时候可以使用<code>JS</code>里面的构造函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,age,career</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.career = career;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>User</code>本质上就是一个构造器。这里使用的是<code>ES5</code>的构造函数(<code>ES6</code>里面的<code>class</code>本质上还是构造函数，<code>class</code>只是一个语法糖而已)</p><p>有了这个构造器，在进行员工信息录入的时候，就不用手动去对象里面创建字面量了，自动让程序从数据库里面获取到员工的姓名，年龄等字段，然后来一个简单的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(name,age,carrer);</span><br></pre></td></tr></table></figure></p><p>那么这个地方就设计到了<strong>构造器模式</strong>，这个模式就比较简单了，看上去其实就是一个<code>new</code>的过程。</p><p>但这里主要需要理解的是在构造过程中，谁发生了变化，而谁没有变化。</p><p>在使用构造器模式的时候，本质上是去抽象了每个对象实例的变与不变。而使用工厂模式则就是<strong>抽象不同构造函数（类）之间的变与不变</strong>。</p><h2 id="简单工厂模式–理解“变”与“不变”"><a href="#简单工厂模式–理解“变”与“不变”" class="headerlink" title="简单工厂模式–理解“变”与“不变”"></a>简单工厂模式–理解“变”与“不变”</h2><p>接着上面的例子扯，如果要对员工的<code>title</code>进行一个区分:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Coder</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.career = <span class="string">'coder'</span>;</span><br><span class="line">  <span class="keyword">this</span>.work = [<span class="string">'fix bug'</span>,<span class="string">'deploy'</span>,<span class="string">'coding'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PM</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.career = <span class="string">'PM'</span>;</span><br><span class="line">  <span class="keyword">this</span>.work = [<span class="string">'design picture'</span>,<span class="string">'open issue'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话就会出现多个类别，所以这里我们需要从数据库里面拿到数据之后，手动判断<code>title</code>之后让，然后手动分配构造器?这也就成类一个“变”的过程了，我们这里封装一个函数出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name,age,career</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(career)&#123;</span><br><span class="line">    <span class="keyword">case</span>: <span class="string">'coder'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Coder(name,age);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span>: <span class="string">'PM'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PM(name,age);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么一来。随着不同<code>title</code>人员的增加，这里<code>case</code>里面的代码数目也会跟着增加。</p><p>这里我们就又需要思考“变”与“不变”之间的关系了。</p><p>本质上<code>title</code>不同的两类人，他们不同的共性仅仅是字段<code>name</code>,<code>age</code>,<code>career</code>,<code>work</code>取值不同而已，同时<code>work</code>字段会随着<code>career</code>字段的取值不同而变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,age,career,work</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.career = career;</span><br><span class="line">  <span class="keyword">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name,age,career</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> work;</span><br><span class="line">  <span class="keyword">switch</span>(career)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'coder'</span>:</span><br><span class="line">      work = [<span class="string">'fix bug'</span>,<span class="string">'deploy'</span>,<span class="string">'coding'</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pm'</span>:</span><br><span class="line">      work = [<span class="string">'design picture'</span>,<span class="string">'open issue'</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'xxx'</span>:</span><br><span class="line">      <span class="comment">// others</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(name,age,career,work);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就不用去思考我们拿到的每组数据是什么工种，我应该怎么分配构造函数，更不用手写无数的构造函数–<code>Factory</code>函数已经帮我们完成了一切，我们只需要无脑的去传参数即可。</p><p>那么这样看来，工厂模式的目的本质上就是为了简化我们的构造过程，使我们可以无脑传参即可。</p><h2 id="抽象工厂模式–理解开放封闭原则"><a href="#抽象工厂模式–理解开放封闭原则" class="headerlink" title="抽象工厂模式–理解开放封闭原则"></a>抽象工厂模式–理解开放封闭原则</h2><p>抽象工厂模式在很长一段时间内都被认为是<code>Java/C++</code>这一类<strong>强类型动态语言的专利</strong>，因为用这些语言创建对象的时候需要时刻考虑类型之间的解耦，以便于该对象日后可以变现出多态性。但<code>JavaScript</code>作为弱类型语言具有天然的多态性，基本上不需要考虑类型耦合带来的问题。而目前的<code>JavaScript</code>语法也不支持抽象类的直接实现，只能通过模拟来实现。</p><p>在实际的业务中，我们往往面对的复杂度并非数个类，一个工厂就能解决的，可能需要多个。</p><p>就上节工厂函数的例子来看，工厂函数是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name,age,career</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> work;</span><br><span class="line">  <span class="keyword">switch</span>(career)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'coder'</span>:</span><br><span class="line">      work = [<span class="string">'fix bug'</span>,<span class="string">'deploy'</span>,<span class="string">'coding'</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pm'</span>:</span><br><span class="line">      work = [<span class="string">'design picture'</span>,<span class="string">'open issue'</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'boss'</span>:</span><br><span class="line">      work = [<span class="string">'have a meeting'</span>,<span class="string">'read'</span>]</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'xxx'</span>:</span><br><span class="line">      <span class="comment">// others</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(name,age,career,work);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这些代码是经不起推敲的，因为在员工系统里面<code>Boss</code>和普通员工是有明显的区别的。两者基本很难在一套系统里面共存下来，因为本身所具备的权限是不一样的。</p><p>那么接下来我们呢应该怎么做呢？去修改<code>Factory</code>的函数体，在里面新增管理层的判断和处理逻辑吗？从处理逻辑来看是没有问题的，但其实从全局来看这是在挖坑，因为员工里面可能还有外包群体和实习生之类但职级差别,这样每次我们需要去新增新的工种的时候，都需要直接对<code>Factory</code>这个函数体本身去进行一个修改，这样会使得<code>Factory</code>变得异常庞大，相当于是在对系统进行挖坑了。这样其他人在维护或者测试在测试的时候很难对这个<code>Factory</code>下手。导致这一系列问题的罪魁祸首还是因为—<strong>没有遵循开放封闭原则</strong>。</p><p>我们再次回顾一下开放封闭原则的内容:<strong>对拓展开放，对修改封闭</strong>。确切而言:是<strong>软件实体可以拓展，但是不可以修改</strong>。像上面就是在疯狂修改而不是在拓展。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>可能上面有些概念对我们来说有些抽象，现在我们重新来进行一个示例:</p><p>大家都知道一部手机是由<code>OS</code>和<code>HardWare</code>组成。所以一家工厂想实现对手机对量产，那么肯定是既要准备好了操作系统，也要有硬件。考虑到这两者背后也存在不同到厂商，而我现在并不知道我到下一个生产线具体想生产一个怎么样到手机，只知道一个手机主要由这两者组成，因此我们先使用一个抽象类来<strong>约定这台手机的基本组成：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 操作系统接口</span></span><br><span class="line">  createOS () &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`抽象工厂方法不能直接调用，需要重写`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提供硬件的接口</span></span><br><span class="line">  createHardWare () &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`抽象工厂方法不能直接调用，需要重写`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个类除了约定流水线手机的通用能力之外，啥也不能干了。如果你尝试让他去干点啥，比如<code>new</code>一个实例出来，并且去调用它的实例方法。它还会报错。在抽象工厂模式里面，上面这个类其实就是我们食物链顶端最大的<code>Boss-AbstractFactory</code>(抽象工厂)。</p><p>抽象工厂并不会干活，具体工厂(<code>ConcreteFactory</code>)来干活，当我们明确了生产方案，明确了某一条流水线具体要生产怎么样的手机之后，就可以化抽象为具体，比如我现在想要生产一个专门生产<code>Android</code>系统 + 高通硬件的手机的生产线，我给这类手机型号起名为<code>FakeStar</code>，那我就可以为这个手机定制一个工厂:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体工厂继承自抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeStarFactory</span> <span class="keyword">extends</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">   createOS () &#123;</span><br><span class="line">    <span class="comment">//  提供android系统实例</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> AndroidOS(); </span><br><span class="line">   &#125;</span><br><span class="line">   createHardWare () &#123;</span><br><span class="line">    <span class="comment">//  提供高通硬件实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QualcommHardWare();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在提供安卓系统的时候，调用了两个构造函数:<code>AndroidOS</code>和<code>QualcommHardWare</code>，它们分别用于生产具体的操作系统和硬件系统实例。像这种被我们拿出来用于<code>new</code>出具体对象的类，叫做具体产品类(<code>ConcreteProduct</code>)。具体产品往往不会孤立存在，不同的具体产品类往往有着共同的功能，比如安卓类和苹果系统类，它们都是操作系统，都有着可以<strong>操控手机硬件系统</strong>这样一个最基本的功能。因此我们可以使用一个<strong>抽象产品类</strong>来声明这一类产品应该具有的基本功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义操作系统这一类产品的抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  controlHardWare () &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`抽象产品方法允许直接调用，需要重写`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体操作系统的具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidOS</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  controlHardWare () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我会用android的方式去操作硬件'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOS</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  controlHardWare () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我会用苹果的方式去操作硬件'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>对于硬件类产品也是同理:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义手机硬件这类产品的抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  手机硬件的共性方法，这里提取“根据命令运转”这个共性</span></span><br><span class="line">  operateByOrder () &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`抽象产品方法不允许直接调用，需要重写`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体硬件的具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QualcommHardWare</span> <span class="keyword">extends</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">  operateByOrder () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我会用高通的方式去运转`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiWare</span> <span class="keyword">extends</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">  operatorByOrder () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我会用小米的方式去运转`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一来，当我们需要生产一台<code>FakeStar</code>手机时候，我们只需要这样做:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我的手机</span></span><br><span class="line"><span class="keyword">const</span> myPhone = <span class="keyword">new</span> FakeStarFactory();</span><br><span class="line"><span class="comment">// 让它拥有系统</span></span><br><span class="line"><span class="keyword">const</span> myOS = myPhone.createOS();</span><br><span class="line"><span class="comment">// 让它拥有硬件</span></span><br><span class="line"><span class="keyword">const</span> myHardWare = myPhone.createHardWare();</span><br><span class="line"><span class="comment">// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)</span></span><br><span class="line">myOS.controlHardWare();</span><br><span class="line"><span class="comment">// 唤醒硬件(输出‘我会用高通的方式去运转’)</span></span><br><span class="line">myHardWare.operateByOrder();</span><br></pre></td></tr></table></figure></p><p>那么关键时刻来了–假如有一天，<code>FakeStar</code>过气了，我们需投入一款新机进入市场，这时候怎么办？我们是不是需要对<strong>抽象工程MobilePhoneFactory</strong>做任何修改，只需要拓展它的种类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStarFactory</span> <span class="keyword">extends</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">  createOS () &#123;</span><br><span class="line">    <span class="comment">// 操作系统实例化代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  createHardWare () &#123;</span><br><span class="line">    <span class="comment">// 硬件实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个操作，对原有对系统不会产生任何潜在对影响，所谓对”对拓展开放，对修改封闭”就这么圆满的实现了。前面我们之所以要实现<strong>抽象产品类</strong>，也是相同的道理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们可以对比一下抽象工厂和简单工厂的思路，思考一下:它们之间又哪些异同?<br>它们的共同点在于，都<strong>尝试去分离一个系统中变与不变的部分</strong>。它们的不同在于场景的复杂度。在简单工厂的使用场景里面，处理的对象是类，并且是一些非常好对付的类–它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可拓展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对共性作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：</p><ul><li>抽象工厂(抽象类，它不能用于生成具体的实例)。</li><li>具体工厂(用于生成产品族里的一个具体的产品)。</li><li>抽象产品(抽象类，他不能用于生成具体实例)。</li><li>具体产品(用于生产产品族里的一个具体产品所依赖的更细粒度的产品)。</li></ul><p>抽象工厂的定义，主要是<strong>围绕一个超级工厂去构建其他的工厂</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计模式之道&quot;&gt;&lt;a href=&quot;#设计模式之道&quot; class=&quot;headerlink&quot; title=&quot;设计模式之道&quot;&gt;&lt;/a&gt;设计模式之道&lt;/h2&gt;&lt;h3 id=&quot;SOLID原则&quot;&gt;&lt;a href=&quot;#SOLID原则&quot; class=&quot;headerlink&quot; title=&quot;SOLID原则&quot;&gt;&lt;/a&gt;SOLID原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单一功能原则(&lt;code&gt;Single Responsibility Principle&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;开放封闭原则(&lt;code&gt;Opened Closed Principle&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;里式替换原则(&lt;code&gt;Liskov Substitution Principle&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;接口隔离原则(&lt;code&gt;Interface Segregation Principle&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;依赖反转原则(&lt;code&gt;Dependency Inversion Principle&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;JS&lt;/code&gt;里面主要还是围绕着“单一功能”和“开放封闭”来展开。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>electron开发小记</title>
    <link href="http://zoomdong.site/2019/11/01/electron/"/>
    <id>http://zoomdong.site/2019/11/01/electron/</id>
    <published>2019-11-01T06:39:00.000Z</published>
    <updated>2019-11-01T06:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="electron开发记录"><a href="#electron开发记录" class="headerlink" title="electron开发记录"></a>electron开发记录</h2><p>首先根据官方文档的<a href="https://electronjs.org/docs/tutorial/first-app#trying-this-example" target="_blank" rel="noopener">启动脚手架</a>来先跑一波<code>electron</code>,注意这一步在<code>npm i</code>的时候有一个比较大的依赖在注入进来，所以会安装比较长的时间。</p><ul><li><code>Electron</code>本身是基于<code>Chrominum</code>和<code>Node.js</code></li><li>开源</li><li>跨平台</li></ul><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>以Chromium举例，它有两个进程，一个主进程，一个是渲染进程.</p><p>主进程(Main Process)</p><ul><li>可以使用和系统对接的<code>Electron API</code> 创建菜单，上传文件等</li><li>可以创建渲染进程- <code>Renderer Process</code></li><li>全面支持<code>Node.js</code></li></ul><p>渲染进程(Renderer Process)</p><ul><li>可以有多个，每个对应一个窗口</li><li>每个都是一个单独的进程</li><li>全面支持<code>Node.js</code>和<code>DOM API</code></li><li>可以使用一部分<code>Electron Api</code></li></ul><p>比如官方提供的<code>quick-electron</code>这个脚手架里面的<code>main.js</code>和<code>renderer.js</code>就分别代表主进程和渲染进程的代码。</p><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><p>首先先介绍一下主进程里面一个比较重要的<code>api</code>叫做<code>BroswerWindow</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示electron已经完成加载好了，准备运行了</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, ()=&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">     width: <span class="number">800</span>,</span><br><span class="line">     height: <span class="number">600</span>,</span><br><span class="line">     webPreferences: &#123;</span><br><span class="line">      <span class="comment">//  表示我们在里面可以使用node的api</span></span><br><span class="line">       nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  <span class="comment">//  这里的mainWindow回去下载的当前目录下面的index.html这个文件 </span></span><br><span class="line">   mainWindow.loadFile(<span class="string">'./index.html'</span>);</span><br><span class="line">   <span class="keyword">const</span> secondWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">     width: <span class="number">400</span>,</span><br><span class="line">     height: <span class="number">300</span>,</span><br><span class="line">     webPreferences: &#123;</span><br><span class="line">       nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="comment">//  父窗口属性，当父窗口关闭的时候，子窗口也会跟着关闭</span></span><br><span class="line">     parent: mainWindow</span><br><span class="line">   &#125;)</span><br><span class="line">   secondWindow.loadFile(<span class="string">'./second.html'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以看到的是，在配置过<code>webPreferences</code>之后，我们在<code>index.html</code>里面的<code>js</code>代码中就可以使用相对应的<code>node api</code>以及一些相关的<code>dom api</code>。</p><p><code>index.html</code>的代码RT:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="built_in">require</span>(<span class="string">'./renderer.js'</span>)</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后在<code>renderer.js</code>里面写上对应的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以弹出nodejs的版本</span></span><br><span class="line">alert(process.versions.node);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">    alert(<span class="string">`greeting from the DOM side`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更多关于<a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">BroswerWindow相关</a>。</p><p>接下来介绍一下进程之前的通信工具，其实就比较类似于<code>nodeJS</code>里面的<code>emit</code>和<code>on</code>这种通信方式:</p><p>我们在渲染进程里面给主进程发送一个<code>message</code>,然后在<code>message</code>这边进行接收即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//  利用ipcRender以及send这个api发送一条消息</span></span><br><span class="line">    ipcRenderer.send(<span class="string">'message'</span>, <span class="string">'hello from renderer'</span>);</span><br><span class="line">    ipcRenderer.on(<span class="string">'reply'</span>,(e,arg)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 把主进程返回回来的消息挂载到页面的对应节点上面去</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>).innerHTML = arg;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>主进程这边接收到消息之后再<code>reply</code>给<code>render</code>进程这边回一个消息:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow, ipcMain &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示electron已经完成加载好了，准备运行了</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, ()=&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">    <span class="comment">//  表示我们在里面可以使用node的api</span></span><br><span class="line">    nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">mainWindow.loadFile(<span class="string">'./index.html'</span>);</span><br><span class="line"><span class="comment">//  用这边来监听renderer那边的值</span></span><br><span class="line">ipcMain.on(<span class="string">'message'</span>,(e,arg) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">    <span class="comment">// 可以在event里面利用发送者这个属性往渲染进程上再回复一组数据</span></span><br><span class="line">    e.sender.send(<span class="string">'reply'</span>,<span class="string">'hello from main'</span>)</span><br><span class="line">    mainWindow.send(<span class="string">'reply'</span>,<span class="string">'hello from main'</span>)  </span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="electron的应用发布与打包"><a href="#electron的应用发布与打包" class="headerlink" title="electron的应用发布与打包"></a>electron的应用发布与打包</h2><p>electron打包方式:</p><ul><li>手动打包</li><li>electron-packager</li><li><a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a></li></ul><p>这里使用<code>electron-builder</code>这个库来进行<code>electron</code>应用的一个打包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install electron-builder -D</span><br></pre></td></tr></table></figure><p>完成之后我们需要在<code>package.json</code>里面添加一份配置文件。用于打包生成对应的安装包。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">"build":&#123;</span><br><span class="line">     "appId":"Music-Player",</span><br><span class="line">     "linux": &#123;</span><br><span class="line">       "target": [</span><br><span class="line">         "AppImage",</span><br><span class="line">         <span class="string">"deb"</span></span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">     "dmg": &#123;</span><br><span class="line">      "background": "build/appdmg.png",</span><br><span class="line">      "icon": "build/icon.icns",</span><br><span class="line">      "iconSize": 100,</span><br><span class="line">      "contents": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">380</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">280</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">          <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"x"</span>: <span class="number">110</span>,</span><br><span class="line">          <span class="attr">"y"</span>: <span class="number">280</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "window": &#123;</span><br><span class="line">        "width": 500,</span><br><span class="line">        "height": 500</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后新建一个启动脚本:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"script":"electron-builder"</span><br></pre></td></tr></table></figure><p>这样就可以完成打包了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;electron开发记录&quot;&gt;&lt;a href=&quot;#electron开发记录&quot; class=&quot;headerlink&quot; title=&quot;electron开发记录&quot;&gt;&lt;/a&gt;electron开发记录&lt;/h2&gt;&lt;p&gt;首先根据官方文档的&lt;a href=&quot;https://electronjs.org/docs/tutorial/first-app#trying-this-example&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;启动脚手架&lt;/a&gt;来先跑一波&lt;code&gt;electron&lt;/code&gt;,注意这一步在&lt;code&gt;npm i&lt;/code&gt;的时候有一个比较大的依赖在注入进来，所以会安装比较长的时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Electron&lt;/code&gt;本身是基于&lt;code&gt;Chrominum&lt;/code&gt;和&lt;code&gt;Node.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小程序杂记</title>
    <link href="http://zoomdong.site/2019/10/08/mini-program/"/>
    <id>http://zoomdong.site/2019/10/08/mini-program/</id>
    <published>2019-10-08T05:37:01.000Z</published>
    <updated>2019-10-10T07:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>迫于生计开始写小程序.</p><p>小程序重要的东西有布局:<br>使用的是<code>flex</code>布局,这点很重要的。</p><p><code>justify-content</code>和<code>align-items</code>一个表示水平轴一个表示交叉轴，但是这两者的话都没有一个绝对的主轴，这点是要根据<code>flex-direction</code>的设定来确定的，<code>flex-direction</code>为<code>row</code>那么水平方向的就为主轴,另外一个为交叉轴，如果为<code>column</code>，那么垂直方向的就为主轴,另外一个为交叉轴。</p><p>当然如果加了<code>reverse</code>之后交叉轴的方向就得换个参照点了。</p><a id="more"></a><p>组件的使用可以参考页面里面的<code>json</code>里面的相关配置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"usingComponents": &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>注意这个地方使用组件的话一定要记得具体精确到文件里面去(貌似小程序这里不会默认解析<code>index</code>)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"usingComponents":&#123;</span><br><span class="line">  "v-like":"/components/like/index",</span><br><span class="line">  "v-movie":"/components/classic/movie/index",</span><br><span class="line">  "v-epsoide":"/components/epsoide/index"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序用<code>px</code>做单位的话，会直接乘以二去换算，所以一般使用<code>rpx</code>来作为单位(<code>rpx</code>尺寸是按照<code>1:1</code>来进行换算的),同时<code>rpx</code>是可以针对不同的机型去进行一个自适应。</p><p>字体的大小可能需要使用<code>px</code>(可能没必要使用随着机型去进行放大。)</p><p>小程序里面做适应的两个神器:</p><ul><li>flex</li><li>rpx</li></ul><p>设置全局样式在<code>app.wxss</code>里面的<code>page</code>里面设置就可以了，不需要自己去设置，现在大部分样式都可以继承下来了。</p><p>组件最好不要留有空白间距。</p><h2 id="数据显示"><a href="#数据显示" class="headerlink" title="数据显示"></a>数据显示</h2><p>数据的来源</p><ul><li>WXML</li><li>JS-&gt;WXML</li><li>服务器-&gt;JS-&gt;WXML</li></ul><p>数据绑定 组件内部的数据放在<code>js</code>文件里面的<code>data</code>里面去,然后<code>wxml</code>去调用的时候<code></code>这样表示即可。 </p><p>三元表达式这样调用即可:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text&gt;&#123;&#123; like ? count1 : count2 &#125;&#125;&lt;<span class="regexp">/text&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果我们想要在一个图片里面这么玩的话，可以把<code>src</code>的值封装成变量即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=<span class="string">"&#123;&#123; like ? yesSrc : noSrc &#125;&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    like: <span class="literal">false</span>,</span><br><span class="line">    count1: <span class="number">99</span>,</span><br><span class="line">    count2: <span class="number">999</span>,</span><br><span class="line">    yesSrc:<span class="string">'./images/like.png'</span>,</span><br><span class="line">    noSrc: <span class="string">'./images/like@dis.png'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这么表示即可。里面<code>properties</code>里面可以指定使用一些组件外部能够操作的数据，就如上面<code>like</code>和<code>count</code>肯定是要外部能够操作的,我们就需要把这些属性发在<code>properties</code>里面去就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">  like: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  count: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">data: &#123;</span><br><span class="line">  yesSrc:<span class="string">'./images/like.png'</span>,</span><br><span class="line">  noSrc: <span class="string">'./images/like@dis.png'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>事件的定义在<code>methods</code>里面去拿数据就可了。</p><p>然后我们去给里面绑定一个事件(注意学习一波这里取数据的方法是可以使用<code>es6</code>的,修改数据使用的是类似于<code>react</code>里面的那套<code>api</code>):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    onLike:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> &#123; like, count &#125; = <span class="keyword">this</span>.properties;</span><br><span class="line">       count = like ? count - <span class="number">1</span> : count + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">         count,</span><br><span class="line">         like: !like</span><br><span class="line">       &#125;) </span><br><span class="line">       <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里注意到小程序里面的一些事件(这里以<code>like</code>组件作为例子)，我们都是写在<code>methods</code>里面的。如果我们想调用这个绑定这个事件到<code>wxml</code>里面去的话，使用小程序相对应的语法即可(<code>bind:tap=&quot;onLike&quot;</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- image组件是有默认的宽和高的 --&gt;</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span> bind:tap=<span class="string">"onLike"</span>&gt;</span><br><span class="line">   &lt;image src=<span class="string">"&#123;&#123; like ? yesSrc : noSrc &#125;&#125;"</span> /&gt;</span><br><span class="line">   &lt;text&gt;&#123;&#123; count &#125;&#125;&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;</span><br></pre></td></tr></table></figure><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>利用小程序来访问<code>API</code>数据,还是和之前的框架(例如<code>react</code>,<code>vue</code>)一样，我们需要一个生命周期函数.</p><p>一般我们创建一个页面里面的<code>js</code>文件里面都会帮我们默认写好生命周期函数。</p><p>生命周期函数的概念是和<code>react</code>,<code>vue</code>里面的生命周期函数没有区别的。</p><p>一般我们发送请求的数据都会放在<code>onLoad()</code>这个生命周期函数之类，这个生命周期函有点类似于<code>react</code>里面被移除的一个<code>API</code>叫做<code>componentWillMount</code>,但是这里我们一般都把请求写在这里(毕竟小程序没有<code>react</code>那么多的东西要去拓展。。。)</p><h3 id="onLoad"><a href="#onLoad" class="headerlink" title="onLoad"></a>onLoad</h3><p>我们在这个地方进行数据请求的话，我们会使用<code>wx.request()</code>这个函数去进行一个<code>api</code>的调用。相关文档参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#API" target="_blank" rel="noopener">这里</a></p><p>使用的话大概是这个样子为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: <span class="string">'http://bl.7yue.pro/v1/classic/latest'</span>,</span><br><span class="line">    <span class="comment">// res是服务器返回给我们的数据,在success这个里面能拿到</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>对于开发过程中产生的无法校验的<code>http</code>接口的情况的话，我们可以在小程序开发者工具里面关闭掉关于<code>http</code>校验的相关操作。<code>wx.request()</code>这里也和<code>axios</code>一样，这里就是个异步函数。所以想拿到值，我们需要自己来操作一下(上面就是一种操作)。</p><p>回调函数有个缺陷就是，在回调函数的外面<code>this</code>是有值的，比如<code>success</code>这个函数的外面是可以抓到值的，但是到<code>success</code>里面使用<code>this.data.xxx</code>去拿<code>data</code>里面的数据是拿不到的。这个时候我们把<code>this</code>赋值一下就ok了.<code>let self = this</code>(就是之前那种传统的方法)，当然这里我们用箭头函数就OK了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">success:<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们前面在<code>like</code>组件里面使用了两个<code>properities</code>(分别为<code>count</code>和<code>like</code>),这里我们就可以使用父组件来将这两个值从父组件这里传递下去。</p><p><code>home.wxml</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;v-like like=<span class="string">"&#123;&#123; classicData.like_status &#125;&#125;"</span> count=<span class="string">"&#123;&#123; classicData.fav_nums &#125;&#125;"</span>  /&gt;</span><br></pre></td></tr></table></figure><p>通过这样可以类似<code>react</code>里面的<code>props</code>将值传递下去。</p><p>在<code>home.js</code>这边获取到请求的数据还是和以前<code>react</code>里面一样，拿到数据后把他使用请求数据的组件的状态存储下面就可了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  classic.getLatest(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        classicData:res</span><br><span class="line">      &#125;) </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>setData</code>和<code>react</code>里面的<code>setState</code>是一模一样的= =,都是用来搞数据更新的，但你不能直接去改变<code>data</code>里面的数据值。</p><h2 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h2><p>我们在使用组件的时候，有的时候可能需要去使用到一些我们自己定义的一系列事件(因为使用原有的事件会有些东西无法获取到)。我们之间监听一个组件的点击事件使用的是<code>bind:tap=&quot;xxx(事件名)&quot;</code>,类似于<code>react</code>里面的<code>onClick</code>事件一样hhh。</p><p>但是我们在父组件里面这样去监听子组件的点击事件的时候是拿不到当前子组件里面的一些状态。</p><p>所以我们要先在子组件里面创建一个自定义事件来通知页面点击了事件，然后把父组件知道的状态传递出去，我们需要使用小程序里面自带的自定义事件里面的激活<code>API</code>来完成操作即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    onLike:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> &#123; like, count &#125; = <span class="keyword">this</span>.properties;</span><br><span class="line">       count = like ? count - <span class="number">1</span> : count + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">         count,</span><br><span class="line">         like: !like</span><br><span class="line">       &#125;) </span><br><span class="line">        <span class="comment">// 发起一个自定义事件 </span></span><br><span class="line">        <span class="keyword">let</span> behavior = <span class="keyword">this</span>.properties.like ? <span class="string">'like'</span> : <span class="string">'cancel'</span></span><br><span class="line">        <span class="comment">// 在这里激活我们的自定义事件like,它里面还有第三个参数</span></span><br><span class="line">        <span class="keyword">this</span>.triggerEvent(<span class="string">'like'</span>,&#123;</span><br><span class="line">           behavior</span><br><span class="line">        &#125;,&#123;&#125;)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后我们将父组件里面需要调用的事件绑定到<code>like</code>这个东西上面即可:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-like</span> <span class="attr">bind:like</span>=<span class="string">"LikeClick"</span>   /&gt;</span></span><br></pre></td></tr></table></figure><p>然后父组件里面定义一下这个点击事件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LikeClick: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>这个时候<code>event</code>那里就可以拿到子组件传递过来的<code>behavior</code>了。</p><h2 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h2><p>就想<code>pages</code>有自己的生命周期函数，组件(<code>components</code>)里面也会有自己的生命周期函数。</p><p>我们想在组件里面输出一些值的内容的话是可以在生命周期函数里面输出的:<br>一般会使用<code>attached</code>这个生命周期函数的钩子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">     index:<span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">      year: <span class="built_in">Number</span>,</span><br><span class="line">      month: <span class="built_in">String</span>, </span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.properties);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>attached</code>这个地方会打印出一个属性的值。<code>properties</code>和<code>data</code>这个地方会输出同样的值(所以这个地方我们不要给这两个东西写个同样的值，一般情况下<code>data</code>会覆盖掉<code>properties</code>下面同样的值)。</p><p>从父组件传递过来的数字，我们一般不放在<code>attached</code>这个生命周期函数里面去写，我们会使用<code>properities</code>这个属性里面的一个<code>observer</code>参数来去做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">     index:&#123;</span><br><span class="line">       type: <span class="built_in">String</span>,</span><br><span class="line">       observer: <span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal,changePath</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">let</span> val = newVal &lt; <span class="number">10</span> ? <span class="string">'0'</span> + newVal : newVal;</span><br><span class="line">         <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">           _index: val </span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">      year:<span class="number">0</span>,</span><br><span class="line">      month: <span class="string">''</span>, </span><br><span class="line">      _index: <span class="string">'0'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  attached: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然这个地方也不能在<code>observer</code>内部使用<code>this.setData</code>里面去修改<code>index</code>这个值，因为这里会出现无限递归调用的现象，就像在<code>render</code>里面使用<code>componentDidMount</code>一样。这个地方所以需要使用一个类似中转变量的东西<code>_index</code>来去回避那个陷阱。(不要在一个属性的监听值里面去修改这个监听值的内容)。</p><h2 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h2><p>小程序里面提供了组件的复用机制可以使用<code>behavior</code>这个<code>API</code>。</p><p>比如说我们的多个组件里面有一些可以共用的东西，例如一些<code>properities</code>或者是<code>data</code>或者是<code>methods</code>甚至是<code>attached</code>这个生命周期函数都可以。</p><p>现在假设我们的组件里面都用共用的两个属性叫做<code>img</code>和<code>content</code>,我们在组件目录下的根路径下面新建一个<code>classic-beh.js</code>的文件，里面使用<code>Behavior</code>来新建一个公共的属性即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> classicBeh = Behavior(&#123;</span><br><span class="line">    properties: &#123;</span><br><span class="line">        img:<span class="built_in">String</span>,</span><br><span class="line">        content: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; classicBeh &#125;</span><br></pre></td></tr></table></figure><p>然后我们需要使用这些公共属性的组件是可以直接去里面调用这些东西的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; classicBeh &#125; <span class="keyword">from</span> <span class="string">'../classic-beh'</span>;</span><br><span class="line">Component(&#123;</span><br><span class="line">  behaviors: [ classicBeh ],  </span><br><span class="line">  properities: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    pauseSrc: <span class="string">'images/player@waitting.png'</span>,</span><br><span class="line">    playSrc: <span class="string">'images/player@playing.png'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在组件内部通过<code>behaviors</code>这个属性去直接进行一波的调用。这样以后这些组件有了共同的趋势了的话，这样我们直接去<code>behavior</code>里面去添加属性。</p><h2 id="循环渲染数据"><a href="#循环渲染数据" class="headerlink" title="循环渲染数据"></a>循环渲染数据</h2><p>在<code>jsx</code>里面渲染数据的话，我们一般都是直接使用<code>map</code>对一个对象数组去进行一个遍历，而在小程序里面，我们通常使用这样的语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;books&#125;&#125;"</span>&gt;</span><br><span class="line">    &lt;v-book book=<span class="string">"&#123;&#123;item&#125;&#125;"</span> /&gt;    </span><br><span class="line">&lt;<span class="regexp">/block&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>小程序里面也有和<code>vue</code>一样的插槽<code>slot</code>概念:</p><p>比如说我们在一个组件(<code>v-tag</code>组件)里面使用插槽:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;text&gt;&#123;&#123; text &#125;&#125;&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- &lt;text&gt;&#123;&#123; num &#125;&#125;&lt;/</span>text&gt; --&gt;</span><br><span class="line">    &lt;!-- 从组件外部传递进来，类似于react的props.children --&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"after"</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;</span><br></pre></td></tr></table></figure><p>同样在组件的<code>js</code>文件里面添加一些相关的配置:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  multipleSlots: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>然后我们去调用这个组件的时候<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line"> &lt;v-tag&gt;</span><br><span class="line">   &lt;text slot=<span class="string">"after"</span>&gt;这个插槽会放到after那里去&lt;<span class="regexp">/text&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>v-tag&gt;</span><br><span class="line">&lt;<span class="regexp">/view&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样就修改成功了。</p><p>通过在父组件里面使用选择器<code>css</code>样式来设定对应列表组件的样式(在组件是列表组件的情况下):<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用子元素选择器来使选择更加精准从而使得避免安全问题 */</span></span><br><span class="line"><span class="selector-class">.comment-container</span> &gt; <span class="selector-tag">v-tag</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">view</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fffbdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.comment-container</span> &gt; <span class="selector-tag">v-tag</span><span class="selector-pseudo">:nth-child(2)</span> &gt; <span class="selector-tag">view</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eefbff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h2&gt;&lt;p&gt;迫于生计开始写小程序.&lt;/p&gt;
&lt;p&gt;小程序重要的东西有布局:&lt;br&gt;使用的是&lt;code&gt;flex&lt;/code&gt;布局,这点很重要的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;justify-content&lt;/code&gt;和&lt;code&gt;align-items&lt;/code&gt;一个表示水平轴一个表示交叉轴，但是这两者的话都没有一个绝对的主轴，这点是要根据&lt;code&gt;flex-direction&lt;/code&gt;的设定来确定的，&lt;code&gt;flex-direction&lt;/code&gt;为&lt;code&gt;row&lt;/code&gt;那么水平方向的就为主轴,另外一个为交叉轴，如果为&lt;code&gt;column&lt;/code&gt;，那么垂直方向的就为主轴,另外一个为交叉轴。&lt;/p&gt;
&lt;p&gt;当然如果加了&lt;code&gt;reverse&lt;/code&gt;之后交叉轴的方向就得换个参照点了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nuxt.js及Vue-SSR学习笔记</title>
    <link href="http://zoomdong.site/2019/10/04/nuxt-ssr/"/>
    <id>http://zoomdong.site/2019/10/04/nuxt-ssr/</id>
    <published>2019-10-04T02:08:38.000Z</published>
    <updated>2019-10-04T02:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nuxt-js基础"><a href="#Nuxt-js基础" class="headerlink" title="Nuxt.js基础"></a>Nuxt.js基础</h2><ul><li>Vue2</li><li>Vue Router</li><li>Vuex</li><li>Vue Server Renderer</li><li>vue-meta</li></ul><p>首先还是<a href="https://nuxtjs.org/" target="_blank" rel="noopener">官方地址</a>给上。</p><p>安装:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先安装一下vue-cli工具</span></span><br><span class="line">yarn global add @vue/cli-init </span><br><span class="line"><span class="comment">// 初始化模板</span></span><br><span class="line">vue init nuxt-community/koa-template</span><br></pre></td></tr></table></figure></p><p>还源的工具可以使用<code>nrm</code>，类似于版本控制的<code>npm</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure></p><p><code>nuxt.js</code>是非常适合做<code>vue</code>的<code>ssr</code>渲染的，他可以让<code>ssr</code>变得非常非常简单。</p><p>我们直接利用刚才那个命令来生成一个<code>nuxt.js</code>模板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init nuxt-community/koa-template nuxt-start</span><br></pre></td></tr></table></figure><p>不过这里可能会遇见一个问题。具体可以参考，项目的<a href="https://github.com/fireairforce/nuxt-starter/blob/master/README.md" target="_blank" rel="noopener">README.md文档</a>。</p><p>这东西的设计其实和<code>umi</code>很类似(可能<code>umi</code>是借鉴了这边吧。。)有一点就是<code>pages</code>目录下面的文件即为路由。我们创建一个<code>xxx.vue</code>，然后去<code>localhost:3000/xxx</code>,就可以直接访问到对应的页面了。</p><a id="more"></a><p>那个<code>layouts</code>就是一个公共的模板。里面有个公用的<code>footer</code>。里面会有个<code>default.vue</code>就是默认的模板。</p><p>里面会有这样的模板代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nuxt</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-footer</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们<code>pages</code>里面的代码都会被生成出来放到<code>&lt;nuxt /&gt;</code> 里面去，而模板文件则会被放在例如<code>&lt;my-footer /&gt;</code>那里去。</p><p>如果我们想要自定义一个模板,直接在<code>layouts</code>下面新建一个<code>search.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout-search"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>search layout header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nuxt</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>search layout footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.layout-search</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后如果要使用这个模板，直接在<code>pages</code>目录下面的<code>search.vue</code>里面引入一下就可了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">      Page is Search</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  layout: <span class="string">'search'</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样去访问<code>search</code>这个路由的时候相对应的<code>layouts</code>就会显示上去。</p><p>其中里面全局的<code>css</code>设定可以在<code>nuxt.config.js</code>里面可以看见,<code>assets/css</code>的<code>main.css</code>被设定成为了全局的<code>css</code>。</p><h2 id="接口相关"><a href="#接口相关" class="headerlink" title="接口相关"></a>接口相关</h2><p>和<code>koa2</code>相关的目录就是<code>server</code>下面的<code>index.js</code>，里面的配置其实也不用改什么了。</p><p>我们去<code>server</code>目录下面新建一个<code>interface</code>目录，然后里面放一个<code>city.js</code>,其代码为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'koa-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  prefix: <span class="string">'/city'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/list'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">      list: [<span class="string">'北京'</span>, <span class="string">'天津'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>然后去<code>index.js</code>里面使用一下这个路由:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cityInterface <span class="keyword">from</span> <span class="string">'./interface/city'</span></span><br><span class="line"></span><br><span class="line">app.use(cityInterface.routes()).use(cityInterface.allowedMethods())</span><br></pre></td></tr></table></figure></p><p>然后我们可以在<code>search.vue</code>里面去搞一发:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">      Page is Search</span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  layout: <span class="string">'search'</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      list: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  <span class="comment">//  用这个类似于componentDidmout()的函数去进行一个数据请求  </span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">async</span> mounted () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> &#123; status, <span class="attr">data</span>: &#123; list &#125; &#125; = <span class="keyword">await</span> axios.get(<span class="string">`/city/list`</span>)</span></span><br><span class="line">    if (status === 200) &#123;</span><br><span class="line">        self.list = list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们刷新页面去看，会发现使用<code>vue</code>里面的生命周期函数去请求的话，到了页面里面，渲染的地方会发生短暂的闪烁，同时查看源码的话，是没有任何结果显示出来的。</p><p>这里如果我们换成<code>nuxt.js</code>里面专门的<code>api</code>的话，就相当于将数据已经存储在服务器端了，然后再利用<code>ssr</code>去将数据渲染出来，这里就不会出现上面那种在浏览器端去请求数据的情况了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> asyncData () &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; status, <span class="attr">data</span>: &#123; list &#125; &#125; = <span class="keyword">await</span> axios.get(<span class="string">`http://localhost:3000/city/list`</span>)</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样去查看源代码的话，就会显示成模板显示成功的样子。</p><p>如果我们把<code>asyncData</code>改成<code>fetch</code>的话(他们两个<code>api</code>都可以获得数据)，但是如果使用<code>fetch</code>会发现并不会获得到数据，是因为<code>fetch</code>是用来处理和<code>vuex</code>相关的数据，而<code>asyncData</code>则是用来处理和组件相关的数据，所以使用<code>fetch</code>并不会拿到数据。所以这里就要用<code>asyncData()</code>,想在初始状态那里拿到一些数据是可以使用<code>fetch</code>的。</p><h3 id="vuex在SSR里面的使用"><a href="#vuex在SSR里面的使用" class="headerlink" title="vuex在SSR里面的使用"></a>vuex在SSR里面的使用</h3><p>可以根据<code>nuxt.js</code>里面的<a href="https://zh.nuxtjs.org/guide/vuex-store/" target="_blank" rel="noopener">文档</a>来查看<code>vuex</code>的使用，同样的也是文件即为配置使用方法。</p><p>这样直接创建一个示例就明白了:<br>根据官方文档的需求，我们直接在根目录下面创建一个<code>store</code>目录，里面用来放<code>vuex</code>相关的文件,我们先建立两个示例文件:</p><p><code>store/modules/city.js</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  list: [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  add (state, text) &#123;</span><br><span class="line">    state.list.push(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">&#123; commit &#125;, text</span>) =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">'add'</span>, text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>store/modules/navbar.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  app: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  add (state, text) &#123;</span><br><span class="line">    state.list.push(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">&#123; commit &#125;, text</span>) =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">'add'</span>, text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根目录下面的文件为<code>store/index.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> city <span class="keyword">from</span> <span class="string">'./modules/city'</span></span><br><span class="line"><span class="keyword">import</span> navbar <span class="keyword">from</span> <span class="string">'./modules/navbar'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    city,</span><br><span class="line">    navbar</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//  把实例放在数据里面验证一下</span></span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>假如我们想在<code>vue</code>里面直接调用数据的话，这里都不用像<code>vue-cli</code>里面那样去注册啥，直接就可以调用了，假设我们想调用<code>city.js</code>里面的<code>state</code>数据，直接使用<code>$store</code>去调用就可以了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in $store.state.city.list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意每次修改了vuex的相关配置之后，都要记得重启即可</strong></p><p>这里的数据也是和<code>服务端</code>同步的，都会被挂载到<code>dom</code>下面去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nuxt-js基础&quot;&gt;&lt;a href=&quot;#Nuxt-js基础&quot; class=&quot;headerlink&quot; title=&quot;Nuxt.js基础&quot;&gt;&lt;/a&gt;Nuxt.js基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Vue2&lt;/li&gt;
&lt;li&gt;Vue Router&lt;/li&gt;
&lt;li&gt;Vuex&lt;/li&gt;
&lt;li&gt;Vue Server Renderer&lt;/li&gt;
&lt;li&gt;vue-meta&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先还是&lt;a href=&quot;https://nuxtjs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方地址&lt;/a&gt;给上。&lt;/p&gt;
&lt;p&gt;安装:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 先安装一下vue-cli工具&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn global add @vue/cli-init &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化模板&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vue init nuxt-community/koa-template&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还源的工具可以使用&lt;code&gt;nrm&lt;/code&gt;，类似于版本控制的&lt;code&gt;npm&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nrm ls&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nuxt.js&lt;/code&gt;是非常适合做&lt;code&gt;vue&lt;/code&gt;的&lt;code&gt;ssr&lt;/code&gt;渲染的，他可以让&lt;code&gt;ssr&lt;/code&gt;变得非常非常简单。&lt;/p&gt;
&lt;p&gt;我们直接利用刚才那个命令来生成一个&lt;code&gt;nuxt.js&lt;/code&gt;模板。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vue init nuxt-community/koa-template nuxt-start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这里可能会遇见一个问题。具体可以参考，项目的&lt;a href=&quot;https://github.com/fireairforce/nuxt-starter/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;README.md文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这东西的设计其实和&lt;code&gt;umi&lt;/code&gt;很类似(可能&lt;code&gt;umi&lt;/code&gt;是借鉴了这边吧。。)有一点就是&lt;code&gt;pages&lt;/code&gt;目录下面的文件即为路由。我们创建一个&lt;code&gt;xxx.vue&lt;/code&gt;，然后去&lt;code&gt;localhost:3000/xxx&lt;/code&gt;,就可以直接访问到对应的页面了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
