<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zoomdong&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zoomdong.site/"/>
  <updated>2020-06-04T16:14:49.017Z</updated>
  <id>http://zoomdong.site/</id>
  
  <author>
    <name>zoomdong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>背包问题分析</title>
    <link href="http://zoomdong.site/2020/06/04/dp-3/"/>
    <id>http://zoomdong.site/2020/06/04/dp-3/</id>
    <published>2020-06-04T11:08:04.000Z</published>
    <updated>2020-06-04T16:14:49.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dp技巧思路总结——背包"><a href="#dp技巧思路总结——背包" class="headerlink" title="dp技巧思路总结——背包"></a>dp技巧思路总结——背包</h2><p>0-1背包相关题目可以参考上一篇文章，这篇开始介绍一些其他的背包问题例如多重背包等。</p><h2 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h2><p>这题在0-1背包那边已经讲过了，这里重新讲一次：</p><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">Leetcode 416题</a></p><a id="more"></a><p>这个问题看上去和背包并没有太大的关系，实际上我们可以先回忆一下背包问题的大致描述：</p><p>载重 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品重量是 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让背包去装物品，能装的最大的价值是？</p><p>这个子集问题就可以转换为载重量为 <code>sum/2</code> 的背包，和 <code>N</code> 个物品，每个物品重量为 <code>nums[i]</code> 。现在让你去装物品，是否存在一种装法，能够恰好装满背包？</p><h3 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析"></a>解法分析</h3><ol><li>先来确定状态和选择。</li></ol><p>背包问题的状态就是“<strong>背包的容量</strong>”和“<strong>可选择的物品</strong>”，选择就是 “<strong>装进背包</strong>” 或 “<strong>不装进背包</strong>”。</p><ol start="2"><li>明确 dp 数组的含义</li></ol><p>按照背包问题的套路，可以给出如下的定义：</p><p><code>dp[i][j] = x</code> ，表死前<code>i</code>个物品，当前背包容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code> ，则说明可以恰好将背包装满，若为 <code>false</code>，则说明不能恰好将背包装满。</p><p>例如：<code>dp[4][9] = true</code> 表示取前四个数能能装满一个容量为 9 的背包。</p><p>对于本题来说，若只选择前四个数字，存在一个子集里面的和可以凑出来数字 9。</p><p>所以根据此定义，我们最终想求的答案就是 <code>dp[N][sum/2]</code>，<code>base case</code> 就是<code>dp[...][0] = true</code>和<code>dp[0][...]=false</code>,因为背包没空间的时候，相当于是装满了，而没有物品选择的时候，肯定没办法装满背包。 </p><ol start="3"><li>根据选择，去思考状态转移方程</li></ol><ul><li>如果不把<code>nums[i]</code> 放入背包，那么就有 <code>dp[i][j] = dp[i-1][j]</code>。</li><li>如果把 nums[i] 放入背包，就有 <code>dp[i][j] = dp[i-1][j-nums[i-1]]</code></li></ul><p>因为数组下标是从0开始的，所以上面第二个就是 <code>nums[i-1]</code></p><p><code>dp[i-1][j-nums[i-1]]</code>表示装了第 <code>i</code> 个物品，就要看背包的剩余重量 <code>j-nums[i-1]</code>限制下能否能够被装满。</p><p>最后一步直接写代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = arr.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next)</span><br><span class="line">  <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> dp = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;=len; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j&lt;=sum/<span class="number">2</span>; j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;=sum / <span class="number">2</span>;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j- nums[i<span class="number">-1</span>]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[len][sum/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p><strong>考虑到 <code>dp[i][j]</code> 都是通过 <code>dp[i-1][...]</code> 转移过来的</strong>，之前的数据都不会再使用了。</p><p>所以，可以进行一个状态压缩，将二维 dp 压缩成一维的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = arr.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next)</span><br><span class="line">  <span class="keyword">if</span> (sum &amp; <span class="number">1</span> || arr.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(sum + <span class="number">1</span>, <span class="literal">false</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = sum;j &gt;= <span class="number">0</span> ;j--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j &gt;= nums[i]) &#123;</span><br><span class="line">        dp[j] = dp[j] || dp[j - nums[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[sum]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是</strong> <strong><code>j</code></strong> <strong>应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果</strong>。</p><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>参考这个题目：<a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change-2/</a> 零钱兑换2号</p><p>转换成背包的描述形式：</p><p>有个最大容量为 <code>amount</code> 背包，有一系列物品 <code>conis</code> ，每个物品的重量为 <code>conis[i]</code> ，<strong>每个物品的数量是无限的</strong>。这里同<code>0,1</code>背包区别在于物品可以无限量的选择，状态转移方程式有一丢丢不同而已。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>确定状态和选择：</li></ol><p>状态还是分为背包容量和可选择的物品，选择就是是否装进背包。</p><p>明白了状态和选择，那么这个问题就基本上解决了，套框架即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值</span><br><span class="line"> <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值</span><br><span class="line">  <span class="keyword">for</span> ...</span><br><span class="line">    dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 计算(选择<span class="number">1</span>,选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><ol start="2"><li>明确 <code>dp</code> 数组的定义。</li></ol><p>这题的状态也是两个，使用前<code>i</code> 种物品，当背包容量为 <code>j</code> 时，有 <code>dp[i][j]</code> 种方法可以装满背包。</p><p><strong>那就是使用<code>coins</code> 数组的前 <code>i</code> 个硬币，想要凑出 <code>j</code> 金额，有 <code>dp[i][j]</code> 中凑法</strong>。</p><p>经过以上的定义，可以得到：</p><p><code>base case</code> 为 <code>dp[0][...] = 0, dp[...][0] = 1</code>。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为<code>0</code>，那么“无为而治”就是唯一的一种凑法。</p><p>那么我们最后要的结果就是 <code>dp[N][amount]</code>，其中 N 为 <code>conis</code> 数组的大小。</p><p>大致的代码思路为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][...] = <span class="number">0</span>;</span><br><span class="line">dp[...][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>..N]:</span><br><span class="line">  <span class="keyword">for</span> j in [<span class="number">1.</span>..amount]:</span><br><span class="line">    物品 i 放进背包,</span><br><span class="line">    物品 i 不放进背包</span><br><span class="line"><span class="keyword">return</span> dp[N][amount];</span><br></pre></td></tr></table></figure><ol start="3"><li>根据选择来确定状态转移的逻辑</li></ol><p>这个问题的特殊之处在于物品的数量是无限的，所以这里和之前的背包问题有一丢丢不同。</p><p>这里如果不把 <code>i</code> 物品装入背包，也就是说不使用 <code>coins[i]</code> 这个面值的硬币，凑出面额 <code>j</code> 的方法数<code>dp[i][j]</code>  应该为 <code>dp[i-1][j]</code></p><p>如果 <code>i</code> 物品装入了背包，也就是说使用了 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code>  应该等于 <code>dp[i][j-conis[i-1]]</code></p><p>这里的索引仍然是从1开头，所以上面是<code>conis[i-1]</code></p><p>综上两种选择，<strong>我们要求的 <code>dp[i][j]</code> 是 “共有多少种凑法”，所以 <code>dp[i][j]</code> 的值应该是以上两种选择的结果之和</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;=amount;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= coins[i<span class="number">-1</span>]) &#123;</span><br><span class="line">      dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j-conis[i<span class="number">-1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N][amount]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;dp技巧思路总结——背包&quot;&gt;&lt;a href=&quot;#dp技巧思路总结——背包&quot; class=&quot;headerlink&quot; title=&quot;dp技巧思路总结——背包&quot;&gt;&lt;/a&gt;dp技巧思路总结——背包&lt;/h2&gt;&lt;p&gt;0-1背包相关题目可以参考上一篇文章，这篇开始介绍一些其他的背包问题例如多重背包等。&lt;/p&gt;
&lt;h2 id=&quot;子集背包问题&quot;&gt;&lt;a href=&quot;#子集背包问题&quot; class=&quot;headerlink&quot; title=&quot;子集背包问题&quot;&gt;&lt;/a&gt;子集背包问题&lt;/h2&gt;&lt;p&gt;这题在0-1背包那边已经讲过了，这里重新讲一次：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equal-subset-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode 416题&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-浏览器中 js 执行机制(下)</title>
    <link href="http://zoomdong.site/2020/06/02/broswer-8/"/>
    <id>http://zoomdong.site/2020/06/02/broswer-8/</id>
    <published>2020-06-02T11:31:30.000Z</published>
    <updated>2020-06-02T16:44:19.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p><ul><li>全局作用域</li><li>函数作用域</li></ul><p>js之前支持上面两种作用域，因为作者设计该语言的时候只是用了最简单的方式。没有块级作用域，这就导致了变量提升这样神奇的设计。</p><h3 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h3><p>由于变量提升作用，使用 js 编写和其他语言相同逻辑的代码，都可能会导致不一样的执行结果。</p><h4 id="1-变量容易在不被察觉的情况下被覆盖"><a href="#1-变量容易在不被察觉的情况下被覆盖" class="headerlink" title="1. 变量容易在不被察觉的情况下被覆盖"></a>1. 变量容易在不被察觉的情况下被覆盖</h4><p>之前前面那篇文章有说到的调用栈执行上下文后声明的会覆盖掉前声明的。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602001927.png" alt="image-20200602001927127"></p><a id="more"></a><h4 id="2-本应销毁的变量没有被销毁"><a href="#2-本应销毁的变量没有被销毁" class="headerlink" title="2. 本应销毁的变量没有被销毁"></a>2. 本应销毁的变量没有被销毁</h4><p>例如这样一段神奇的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">9</span>;i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这个地方会因为变量提升的原因，在创建执行上下文阶段，变量 <code>i</code> 被提升了，所以 <code>for</code> 循环结束之后，变量 <code>i</code> 并没有被销毁。会打印出 <code>7</code>。</p><h3 id="ES6-是如何解决变量提升带来的缺陷"><a href="#ES6-是如何解决变量提升带来的缺陷" class="headerlink" title="ES6 是如何解决变量提升带来的缺陷"></a>ES6 是如何解决变量提升带来的缺陷</h3><p>引入了let,const，从而使得 js 像其他语言一样也有了块级作用域。</p><p>关于 <code>let</code> 和 <code>const</code> 的用法，可以参考下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">6</span></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">y = <span class="number">9</span></span><br></pre></td></tr></table></figure><p>下面具体讲一下 ES6 是如何通过块级作用域解决上面问题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，两个地方都定义了 <code>x</code>，第一个地方在函数块的顶部，第二个地方在 <code>if</code> 块的内部，由于 <code>var</code> 的作用范围是整个函数，所以编译阶段，会生成如下的执行上下文：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602003314.png" alt="image-20200602003314573"></p><p>从执行上下文的变量环境中可以看出，最终只生成了一个变量 <code>x</code> ，函数体内所有对 <code>x</code> 的赋值操作都会直接改变变量环境中的 <code>x</code> 值。</p><p>所以上述代码最后输出的结果是 <code>2</code>，而对于相同逻辑的代码，其他语言最后输出应该是1，因为 <code>if</code> 块里面声明不应该影响到块外面的变量。</p><p>改造过程其实很简单，把里面的 <code>var</code> 改成 <code>let</code>。输出结果就会一直了。</p><p>这是因为有了 let 关键字之后，就可以支持块级作用域了。所以在编译阶段，js 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。这种就非常符合我们的编程习惯了：作用域块内声明的变量不影响块外面的变量。</p><h3 id="js是如何支持块级作用域"><a href="#js是如何支持块级作用域" class="headerlink" title="js是如何支持块级作用域"></a>js是如何支持块级作用域</h3><p>前面已经介绍过 js 是通过变量环境实现函数级的作用域的，es6 又是如何在函数级作用域的基础上，实现对块级作用域的支持的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面这段代码作为例子，大概有这样的一些流程：</p><ol><li><p><strong>编译并创建执行上下文</strong></p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602092112.png" alt="image-20200602092112365"></p></li></ol><p>通过上图可以得知：</p><ul><li>函数内部通过 <code>var</code> 声明的变量，编译阶段全都被存到<strong>变量环境</strong>里面了。</li><li>通过 <code>let</code> 声明的变量，编译阶段会被放到<strong>词法环境</strong>中</li><li>函数作用域块内部，通过 <code>let</code> 声明的变量并没有被存到词法环境中</li></ul><ol start="2"><li>继续执行代码，这时变量环境中的 <code>a</code> 已经被设置了 1，词法环境中的 b 已经被设置成了 2，这时候函数的执行上下文就如图所示：</li></ol><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602092855.png" alt="image-20200602092855471"></p><p>从图中可以看出，当进入函数的作用域块时，作用域块中通过 <code>let</code> 声明的变量，会被存在放在一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面和内部同时声明了变量 <code>b</code>，当执行到作用域内部的时候，他们都是独立的存在。</p><p>在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块之后，就会把作用域块内部的变量压到栈顶，作用域执行完成之后，该作用域的信息就会从栈顶弹出来，这就是词法环境的结构。</p><p>再接下来，当执行到作用域块中的<code>console.log(a)</code>这行代码的时候，就需要在词法环境和变量环境中查找变量 a 的值了，查找方式为：沿着词法环境的栈顶向下查询，如果词法环境中的某个块查找到了，就直接返回给 js 引擎，如果没找到，就继续在变量环境中找。</p><p>这样一个变量查找就完成了，具体流程图如下：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602094648.png" alt="image-20200602094648840"></p><p>作用域块执行结束之后，内部定义的变量就会从词法环境的栈顶从弹出来，最终执行上下文如下图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602094822.png" alt="image-20200602094822065"></p><p>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p><p>分析一个思考题目的结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myname = <span class="string">'xyx'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myname);</span><br><span class="line">  <span class="keyword">let</span> myname = <span class="string">'wd'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印的结果为：<code>Reference Error</code>,原因是在块级作用域内，<code>let</code> 声明的变量被提升，但变量只是创建被提升，初始化没有被提升，在初始化之前使用变量，就会形成一个暂时性的死去。</p><h2 id="作用域链和闭包"><a href="#作用域链和闭包" class="headerlink" title="作用域链和闭包"></a>作用域链和闭包</h2><p>以下面代码为例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'wd'</span></span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'xyx'</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>通过执行上下文来分析一下这里的代码执行流程。当这段代码执行到 <code>bar</code> 函数内部的时候，其调用栈的状态为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602100114.png" alt="image-20200602100114079"></p><p>这里也许第一反应是按照调用栈的顺序去查找变量，最后执行出的打印结果会是 <code>wd</code>，实际上这里执行的结果是 <code>xyx</code>。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>很多人对作用域链理解会费解，实际上当你理解了调用栈、执行上下文、词法环境、变量环境等概念。</p><p>其实在每个执行上下文的变量环境中，包含有一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称之为 <strong>outer</strong>。</p><p>当一段代码使用一个变量，js 引擎会首先在 “当前的执行上下文” 中查找变量。</p><p>比如上面那段代码，当前的 bar 里面没有，那么 js 引擎会继续在 <strong>outer</strong> 所指向的执行上下文中查找。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602100755.png" alt="image-20200602100755124"></p><p>而 bar 和 foo 函数的 outer 都是指向全局执行上下文的，这就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 js 引擎会去全局执行上下文中查找。查找的链条就叫<strong>作用域链</strong>。</p><p>那么为啥是 <code>foo</code> 调用的 <code>bar</code> ，为啥 bar 的外部引用是全局执行上下文，而不是 foo 函数的执行上下文。于是这里就介绍一下<strong>词法作用域环境。</strong></p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符</strong>。</p><p>具体如图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602101938.png" alt="image-20200602101938370"></p><p>词法作用域是根据代码的位置来决定的。上面词法作用域的顺序为： <code>foo</code> -&gt; <code>bar</code> -&gt;<code>main</code> -&gt;全局</p><p>这时再回过头看当时的问题：根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以 foo 或 bar 函数使用了一个没定义的变量当然会先去全局作用域找。</p><p><strong>词法作用域是在代码阶段就决定好的，和函数怎么调用的没有任何关系。</strong> </p><h3 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h3><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">'wd'</span></span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> myName = <span class="string">'xyx'</span></span><br><span class="line">    <span class="built_in">console</span>.log(test)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">'wd1'</span></span><br><span class="line">  <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">'wd2'</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>ES6 是支持块级作用域的，当执行到代码块的时候，如果代码块中有 <code>let</code> 或 <code>const</code> 声明的变量，那么变量就会存放到该函数的词法环境中，上面那段代码执行到 bar 函数内部的 if 语句块的时候，其调用栈的情况为：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602104713.png" alt="image-20200602104713114"></p><p>现在是执行到 bar 函数的 if 语句块之内，需要打印出变量 test 的值，查找过程已经用序号标记出来了。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>结合下面代码来理解闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">'wd'</span></span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> test2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(test1)</span><br><span class="line">      <span class="keyword">return</span> myName</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span> (<span class="params">newName</span>) </span>&#123;</span><br><span class="line">      myName = newName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">'xyx'</span>)</span><br><span class="line">bar.getName();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure><p>当执行到 foo 函数内部的 <code>return innerBar</code> 这行代码时调用栈的情况，可以参考下图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602105512.png" alt="image-20200602105512644"></p><p>从上面代码中可以看出，<code>innerBar</code> 是一个对象，包含了 <code>getName</code> 和 <code>setName</code> 两个方法。这两个方法都是在 <code>foo</code> 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p><p><strong>根据词法作用域规则，内部函数 getName 和 setName 总是可以访问他们外部函数 foo 中的变量。</strong>所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但 getName 和 setName 函数仍然可以使用 foo 函数中的变量。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602110433.png" alt="image-20200602110433087"></p><p>foo 函数的整个调用栈状态如上图所示。</p><p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但由于返回的 setName 和 getName 方法使用了 foo 函数内部的变量 myName,test1，所以这两个变量依然保存在内存中。像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用这两个方法，他们都会背着这个 foo 函数的<strong>专属背包</strong>。</p><p>之所以是<strong>专属</strong>背包，因为除了 setName 和 getName 函数之外，其他任何方法都是无法访问该背包的，我们就可把这个背包称为 foo 函数的<strong>闭包</strong>。</p><p>好了，我们终于可以给闭包一个定义了。<strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</strong></p><p>当调用 setName 的时候，这个时候会修改掉闭包中的 myName 变量的值。</p><p>同样，调用 getName 的时候，返回的值也是位于闭包中的值。</p><p>可以通过开发者工具来查看闭包的情况，打开 Chrome 开发者工具，在 bar 函数的任意地方打上断点，然后刷新页面，可以看到如下的内容：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602112232.png" alt="image-20200602112232043"></p><p>Local 是当前函数 getName 的作用域，Closure(foo) 是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从 “Local -&gt; Closure(foo) -&gt; Global”就是一个完整的作用域链。</p><h3 id="闭包是怎么回收的"><a href="#闭包是怎么回收的" class="headerlink" title="闭包是怎么回收的"></a>闭包是怎么回收的</h3><p>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p><p><strong>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</strong></p><p>思考:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  myName: <span class="string">'yisin'</span>,</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> myName = <span class="string">'zoodmong'</span></span><br><span class="line">  <span class="keyword">return</span> bar.printName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">'wd'</span>;</span><br><span class="line"><span class="keyword">let</span> _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName();</span><br></pre></td></tr></table></figure><p>上面两次都会打印出 <code>wd</code>，因为：</p><ol><li><p><code>bar</code> 不是一个函数，因此 <code>bar</code> 当中的 <code>printName</code> 其实是一个全局声明的函数，bar 当中的 myName 只是对象的一个属性，也和 printName 没有联系，如果要产生联系，需要使用 this 关键字，表示这里的 myName 是对象的一个属性，不然的话，printName 会通过词法作用域链去到其声明的环境，也就是全局，去找 myName。</p></li><li><p>foo 函数返回的 printName 是全局声明的函数，因此和 foo 当中定义的变量也没有任何联系，这个时候 foo 函数返回 printName 并不会产生闭包。</p></li></ol><h2 id="js-中的-this-是什么"><a href="#js-中的-this-是什么" class="headerlink" title="js 中的 this 是什么"></a>js 中的 this 是什么</h2><p>关于 <code>this</code>,还是先从执行上下文开始说起。前面提到过执行上下文中包含有变量环境、词法环境、外部环境。里面其实还有个 this，具体可以参考：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602115141.png" alt="image-20200602115141291"></p><p>每个执行上下文中都有一个 this。前面提过，有三种执行上下文——全局、函数、eval 执行上下文。所以 this 也存在于这三种情况中。</p><p>下面重点讲解一下<strong>全局执行上下文中的 this</strong> 和 <strong>函数执行上下文中的 this</strong>。</p><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>见下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在 foo 函数内部打印出来的其实还是window对象，不过这里可以通过一些方法来修改这个 this 指向。</p><h4 id="1-call方法设置"><a href="#1-call方法设置" class="headerlink" title="1. call方法设置"></a>1. call方法设置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  name: <span class="string">'wd'</span>,</span><br><span class="line">  school: <span class="string">'neuq'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'yisin'</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)</span><br><span class="line"><span class="comment">// 这是输出会发现bar里面的name已经成了yisin</span></span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="comment">// 这里会提示该变量没有定义</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure><p>除了 call 方法，还可以用用 apply 和 bind 方法。</p><h4 id="2-通过对象调用方法设置"><a href="#2-通过对象调用方法设置" class="headerlink" title="2. 通过对象调用方法设置"></a>2. 通过对象调用方法设置</h4><p>修改函数上下文的 <code>this</code>  指向，除了通过函数的 <code>call</code> 方法来实现外，还可以通过对对象调用的方式，比如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'geektime'</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.showThis()</span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个 <code>obj</code> 对象，对象由一个 <code>name</code> 属性和一个 <code>showThis</code> 方法组成，然后再通过 <code>obj</code> 对象来调用 <code>showThis</code> 方法。执行这段代码，最终输出的 <code>this</code> 值是指向 <code>obj</code> 的。</p><p>因此我们可以得出这样的结论：<strong>使用对象来调用内部的一个方法，该方法的 this 是指向对象本身的。</strong></p><p>js 引擎在执行 <code>obj.showThis()</code> 的时候，将其转换为了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.showThis.call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>接下来稍微改变一下调用方式，把 <code>showThis</code> 赋值一个全局对象，然后再调用这个对象，代码如下图：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zoomdong'</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'yisin'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = obj.showThis</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这段代码执行的时候，<code>this</code> 的指向就到了全局的 window 对象。</p><p>通过以上例子，可以得到这样两个结论：</p><ul><li><strong>在全局环境中调用一个函数，函数内部的 <code>this</code> 指向的是全局变量 <code>window</code>。</strong></li><li><strong>通过一个对象来调用内部的一个方法，方法的执行上下文中的 <code>this</code> 指向对象本身。</strong></li></ul><h4 id="3-通过构造函数中设置"><a href="#3-通过构造函数中设置" class="headerlink" title="3. 通过构造函数中设置"></a>3. 通过构造函数中设置</h4><p>可以像这样设置构造函数中的 <code>this</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'zoomdong'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> createObj();</span><br></pre></td></tr></table></figure><p>在这段代码中，我们使用了 <code>new</code> 创建了对象 <code>obj</code>，那么你知道这时候构造函数中的 <code>this</code> 指向了谁吗？</p><p>在执行 <code>new createObj()</code> 的时候，js 引擎做了如下四件事情：</p><ul><li>创建了一个空对象 tempObj</li><li>调用 createObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 createObj 的执行上下文创建的时候，它的 this 指向了 tempObj 对象。</li><li>然后执行 createObj 函数，此时 createObj 函数执行上下文中的 this 指向了 tempObj 对象;</li><li>最后返回 tempObj 对象</li></ul><p>为了直观理解，可以使用代码来演示一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">createObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure><p>这样，我们就通过 new 关键字创建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p><p>具体过程参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new</a></p><h3 id="this-函数中设计的一些缺陷"><a href="#this-函数中设计的一些缺陷" class="headerlink" title="this 函数中设计的一些缺陷"></a>this 函数中设计的一些缺陷</h3><h4 id="1-嵌套函数中的-this-不会从外层中继承"><a href="#1-嵌套函数中的-this-不会从外层中继承" class="headerlink" title="1. 嵌套函数中的 this 不会从外层中继承"></a>1. 嵌套函数中的 this 不会从外层中继承</h4><p>这是个挺严重的设计错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'yisin'</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.showThis()</span><br></pre></td></tr></table></figure><p>这段代码中 <code>showThis</code> 方法里面添加了一个 bar 方法，然后接着在 <code>showThis</code> 函数中调用了 <code>bar</code>  函数，执行这段代码的结果你会发现：<strong>函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 obj 对象。</strong></p><p>这里可以使用一个中间变量 <code>that</code> 来解决这个过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'yisin'</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.name = <span class="string">'zoomdong'</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(self)</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure><p>这样就可以输出到我们想要的结果了。其实这里 obj.name 的值就为 <code>zoomdong</code>。这个方法的本质其实就是把 <strong>this 体系转换为了作用域体系。</strong></p><p>也可以使用箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'yisin'</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">'zoomdong'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure><p>执行这段代码，你会发现它也输出了我们想要的结果，也就是箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p><h4 id="2-普通函数中的-this-默认指向全局对象-window"><a href="#2-普通函数中的-this-默认指向全局对象-window" class="headerlink" title="2.普通函数中的 this 默认指向全局对象 window"></a>2.普通函数中的 this 默认指向全局对象 window</h4><p>在默认情况下调用一个函数，其执行上下文中的 <code>this</code> 是默认指向全局对象 <code>window</code> 的。</p><p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 <code>this</code> 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的<code>this</code> 指向某个对象，最好的方式是通过 <code>call</code> 方法来显示调用。</p><p>这个问题可以通过设置 <code>JavaScript</code> 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 <code>this</code> 值是 <code>undefined</code>，这就解决上面的问题了。总结</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>当函数作为对象的方法调用时，函数中的 this 就是该对象</li><li>当函数被正常调用时，在严格模式下，<code>this</code> 值是 <code>undefined</code>，非严格模式下 <code>this</code> 指向的是全局对象 <code>window</code></li><li>嵌套函数中的 <code>this</code> 不会继承外层函数的 <code>this</code> 值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;作用域指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局作用域&lt;/li&gt;
&lt;li&gt;函数作用域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;js之前支持上面两种作用域，因为作者设计该语言的时候只是用了最简单的方式。没有块级作用域，这就导致了变量提升这样神奇的设计。&lt;/p&gt;
&lt;h3 id=&quot;变量提升所带来的问题&quot;&gt;&lt;a href=&quot;#变量提升所带来的问题&quot; class=&quot;headerlink&quot; title=&quot;变量提升所带来的问题&quot;&gt;&lt;/a&gt;变量提升所带来的问题&lt;/h3&gt;&lt;p&gt;由于变量提升作用，使用 js 编写和其他语言相同逻辑的代码，都可能会导致不一样的执行结果。&lt;/p&gt;
&lt;h4 id=&quot;1-变量容易在不被察觉的情况下被覆盖&quot;&gt;&lt;a href=&quot;#1-变量容易在不被察觉的情况下被覆盖&quot; class=&quot;headerlink&quot; title=&quot;1. 变量容易在不被察觉的情况下被覆盖&quot;&gt;&lt;/a&gt;1. 变量容易在不被察觉的情况下被覆盖&lt;/h4&gt;&lt;p&gt;之前前面那篇文章有说到的调用栈执行上下文后声明的会覆盖掉前声明的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200602001927.png&quot; alt=&quot;image-20200602001927127&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dp构造思路：一些经典题目解法</title>
    <link href="http://zoomdong.site/2020/06/01/dp-2/"/>
    <id>http://zoomdong.site/2020/06/01/dp-2/</id>
    <published>2020-06-01T06:56:42.000Z</published>
    <updated>2020-06-01T07:24:05.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>dp 的难点在于寻找正确的状态转移方程，这里以 <strong>最长递归子序列问题</strong> 来讲讲 dp 的通用技巧：<strong>数学归纳思想</strong>。</p><p>题目 RT:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529181044.png" alt="image-20200529181044741"></p><p>这里子序列可以是不连续的序列。下面通过设计 dp 来解决问题。</p><a id="more"></a><h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><p>dp 的核心思路是数学归纳法。</p><p>这里我们可以这样定义：<strong><code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。</strong></p><p>根据这个定义，我们就可以推出 base case：<code>dp[i]</code> 初始值为 1，因此以 <code>nums[i]</code> 结尾的最长递增子序列起码要包含他自己。</p><p>例如：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529181902.png" alt="image-20200529181902383"></p><p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br></pre></td></tr></table></figure><p>那么怎么推算 dp 数组中的每个值，就是我们这里的重点内容了，这里就可以使用数学归纳法了：</p><p>假设我们已经知道了 <code>dp[0...4]</code> 的所有结果，我们如何根据这些结果来推出 <code>dp[5]</code> 呢？</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529182358.png" alt="image-20200529182358120"></p><p>根据之前对 dp 数组的值的定义：<code>nums[5]</code> 值为 3，<strong>既然是递增子序列，我们只需要找前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</strong></p><p>显然，可以形成很多种新的子序列，但这里只选择最长的那一个，把最长子序列的长度当作 <code>dp[5]</code> 的值即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j + <span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们已经可以算出 dp[5]了，其他情况依此类推即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以 base case 作为例子，看一下完整的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>(nums.length).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这样这道题就搞定了，总结下dp状态转移关系：</p><ol><li>明确 <code>dp</code> 数组所存数据的含义。</li><li>根据 <code>dp</code> 数组的含义，运用数学归纳法，假设 <code>dp[0...i-1]</code> 都已知，想办法求出 <code>dp[i]</code>，一旦这一步完成，这题就 ac 了。</li></ol><h2 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h2><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529184953.png" alt="image-20200529184953233"></p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>解这个题目需要dp技巧，但 dp 数组定义比较特殊。按照常规的 dp 思路，一般是这样定义 dp 数组：</p><p><strong><code>nums[0...i]</code> 中的 “最大子数组和” 为 dp[i]</strong></p><p>如果这样定义，整个 <code>nums</code> 数组的“最大子数组和”就是<code>dp[n-1]</code>。那么这样要如何找到状态转移方程式呢？按照数学归纳法，假设我们知道了 <code>dp[i-1]</code>，如何往 <code>dp[i]</code> 推？</p><p>如下图，按照我们对 <code>dp</code> 数组的定义，<code>dp[i] = 5</code>，也就是等于 <code>nums[0...i]</code> 中的最大子数组和：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529194733.png" alt="image-20200529194733844"></p><p>在上图这种情况中，利用数学归纳法是不能从 <code>dp[i]</code> 推出 <code>dp[i+1]</code> 的。</p><p><strong>因为子数组一定是连续的，按照我们当前 <code>dp</code> 数组定义，并不能保证 <code>nums[0...i]</code> 中的最大子数组于 <code>nums[i+1]</code> 是相邻的</strong>，也就是没有办法从 <code>dp[i]</code> 中推出 <code>dp[i+1]</code> 的。</p><p>所以我们需要重新定义 <code>dp</code> 数组的含义：</p><p><strong>以 <code>nums[i]</code> 为结尾的“最大子数组和”为<code>dp[i]</code></strong>。</p><p>这种定义之下，想得到整个 <code>nums</code> 数组的“最大子数组和”，不能直接返回 <code>dp[n-1]</code>而是返回dp数组中的最大值。</p><p>根据数学归纳法，如果我们已经推出了 <code>dp[i-1]</code>，那么该如何推出 <code>dp[i]</code> 呢？</p><p>可以做到，<code>dp[i]</code>有两种选择，和前面相邻的子数组连接，形成一个更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。</p><p>既然要选择子数组最大的和，当然要选择最大的子数组了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">Math</span>.max(nums[i], dp[i<span class="number">-1</span>] + nums[i])</span><br></pre></td></tr></table></figure><p>所以正确的解法就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;len;i++) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(nums[i], dp[i<span class="number">-1</span>] + nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>这里介绍一下一些常见的背包问题，以最常见的0-1背包问题作为例子：</p><p>给你一个装载重量为 <code>W</code> 的背包和 <code>N</code>个物品，每个物品有质量和属性两个属性。其中第 <code>i</code>  个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在用这个背包装物品，最多能装的价值是多少？</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200530145726.png" alt="image-20200530145726517"></p><p>举个简单例子，输入例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span>, W = <span class="number">4</span>;</span><br><span class="line">wt = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">val = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>算法结果返回了<code>6</code>，选择前面两件物品装进背包，总质量3小于 <code>W</code>，可以获得的最大价值为6。</p><p>题目就是这么简单，一个典型的 dp 问题。这个问题中的物品不可以被分割，要么装进背包，要么不装，不能说切成两块装一半。这就是<code>0-1</code>背包名词的来历。</p><h3 id="dp-套路"><a href="#dp-套路" class="headerlink" title="dp 套路"></a>dp 套路</h3><p>第一步首先要明确两点，<strong>状态和选择</strong>。</p><p>先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题。所以状态有两个，就是<strong>背包的容量</strong>和<strong>可选择的物品</strong>。</p><p>再说选择，对于每件物品，能选择的就是<strong>装进背包</strong>或者<strong>不装进背包</strong>。</p><p>明白了状态和选择，动态规划问题就基本上解决了，只需要往这个框架里面套就完事了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值:</span><br><span class="line">  <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值:</span><br><span class="line">    <span class="keyword">for</span> ...</span><br><span class="line">      dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>,选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p><strong>第二步，要明确 <code>dp</code> 数组的定义。</strong></p><p>首先看到刚才找到的“状态”有两个，也就是我们说的需要一个二维 <code>dp</code> 数组。</p><p><code>dp[i][w]</code> 的定义如下：对于前 <code>i</code> 个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是 <code>dp[i][w]</code>。</p><p>例如：如果<code>dp[3][5] = 6</code>,其含义为：对于给定的一系列物品中，若只对前3个物品进行选择，当背包容量为5时，最多可以装下的价值为6。</p><p>为什么这样定义？便于状态转移，或者说这就是套路。</p><p>根据这个定义，我们想知道的答案就是 <code>dp[N][W]</code>。<code>base case</code>就是 <code>dp[0][...] = dp[...][0] = 0</code>，因为没有物品或者背包空闲的时候，能装的最大价值就是 0。</p><p>细化上面的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][...] = <span class="number">0</span></span><br><span class="line">dp[...][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>..N]:</span><br><span class="line">  <span class="keyword">for</span> w <span class="keyword">in</span> [<span class="number">1.</span>..W]:</span><br><span class="line">    dp[i][w] = max(装i物品，不装i物品 )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure><p><strong>第三步，根据“选择”来思考状态转移的逻辑：</strong></p><p>简单而言，上面伪代码中“装i物品”和“不装i物品”怎么用代码体现出来呢？</p><p>这就要结合 <code>dp</code> 数组的定义和我们的算法逻辑来分析了：</p><p><code>dp[i][w]</code>表示：对于前 <code>i</code>  个物品，当前背包容量为 <code>w</code>时，这种情况下可以装下的最大的价值是 <code>dp[i][w]</code>。</p><p>如果没有把第 <code>i</code> 个物品装入背包，那么显然，最大价值 <code>dp[i][w]</code>  应该等于 <code>dp[i-1][w]</code> ，继承之前的结果。</p><p>如果把这第 <code>i</code>  个物品装入了背包，那么 <code>dp[i][w]</code>应该等于 <code>dp[i-1][w-wt[i-1]] + val[i-1]</code>。</p><p>首先，由于 <code>i</code> 是从1开始的，所以 <code>val</code> 和 <code>wt</code> 的索引是 <code>i-1</code> 时表示第 <code>i</code> 个物品的价值和重量。</p><p>而 <code>dp[i-1][w-wt[i-1]]</code>也很好理解：如果你装了第 <code>i</code> 个物品，就要寻求剩余质量 <code>w-wt[i-1]</code> 限制下的最大价值，加上第 <code>i</code> 个物品的价值 <code>val[i-1]</code>。</p><p>综上两种选择，我们已经分析完毕了，也就是写出了状态转移方程式，可以进一步细化代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>..N]:</span><br><span class="line">  <span class="keyword">for</span> w <span class="keyword">in</span> [<span class="number">1.</span>..W]:</span><br><span class="line">    dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure><p><strong>最后一步把伪代码翻译成代码，处理一些边界情况。</strong></p><p>且处理一下<code>w-wt[i-1]</code>会使得索引小于 <code>0</code> 的情况。</p><p>代码如下图所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">W, N, wt, val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;=W;j++) &#123;</span><br><span class="line">      <span class="comment">// 这种情况只能不放入背包</span></span><br><span class="line">      <span class="keyword">if</span>(j-wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 装入或者不装入，择优选择</span></span><br><span class="line">        dp[i][w] = max(dp[i<span class="number">-1</span>][j-wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode 0-1 背包的问题可以选择 <code>416</code>，<code>474</code>，<code>1049</code> 来练习一波。</p><h3 id="lc416-分割等和子集"><a href="#lc416-分割等和子集" class="headerlink" title="lc416  分割等和子集"></a>lc416 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener"> 分割等和子集</a></h3><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200530172114.png" alt="image-20200530172114845"></p><p>这个题目和传统的 <code>0-1</code> 背包并不是很像，即：</p><ul><li>0-1背包问题选取物品的容积总量不能超过规定的容量</li><li>本题选取的数字之和需要恰好等于规定和的一半</li></ul><p>因此这题的 base 应该这样去设置:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">0</span>][<span class="symbol">nums[0</span>]] = true;</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">0</span>] = true</span><br></pre></td></tr></table></figure><p>先找一下状态，状态首先有元素的数目，以及这些对应元素里面是否有值能够去填补相对应的和。</p><p>于是可以这样来设置一个状态：</p><p><code>dp[i][j]</code> 表示 0~i 个元素里面是否存在和为 j 的子集:</p><p>选择是这样的:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 选择 in 初始数组</span><br><span class="line">  for 元素 in 和的一半</span><br><span class="line">    dp<span class="comment">[选择区间元素]</span><span class="comment">[元素]</span> = dp<span class="comment">[选择区间元素-1]</span><span class="comment">[元素]</span> || dp<span class="comment">[选择区间元素-1]</span><span class="comment">[元素 - 选择]</span></span><br></pre></td></tr></table></figure><p>那么这次的核心dp代码就是这样的了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一下边界</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;=sum / <span class="number">2</span>;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">      dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j-nums[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][sum / <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h3><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601125804.png" alt="image-20200601125804588"></p><p>这题和 0-1 背包有点不一样的区别在于 0-1 背包板子里面是只有一个背包容量的，但是这种情况下是可以需要2个背包的，一个用来存取0的数目，一个用来存1的数目， 因此这里我们开需要开两个背包容量来去计算:</p><p><code>dp[k][i][j]</code> 该状态的意思指的是在子区间 <code>0 ~ k</code>  中使用 i 个 0 和 j 个 1 能得到的最多字符串的数目。</p><p>状态转移方程式为:</p><p><code>dp[k][i][j] = Math.max(dp[k-1][i][j], dp[k-1][i-当前字符串0的数目][j-当前字符串1的数目])</code></p><p>因此核心代码可以这样来推：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">strs, m, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化的全初始化为0</span></span><br><span class="line">  <span class="keyword">let</span> dp[strs.length][m][n] = &#123;<span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> strs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        dp[index][i][j] = dp[index<span class="number">-1</span>][i][j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= countZero(str) &amp;&amp; j &gt;= countOne(str)) &#123;</span><br><span class="line">          <span class="comment">// 这里也是和0,1背包的两种选择，放或者不放当前的字符串</span></span><br><span class="line">          dp[index][i][j] = <span class="built_in">Math</span>.max(dp[index<span class="number">-1</span>][i][j], dp[index<span class="number">-1</span>][i-countZero(str)][j-countOne(str)])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[strs.length][m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长递增子序列&quot;&gt;&lt;a href=&quot;#最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;最长递增子序列&quot;&gt;&lt;/a&gt;最长递增子序列&lt;/h2&gt;&lt;p&gt;dp 的难点在于寻找正确的状态转移方程，这里以 &lt;strong&gt;最长递归子序列问题&lt;/strong&gt; 来讲讲 dp 的通用技巧：&lt;strong&gt;数学归纳思想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;题目 RT:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529181044.png&quot; alt=&quot;image-20200529181044741&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里子序列可以是不连续的序列。下面通过设计 dp 来解决问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-浏览器中 js 执行机制(上)</title>
    <link href="http://zoomdong.site/2020/06/01/broswer-7/"/>
    <id>http://zoomdong.site/2020/06/01/broswer-7/</id>
    <published>2020-05-31T16:54:52.000Z</published>
    <updated>2020-05-31T16:56:28.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>指在 js 代码执行过程中，js 引擎把变量声明部分和函数的声明部分提到代码开头的“行为”。变量被提升之后，会被设置默认值 undefined。</p><h2 id="js-代码执行流程"><a href="#js-代码执行流程" class="headerlink" title="js 代码执行流程"></a>js 代码执行流程</h2><p><strong>实际上变量提升这一过程中，变量和函数声明在代码中的位置不会被改变，而是在编译阶段被 js 引擎放入内存之中。</strong>一段 js 代码在执行之前需要被 js 引擎编译，编译完成之后，才会进入执行阶段。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200531230502.png" alt="image-20200531230502237"></p><a id="more"></a><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1.编译阶段"></a>1.编译阶段</h3><p><strong>这一过程输入一段 js 代码在经过编译之后会被分成两部分内容：执行上下文 和 可执行代码。</strong></p><p>执行上下文是 js 执行一段代码时的运行环境，调用一段函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 <code>this</code>、变量、对象以及函数。</p><p>执行上下文具体细节后面会介绍，现在只需知道，执行上下文中存在一个<strong>变量环境的对象</strong>，该对象中保存了变量提升的内容。</p><p>下面代码为例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showA()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function start'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前面两行没有声明语句，因此 js 引擎不会做任何处理</li><li>第 3 行，由于这行经过 var 声明，因此 js 引擎会在环境对象中创建一个名为 a 的属性，并使用 undefined 来初始化</li><li>第 4 行，js 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆(HEAP) 中，并在环境对象中创建一个 showA 属性，然后将该属性指向堆中函数位置。</li></ul><p>这样就生成了变量环境对象。接下来 <strong>js 引擎就会把声明以外的代码全部编译成字节码</strong>。</p><h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>js 引擎开始执行“可执行代码”，按照顺序一行行执行。</p><ul><li>执行到 showA 函数，js 引擎开始在变量环境对象中查找这个函数，变量环境对象中存在该函数的引用，所以 js 引擎便开始执行这个函数，并输出其结果</li><li>然后打印 a 内容，js 引擎继续在变量环境对象中找该对象，由于变量里面有 a 变量，并且其值为 undefined，所以就输出这个</li><li>然后执行 第三行，把 123 的值赋值给 a 变量，赋值之后变量环境中的 a 属性值变为 ‘123’ </li></ul><p>此时的变量环境为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableEnviroment:</span><br><span class="line">  a -&gt; <span class="string">'123'</span>,</span><br><span class="line">  showA -&gt; <span class="keyword">function</span> : &#123; console.log(<span class="string">'function start'</span>) &#125;</span><br></pre></td></tr></table></figure><p>那么以上就是一段代码的编译和执行过程了。实际上，这个过程是很复杂的，包括了词法分析 -&gt; 语法解析-&gt;代码优化 -&gt; 代码生成等。</p><p>如果在代码中出现同名的变量或者函数，会在编译阶段被最终的所覆盖掉。</p><h2 id="调用栈：为什么-js-代码会出现栈溢出"><a href="#调用栈：为什么-js-代码会出现栈溢出" class="headerlink" title="调用栈：为什么 js 代码会出现栈溢出"></a>调用栈：为什么 js 代码会出现栈溢出</h2><p>一般这样一些代码会在执行之前就被编译并创建执行上下文：</p><ul><li>js 执行全局代码时，编译全局代码并创建全局执行上下文，而且整个页面的生存周期之内，全局执行上下文只有一份</li><li>调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束后会被销毁</li><li>使用 eval 函数的时候，代码会被编译并创建执行上下文</li></ul><p>调用栈是用来管理函数调用关系的一种数据结构</p><h3 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h3><p>函数调用是运行一个函数。例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure><p>这段代码很简单，先创建一个 <code>add</code> 函数，接着在代码的最下面又调用了该函数。</p><p>下面利用这段简单的代码来解释函数调用的过程。</p><p>在执行到函数 <code>add()</code> 之前，js引擎为为其创建全局执行上下文，包含了声明的函数和变量，如图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200531234226.png" alt="image-20200531234226222"></p><p>代码中全局变量和函数都保存在全局上下文的变量环境中。</p><p>执行上下文准备好之后，便开始执行全局代码，执行到 add 这里的时候，js 判断这是个函数调用，会执行以下操作：</p><ul><li>从全局执行上下文中，取出 add 函数代码</li><li>对 add 函数进行编译，并<strong>创建该函数的执行上下文</strong>和<strong>可执行代码</strong>。</li><li>执行代码，输出结果</li></ul><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200531235232.png" alt="image-20200531235232379"></p><p>执行到 add 函数的时候，我们会有两个执行上下文——全局执行上下文和 add 函数执行上下文。</p><p>js会使用栈来管理这些执行上下文。</p><h3 id="js-调用栈"><a href="#js-调用栈" class="headerlink" title="js 调用栈"></a>js 调用栈</h3><p>js 引擎利用栈来管理执行上下文。在创建好上下文之后， js 引擎会把执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为<strong>执行上下文栈</strong>，又称<strong>调用栈</strong>。</p><p>以下面一段代码作为例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span> (<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">10</span>;</span><br><span class="line">  result = add(b, c)</span><br><span class="line">  <span class="keyword">return</span> a + result + d</span><br><span class="line">&#125;</span><br><span class="line">addAll(<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><ol><li><p>第一步创建全局上下文，并将其压入栈底。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601000520.png" alt="image-20200601000520600"></p></li></ol><p>变量 a, 函数 add 和 addAll 都保存到了全局上下文的变量环境对象中了。</p><p>全局执行上下文压入到调用栈后，js 引擎就开始执行全局代码了。首先会执行 a = 2 的赋值操作，执行该语句会将上下文变量环境中 a 的值设置为 2。设置后的全局上下文状态为：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601002451.png" alt="image-20200601002451275"></p><p>第二步是<strong>调用 addAll 函数</strong>。调用此函数的时候，js 引擎会编译该函数，并为其创建一个上下文，最后还将该函数的执行上下文压入栈中，如下图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601003203.png" alt="image-20200601003203316"></p><p>先创建该函数的执行上下文，创建好之后，进入函数代码的执行阶段，先执行 d = 10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成 10。</p><p>第三步执行到 add 函数同样会创建其的执行上下文环境，并将其压入栈。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601003507.png" alt="image-20200601003507754"></p><p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601003617.png" alt="image-20200601003617312"></p><p>紧接着 addAll 执行最后一个相加操作后并返回， addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601003805.png" alt="image-20200601003805613"></p><p>至此，整个 js 流程就执行结束了。</p><p><strong>调用栈是 js 引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能追踪到哪个函数正在被执行以及各个函数之间的调用关系。</p><h3 id="开发中使用调用栈"><a href="#开发中使用调用栈" class="headerlink" title="开发中使用调用栈"></a>开发中使用调用栈</h3><ol><li>浏览器查看调用栈信息</li></ol><p>在第三行处打上断点，然后刷新页面。会发现执行到 add 的时候，执行流程就暂停了，这时可以通过右边的 call stack 来查看当前的调用栈情况。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200601004243.png" alt="image-20200601004243038"></p><p>在 <code>Call Stack</code> 那里可以清晰看到函数之间的调用关系。这在分析代码结构以及找 bug 时是非常关键的。</p><p>除了打断点，还可以通过 <code>console.trace()</code> 来查看函数之间的调用关系。</p><ol start="2"><li>栈溢出</li></ol><p>当我写一个没有边界条件的递归函数时:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add (a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>这时候 js 引擎执行这一段代码的时候，首先会调用函数 division，并创建执行上下文，压入栈中；然后这个函数时递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但是栈容量时有限的，所以就会出现栈溢出的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h2&gt;&lt;p&gt;指在 js 代码执行过程中，js 引擎把变量声明部分和函数的声明部分提到代码开头的“行为”。变量被提升之后，会被设置默认值 undefined。&lt;/p&gt;
&lt;h2 id=&quot;js-代码执行流程&quot;&gt;&lt;a href=&quot;#js-代码执行流程&quot; class=&quot;headerlink&quot; title=&quot;js 代码执行流程&quot;&gt;&lt;/a&gt;js 代码执行流程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实际上变量提升这一过程中，变量和函数声明在代码中的位置不会被改变，而是在编译阶段被 js 引擎放入内存之中。&lt;/strong&gt;一段 js 代码在执行之前需要被 js 引擎编译，编译完成之后，才会进入执行阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200531230502.png&quot; alt=&quot;image-20200531230502237&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Node.js,来一打 Cpp 拓展》学习笔记- Chrome V8 基础-上</title>
    <link href="http://zoomdong.site/2020/05/30/cpp-node-3/"/>
    <id>http://zoomdong.site/2020/05/30/cpp-node-3/</id>
    <published>2020-05-30T06:43:07.000Z</published>
    <updated>2020-05-30T06:44:05.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chrome-V8-基础-上"><a href="#Chrome-V8-基础-上" class="headerlink" title="Chrome V8 基础-上"></a>Chrome V8 基础-上</h2><h3 id="Node-js-与-Chrome-V8"><a href="#Node-js-与-Chrome-V8" class="headerlink" title="Node.js 与 Chrome V8"></a>Node.js 与 Chrome V8</h3><p>Node.js 的 JavaScript 运行时引擎是 Chrome V8，那么它们是以何种形式链接起来的呢？</p><ul><li>2006 年，V8 开始投入研发</li><li>2008年9月，V8 发布了第一个版本，并且 Chrome 浏览器也几乎同期发布，至此 js 还是运行在浏览器中的一门脚本语言</li><li>2009年， ry 开发了 Node.js</li></ul><p>之后 js 就被带入后端领域，V8 也不仅仅只是 Chrome 的一个支持引擎。</p><p>与 Chrome 差不多，node 为 v8 提供了一个宿主，只不过前者的宿主中包含的是类似于 HTML DOM、<code>window</code> 对象等内容；<strong>而后者则提供了一整个沙箱 <code>vm</code>机制，以及文件系统、网络操作等内容。</strong></p><p>也就是说，Node.js 实际上就是 Chrome V8 引擎的一个宿主。如果你有兴趣，也完全可以用 Chrome V8 创造一个别的 <code>.js</code> ，比如 <code>Mode.js</code> 、 <code>Lode.js</code>等。</p><p>因此，我们并不需要对 Chrome V8 有一个特别深入的了解，也不需要知道它的算法、原理等。我们只用关心它暴露出来的一些 api，以及使用这些 api 所必要的储备知识。</p><p>有了这些 api，我们就能让自己的 C++ 扩展与 Node.js 进行互通了 —— 因为 Node.js 底层很大程度上也是直接使用了 Chrome V8 所暴露出来的 api。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h4><p>Chrome V8 中，内存机制是很重要的，其中就包括了它在内的各种概念。v8 高效的一个重要原因就是因为它的内存机制。</p><p><code>Chrome V8</code> 中 js 的数据类型都是由 v8 内部的内存机制进行管理的。</p><p><code>Node.js</code> 实际上就是一个使用 C++ 完成的程序，其能执行 js 代码，它的底层主要由两部分第三方库组成——Chrome V8 和 libuv:</p><ul><li>Chrome V8 是 js 运行时，用于解释执行 js</li><li>libuv 实现了 node 中大家老生常谈的 “事件循环”。</li></ul><p>其中 v8 是一个由 C++ 完成的库，用于执行 js。也就是说如果你在自己的 js 代码中声明了一个变量，那么这个变量会被 v8 中的内存机制进行管理。</p><p>Chrome v8 创建的 cpp 数据类型能被我们编写的 cpp 代码(如cpp扩展)所访问，并且其与 js 中操作的是在内存中相同的存储单元。也就是说你在 js 中声明了一个 <code>let a = 1;</code>，那么相应作用域下，cpp代码能对其进行操作。</p><p>v8 创建的数据存储单元只能被它的内存回收机制所回收，而不能被我们自己所管理（不能被 <code>delete</code>或者 <code>free</code>）。回收的前提是——这个js变量在js代码中已经不被引用了，且在 cpp 代码中也不再被引用。</p><blockquote><p>浮点数在 cpp 中通常是 float 或者 double;而在 v8 中则是 v8::Number,这也是个对象</p></blockquote><p> 作为一个 Node.js 开发者，大家可能对于老生代内存，新生代内存等耳熟能详。实际上 Chrome V8 中的堆内存却不止这两部分。</p><ul><li><strong>新生态内存区</strong>：分配基础的数据对象，小而频。区域小但是垃圾回收频繁。</li><li><strong>老生代指针区</strong>：一堆指向老生代内存区具体数据内容的指针。新生代蜕变过来的对象会移动至此。</li><li><strong>老生代数据区</strong>：存放数据对象，而不是指向其他对象的指针。老生代指针区的指针就指向这里。</li><li><strong>大对象区</strong>：存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收并不会移动大对象。</li><li><strong>代码区</strong>：代码对象，也就是包含 JIT 之后指令的对象会分配到这里。唯一有执行权限的区域。</li><li><strong>Cell 区、属性区、Map区</strong>：存放 Cell、属性 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单</li></ul><h4 id="1-新生代内存"><a href="#1-新生代内存" class="headerlink" title="1.新生代内存"></a>1.新生代内存</h4><p>使用 <code>Scavenge</code> 算法进行回收：将内存一分为二，一个是使用状态的 from 空间，一个是闲置状态的 to 空间。每次进行垃圾回收的时候都会有一半的内存是用不了的，但是由于其空间小，因此浪费不了多少空间。</p><p>如果有个对象在新生代的多次垃圾回收中都没被收走，那么他就会晋升到老生代内存，晋升的标准有：</p><ul><li>垃圾回收中，对象经历过一次新生代清理，就可以晋级了(类似于游戏晋级赛)</li><li>垃圾回收过程中，如果To空间使用超过 25% ，那么它也可以晋级了(类似于补位晋级)</li></ul><h4 id="2-老生代内存"><a href="#2-老生代内存" class="headerlink" title="2.老生代内存"></a>2.老生代内存</h4><p>老生代保存一些周期长的对象，因此其占用内存非常多。</p><p>所以老生代就不会使用像新生代那样的算法了，会使用 <code>Mark-Sweep</code> 和 <code>Mark-Compact</code> 的结合体。主要采用 <code>Mark-Sweep</code> 。如果老生代空间不足以分配从新生代晋级过来的对象时，才会使用 <code>Mark-Compact</code>。</p><ol><li>Mark-Sweep(标记清除)</li></ol><p>用于清除一些已死亡的对象。(标记v8内存中死亡的对象，然后清除掉)</p><ol start="2"><li>Mark-Compact(标记整理)</li></ol><p>标记清除会产生内存碎片，而标记整理会在清除的基础上进行修改，在清除时让其变得更加紧缩。</p><ol start="3"><li>惰性清理</li></ol><p>在标记时，v8已经掌握了内存区对象的死活，他会延迟这一过程的清理。垃圾回收器可以根据自身需要来清理死掉的对象。</p><h3 id="隔离实例"><a href="#隔离实例" class="headerlink" title="隔离实例"></a>隔离实例</h3><p>Chrome v8 中一个引擎实例的数据类型叫 <code>Isolate</code>，全称为隔离实例(<code>Isolated Instance</code>)，是一个 v8 引擎的实例，也可以理解为引擎主体，每个实例内部拥有完全独立的各种状态：堆管理、垃圾回收机制。</p><p>抛开 Node.js 不说，使用 v8 进行开发的开发者其实是可以在它的程序中创建多个 Isolate 实例，并且并行地在多个线程中使用——但单个实例不能在多线程中使用。</p><p>在开发 node 的 cpp拓展时，已经就处于 v8 的环境中了，这时不需要再生成一个实例了，直接获取 node.js 环境所使用的实例即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::value&gt;&amp; args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Isolate* isolate = args.GetIsolate();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文对象是用来定义 js 执行环境的一个对象，其数据类型是 <code>Context</code>，它在创建的时候要指明属于哪个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8::Isolate* isolate = ...;</span><br><span class="line">v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);</span><br></pre></td></tr></table></figure><p>这里可以理解为一个沙箱化的执行上下文环境，内部预置了一系列对象和函数。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>是一段已经编辑好的 js 脚本的对象。数据类型就是 <code>Script</code> 。在编译是和一个处于活动状态的 上下文进行绑定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::context&gt; context = ...;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">v8::Local&lt;v8::String&gt; source = 一段 js 代码;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上下文绑定并且编译</span></span><br><span class="line">v8::Local&lt;v8::Value&gt; result = v8::Script::Compile(context, source).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行脚本</span></span><br><span class="line">v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();</span><br></pre></td></tr></table></figure><h3 id="句柄-Handle"><a href="#句柄-Handle" class="headerlink" title="句柄(Handle)"></a>句柄(Handle)</h3><p>句柄在 v8 中提供对于堆内存中的 js 数据对象的一个引用。</p><p>之所以使用句柄而不是对象指针之类的，一个主要的原因是因为 v8 在进行垃圾回收机制的时候，通常会将 js 的数据对象移来移去，如果使用指针的话，一个对象被移走了，那么这个指针就成为了野指针。如果是 handle ，垃圾回收器就会更新引用了数据块的那些 handle,让其断不了联系。</p><p>当一个对象不被句柄所引用时，就被认定为是垃圾。句柄的类型有：</p><ul><li>本地句柄(v8::Local)</li><li>持久句柄(v8::Persistent)</li><li>永生句柄(v8::Eternal)</li><li>待实本地句柄</li><li>其他句柄</li></ul><p>其中本地和持久是最常用的句柄。</p><p><strong>句柄的存在形式是 C++ 的一个模版类，其需要根据不同的 v8 数据类型进行不同的声明。</strong></p><ul><li><code>v8::Local&lt;v8::Number&gt;</code>：本地 js 数值类型句柄</li><li><code>v8::Persistent&lt;v8::String&gt;</code>:本地js字符串类型句柄</li></ul><h4 id="本地句柄"><a href="#本地句柄" class="headerlink" title="本地句柄"></a>本地句柄</h4><p>存在于栈内存中，在对应的析构函数被调用时被删除。生命周期是由其所在的句柄作用域所决定的。</p><p>本地句柄有一些比较重要的 <code>api</code>：</p><h5 id="1-创建-new"><a href="#1-创建-new" class="headerlink" title="1.创建(new)"></a>1.创建(new)</h5><p><code>New</code> 是 Local 句柄的一个静态方法。在<code>node v6.9.4</code> 对应的 v8 版本有两个重载。</p><ul><li><code>Local&lt;T&gt;::New(Isolate* isolate, Local&lt;T&gt; that)</code>: 传入Isolate 实例和一个本地句柄，进行复制构造</li><li><code>Local&lt;T&gt;::New(Isolate* isolate, const PersistentBase&lt;T&gt; &amp;that)</code>:传入 Isolate 实例和一个持久句柄</li></ul><h5 id="2-清除-Clear"><a href="#2-清除-Clear" class="headerlink" title="2.清除(Clear)"></a>2.清除(Clear)</h5><p>将句柄的指向空:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;Number&gt; handle = Number::New(isolate, <span class="number">23333</span>);</span><br><span class="line">handle.Clear();</span><br></pre></td></tr></table></figure><h5 id="3-是否为空-IsEmpty"><a href="#3-是否为空-IsEmpty" class="headerlink" title="3.是否为空(IsEmpty)"></a>3.是否为空(IsEmpty)</h5><p>判断为空并不是直接使用<code>==</code>,而是<code>IsEmpty</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;Number&gt; handle = Number::New(isolate, <span class="number">23333</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle.IsEmpty()) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-转换数据类型-As-Cast"><a href="#4-转换数据类型-As-Cast" class="headerlink" title="4.转换数据类型(As/Cast)"></a>4.转换数据类型(As/Cast)</h5><p>将某种数据类型的句柄转换成另外一种类型的本地句柄，可以使用<code>As</code> 和<code>Cast</code> 函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Chrome-V8-基础-上&quot;&gt;&lt;a href=&quot;#Chrome-V8-基础-上&quot; class=&quot;headerlink&quot; title=&quot;Chrome V8 基础-上&quot;&gt;&lt;/a&gt;Chrome V8 基础-上&lt;/h2&gt;&lt;h3 id=&quot;Node-js-与-Chrome-V8&quot;&gt;&lt;a href=&quot;#Node-js-与-Chrome-V8&quot; class=&quot;headerlink&quot; title=&quot;Node.js 与 Chrome V8&quot;&gt;&lt;/a&gt;Node.js 与 Chrome V8&lt;/h3&gt;&lt;p&gt;Node.js 的 JavaScript 运行时引擎是 Chrome V8，那么它们是以何种形式链接起来的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2006 年，V8 开始投入研发&lt;/li&gt;
&lt;li&gt;2008年9月，V8 发布了第一个版本，并且 Chrome 浏览器也几乎同期发布，至此 js 还是运行在浏览器中的一门脚本语言&lt;/li&gt;
&lt;li&gt;2009年， ry 开发了 Node.js&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后 js 就被带入后端领域，V8 也不仅仅只是 Chrome 的一个支持引擎。&lt;/p&gt;
&lt;p&gt;与 Chrome 差不多，node 为 v8 提供了一个宿主，只不过前者的宿主中包含的是类似于 HTML DOM、&lt;code&gt;window&lt;/code&gt; 对象等内容；&lt;strong&gt;而后者则提供了一整个沙箱 &lt;code&gt;vm&lt;/code&gt;机制，以及文件系统、网络操作等内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说，Node.js 实际上就是 Chrome V8 引擎的一个宿主。如果你有兴趣，也完全可以用 Chrome V8 创造一个别的 &lt;code&gt;.js&lt;/code&gt; ，比如 &lt;code&gt;Mode.js&lt;/code&gt; 、 &lt;code&gt;Lode.js&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;因此，我们并不需要对 Chrome V8 有一个特别深入的了解，也不需要知道它的算法、原理等。我们只用关心它暴露出来的一些 api，以及使用这些 api 所必要的储备知识。&lt;/p&gt;
&lt;p&gt;有了这些 api，我们就能让自己的 C++ 扩展与 Node.js 进行互通了 —— 因为 Node.js 底层很大程度上也是直接使用了 Chrome V8 所暴露出来的 api。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-页面渲染流程(下)</title>
    <link href="http://zoomdong.site/2020/05/29/broswer-6/"/>
    <id>http://zoomdong.site/2020/05/29/broswer-6/</id>
    <published>2020-05-29T09:21:26.000Z</published>
    <updated>2020-05-29T09:23:25.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>因为页面中还有一些复杂的动画效果，例如一些复杂的 3D 变化、页面滚动。为了更方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树</strong>(LayerTree)。</p><p>想要更直观地理解图层，可以打开 Chrome 的“开发者工具”， 选择“Layers”标签，就可以看到可视化页面的分层情况。</p><p>渲染引擎给页面分了很多图层，这些图层按照一定的顺序叠加在一起，就形成了最终的页面。</p><a id="more"></a><p>图层和布局节点树之间的关系为：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529152538.png" alt="image-20200529152538242"></p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有相对应的层，那么这个节点就属于父节点的图层。</p><p>上图中 span 标签没有专属图层，那么它就从属于它的父节点图层。不管怎么样，最终每个节点都会直接或间接从属于一个层。</p><p>一般渲染引擎会为满足下面条件的节点创建新的图层:</p><h3 id="1-拥有层叠上下文属性的元素会被提升为单独的一层"><a href="#1-拥有层叠上下文属性的元素会被提升为单独的一层" class="headerlink" title="1.拥有层叠上下文属性的元素会被提升为单独的一层"></a>1.拥有层叠上下文属性的元素会被提升为单独的一层</h3><p>页面是个二维页面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上，根据下图来感受：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529153313.png" alt="image-20200529153313693"></p><p>从图中可以看出，明确定位元素的属性、定义透明属性的元素、使用 CSS 滤镜的元素等都有层叠上下文属性。</p><h3 id="2-需要裁剪-clip-的地方也会被创建为图层"><a href="#2-需要裁剪-clip-的地方也会被创建为图层" class="headerlink" title="2.需要裁剪(clip)的地方也会被创建为图层"></a>2.需要裁剪(clip)的地方也会被创建为图层</h3><p>裁剪例如,设置了<code>overflow: auto</code> 属性的 <code>div</code> 元素。超出了限定的面积之后那么div里面的内容就会被裁剪。</p><p>这种情况下，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会成单独一层。</p><h2 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h2><p>完成图层构建之后，渲染引擎就会对图层树中的每个图层进行绘制。</p><p>渲染引擎会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529160103.png" alt="image-20200529160103665"></p><p>从图中可以看出，绘制列表中的指令其实很简单，就是让其执行一个简单的绘制操作，比如绘制线条之类的。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的列表就是这些待绘制列表。</p><h2 id="栅格化-raster-操作"><a href="#栅格化-raster-操作" class="headerlink" title="栅格化(raster)操作"></a>栅格化(raster)操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎的合成线程来完成的。可以结合下图来查看渲染主线程和合成线程之间的关系：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529161218.png" alt="image-20200529161218832"></p><p>如上图，当图层的绘制列表准备好之后，主线程会把绘制列表<strong>提交（commit）</strong>结合成线程，那么接下来合成线程是怎么准备工作的呢？</p><p>首先我们先知道一个叫做视口的概念：一个页面可能很大，但是用户只能看到其中的一部分，那么这一部分就是视口。</p><p><strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的</strong>。所谓栅格化，是指将图块转成位图。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529163059.png" alt="image-20200529163059152"></p><p>通常，这个过程会被 GPU 来加速生成，使用 GPU 生成位图的过程叫做快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><p>GPU 操作是运行在 GPU 进程中的，栅格化操作使用了 GPU，最终生成位图的操作是在 GPU 中完成的。这就涉及到了跨进程操作：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529163434.png" alt="image-20200529163433987"></p><p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><h2 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，根据此命令，将其内容绘制到内存中，然后再将内存显示在屏幕上。</p><p>到这里，html、css、js 等文件经过浏览器就会显示出漂亮的页面了。</p><h2 id="渲染流水线总结"><a href="#渲染流水线总结" class="headerlink" title="渲染流水线总结"></a>渲染流水线总结</h2><p>总结图为：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529165110.png" alt="image-20200529165109936"></p><p>结合上图，一个完整的渲染流程大致可总结为：</p><ol><li>渲染进程将 HTML -&gt; DOM</li><li>渲染引擎将 CSS -&gt; StyleSheets，计算出 DOM 样式的节点</li><li>创建布局树，并计算元素的布局信息</li><li>对布局树分层，并生成分层树</li><li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程</li><li>合成线程将图层<strong>分块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图</li><li>合成线程发送图块绘制命令 <strong>DrawQuad</strong> 给浏览器进程</li><li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上面</li></ol><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>三个关于渲染流水线的相关概念——“<strong>重排</strong>”、“<strong>重绘</strong>”、“<strong>合成</strong>”。</p><h4 id="1-更新了元素的几何属性-重排"><a href="#1-更新了元素的几何属性-重排" class="headerlink" title="1.更新了元素的几何属性(重排)"></a>1.更新了元素的几何属性(重排)</h4><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529171002.png" alt="image-20200529171002628"></p><p>RT，通过 js 或 css 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器就会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p><h3 id="2-更新元素的绘制属性-重绘"><a href="#2-更新元素的绘制属性-重绘" class="headerlink" title="2. 更新元素的绘制属性(重绘)"></a>2. 更新元素的绘制属性(重绘)</h3><p>如图所示：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529171409.png" alt="image-20200529171409707"></p><p>如果 js 修改了元素的背景颜色，那么布局阶段将不会被执行，因为没有引起几何位置的变化，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。<strong>相较于重绘，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p><h3 id="3-直接合成阶段"><a href="#3-直接合成阶段" class="headerlink" title="3.直接合成阶段"></a>3.直接合成阶段</h3><p>如果改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，那么这个过程就叫做合成。具体流程为：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200529171759.png" alt="image-20200529171759530"></p><p>上图中使用了 CSS 的 transform 来实现动画，这可以避开重排和重绘阶段，直接在非主线程执行合成动画的操作。这样的效率是最高的。因为是在非主线程上合成，并且没有占用主线程和资源，另外也避开了布局和绘制两个阶段。因此，<strong>合成能够大大提升绘制效率</strong>。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>减少重排重绘, 方法很多：</p><ol><li>使用 class 操作样式，而不是频繁操作 style</li><li>避免使用 table 布局</li><li>批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React</li><li>Debounce window resize 事件</li><li>对 dom 属性的读写要分离</li><li>will-change: transform 做优化</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分层&quot;&gt;&lt;a href=&quot;#分层&quot; class=&quot;headerlink&quot; title=&quot;分层&quot;&gt;&lt;/a&gt;分层&lt;/h2&gt;&lt;p&gt;因为页面中还有一些复杂的动画效果，例如一些复杂的 3D 变化、页面滚动。为了更方便地实现这些效果，&lt;strong&gt;渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树&lt;/strong&gt;(LayerTree)。&lt;/p&gt;
&lt;p&gt;想要更直观地理解图层，可以打开 Chrome 的“开发者工具”， 选择“Layers”标签，就可以看到可视化页面的分层情况。&lt;/p&gt;
&lt;p&gt;渲染引擎给页面分了很多图层，这些图层按照一定的顺序叠加在一起，就形成了最终的页面。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-页面渲染流程(上)</title>
    <link href="http://zoomdong.site/2020/05/28/broswer-5/"/>
    <id>http://zoomdong.site/2020/05/28/broswer-5/</id>
    <published>2020-05-27T16:55:31.000Z</published>
    <updated>2020-05-27T16:56:18.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>通常，我们编写好 HTML、JavaScript、CSS等文件，经过浏览器就会显示出漂亮的页面。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526114743.png" alt="image-20200526114743309"></p><p>RT,左边输入html,js,css，这些数据经过中间的一个渲染过程，最终输出为屏幕上的像素。</p><p>这中间的渲染模块就是我们需要讨论的问题。</p><a id="more"></a><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526114936.png" alt="image-20200526114936334"></p><p>RT,HTML 内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。</p><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。这样的一个处理流程就叫做<strong>渲染流水线</strong>。流程示意图如下:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526120441.png" alt="image-20200526120441571"></p><p>按照渲染的时间顺序，流水线可以分为以下几个子阶段:<strong>构建 DOM 树 -&gt; 样式计算 -&gt; 布局阶段 -&gt; 分层 -&gt; 绘制 -&gt; 分块 -&gt; 光栅化 -&gt; 合成</strong>。</p><p>重点要关注的应该有以下几个阶段:</p><ul><li>开始每个阶段都有其<strong>输入的内容</strong></li><li>然后每个子阶段有其<strong>处理过程</strong></li><li>最后每个子阶段会生成<strong>输出内容</strong></li></ul><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的树结构 —— DOM 树。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526144725.png" alt="image-20200526144725611"></p><p>这玩意儿实际就是数据结构里面的树。在渲染流程中，就有频繁地使用树结构。</p><p>根据下图可以参考 DOM 树的构建过程:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526144850.png" alt="image-20200526144850462"></p><p>从图中可以看出，构建 DOM 树的输入内容实际上是一个很简单的 HTML 文件，然后经过 HTML 解析器解析，最后输出树状结构的 DOM。</p><p>为了更加直观地理解 DOM 树，可以在 console 控制台上直接打上一个”document”，这样就能看到一个完整的 DOM 树结构。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526150004.png" alt="image-20200526150004652"></p><p>我们可以通过 <code>JavaScript</code> 代码来修改 <code>DOM</code> 的内容。</p><h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>样式计算的目的是为了计算出 DOM 每个节点的具体样式。分三个步骤完成：</p><h3 id="1-把-CSS-转换为浏览器能够理解的结构"><a href="#1-把-CSS-转换为浏览器能够理解的结构" class="headerlink" title="1. 把 CSS 转换为浏览器能够理解的结构"></a>1. 把 CSS 转换为浏览器能够理解的结构</h3><p>CSS 样式来源主要有以下三种：</p><ul><li>通过 link 引用外部 CSS</li><li><code>&lt;style&gt;</code>内标记的 CSS</li><li>元素的 <code>&lt;style&gt;</code> 属性内嵌的 CSS</li></ul><p>和 HTML 文件一样，浏览器也没有办法直接去理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换的操作，将 CSS 文本转换为浏览器可以理解的结构 —— stylesheet.</p><p>我们可以在控制台中输入 <code>document.styleSheets</code> 来看到 styleSheets 的结构。渲染引擎会把获得到的 CSS 文本全部转换成 styleSheets 结构中的数据，并且该数据同时具备了查询和修改功能，为后面的样式操作提供基础。</p><h3 id="2-转换样式表中属性值，使其标准化"><a href="#2-转换样式表中属性值，使其标准化" class="headerlink" title="2. 转换样式表中属性值，使其标准化"></a>2. 转换样式表中属性值，使其标准化</h3><p>现在已经把现有的 <code>CSS</code> 结构转化为浏览器可以理解的结构了，那么接下来就需要对其进行属性标准化操作了。</p><p>什么是属性值标准化，可以参考下面的 CSS 文本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">2em</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">display</span>: none&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font-weight</span>: bold&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">color</span>:red; &#125;</span><br></pre></td></tr></table></figure><p>CSS 文本中有很多属性值，如 2em、blue、bold，这些类型的数值不容易被渲染引擎理解，所以需要<strong>将所有值转换为渲染引擎容易理解的、标准化的计算值</strong>，这个过程就是属性值的标准化。</p><p>标准化之后的属性值为：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200528002923.png" alt="image-20200528002923033"></p><h3 id="3、计算出-DOM-树中每个节点的具体样式"><a href="#3、计算出-DOM-树中每个节点的具体样式" class="headerlink" title="3、计算出 DOM 树中每个节点的具体样式"></a>3、计算出 DOM 树中每个节点的具体样式</h3><p>这里就涉及到 CSS 的继承规则和层叠规则了。</p><p>首先是 CSS 继承。<strong>CSS 继承就是每个 DOM 节点都包含有父节点的样式</strong>。</p><p>例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">20px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">display</span>: none&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font-weight</span>: bold;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure><p>最终应用到 DOM 节点的效果如下图所示：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200528003200.png" alt="image-20200528003200532"></p><p>从图可以看出，所有子节点都继承了父节点的样式。比如 body 节点的 font-size 属性是 20，那么 body 节点下面的所有节点的 font-size 都等于 20。</p><p>我们可以打开 Chrome 的开发者工具，选择第一个 Element 标签，再选择 style 子标签，可以看到如下界面：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200528003417.png" alt="image-20200528003417076"></p><p>大致可以描述为：</p><ul><li>首先，可以选择要查看的<strong>元素的样式(位于图中区域二)</strong>，图中第一个区域点击对应的元素，就可以了解下面的区域查看元素的样式了。</li><li>可以通过查看<strong>样式来源</strong>中查看样式的具体来源信息，看是来自于样式文件，还是 UA 样式表。</li><li>最后可以通过区域 2 和区域 3 来查看样式继承的具体过程。</li></ul><p>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算样式的节点。</p><p><strong>层叠是 CSS 的一个基本特征，它定义了如何合并来自多个源的属性值算法。它在 CSS 中处于核心地位，其全称 “层叠样式表” 正是想强调这一点。</strong></p><p>如果你想了解每个 DOM 元素的最终计算样式，可以打开 Chrome 的“开发者工具”，选择第一个 “element” 标签，然后再选择 “Computed” 子标签。RT:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200528004227.png" alt="image-20200528004227762"></p><p>上图红色框图显示了 <code>html.body.div.p</code>标签的 ComputedStyle 的值。想查看哪个元素，点击左边对应的标签就行了。</p><h2 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h2><p>计算出 DOM 树可见元素的几何位置，我们把这个计算过程叫做布局。</p><p>Chrome 在布局阶段主要需要完成两个任务：创建布局树和布局计算。</p><h3 id="1-创建布局树"><a href="#1-创建布局树" class="headerlink" title="1.创建布局树"></a>1.创建布局树</h3><p>你可能注意到 DOM 树还含有很多不可见的元素，例如 head 标签，还有使用了 <code>display: none</code> 属性的元素。所以，在显示之前，我们还要额外地构建一颗只包含可见元素布局树。结合下图看布局树的构造过程：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200528004626.png" alt="image-20200528004625999"></p><p>从上可以看出：DOM 树中所有不可见的节点都没有包含到布局树中。</p><p>为了构建布局树，浏览器大体需要完成以下的工作：</p><ul><li>遍历 DOM 树中所有可见节点，并把这些节点加到布局树中。</li><li>不可见的节点会被布局树忽略掉， 如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为他有 <code>display: none</code> 这个属性，所以也没有被包括进去布局树之中。</li></ul><h3 id="2-布局计算"><a href="#2-布局计算" class="headerlink" title="2.布局计算"></a>2.布局计算</h3><p>现在我们已经有了一颗完整的布局树，后序 Chrome 会对布局树节点的坐标位置进行一个计算。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个过程大致可以总结为：</p><ul><li>浏览器不能直接理解 HTML，所以需要进一步需要将其转换为浏览器能够理解的 DOM 树结构；</li><li>生成 DOM 树后，还要根据 CSS 样式表，来计算出 DOM 树所有节点的样式</li><li>最后计算出 DOM 元素的布局信息，使其都保存在布局树中</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;通常，我们编写好 HTML、JavaScript、CSS等文件，经过浏览器就会显示出漂亮的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526114743.png&quot; alt=&quot;image-20200526114743309&quot;&gt;&lt;/p&gt;
&lt;p&gt;RT,左边输入html,js,css，这些数据经过中间的一个渲染过程，最终输出为屏幕上的像素。&lt;/p&gt;
&lt;p&gt;这中间的渲染模块就是我们需要讨论的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从 0 开始，成为 Ant-Design Contributor</title>
    <link href="http://zoomdong.site/2020/05/27/how-to-be-antd-contributor/"/>
    <id>http://zoomdong.site/2020/05/27/how-to-be-antd-contributor/</id>
    <published>2020-05-27T03:06:17.000Z</published>
    <updated>2020-05-27T03:10:32.940Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是 zoomdong，一名大三的学生，目前在北京实习。想给大家分享一下我最近给 Ant-design贡献代码的经历，同时也希望能引导大家来一起参与其中，一起为开源世界来贡献自己的力量！</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 <a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant-Desgin</a>，我想不用我做过多的介绍，大家或多或少有对其有所耳闻。作为一个顶级的“设计语言和研发框架”，antd 在国内乃至全世界都是十分受欢迎的。截止到这篇文章完成之前，antd 的 <a href="https://github.com/ant-design/ant-design/" target="_blank" rel="noopener">star</a> 数也成功突破了 60k 这一关口，master 分支的 commit 数目也高达 1万8千多，这反映了 antd 的受欢迎程度以及核心贡献者们对 issue 处理的效率之高。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527000338.png" alt="image-20200527000338797"></p><p>我是从大二学习前端时在学长的推荐下开始使用这个框架的，在校时使用 react + antd + dva 完成了许许多多的项目。同时，就在今年，我也开始加入到了 antd 这个项目的贡献中去，在这个月第一次给 antd <a href="https://github.com/ant-design/ant-design/issues/24206" target="_blank" rel="noopener">修复了bug</a>，成功成为了一名 antd 的contributor了。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200526235101.png" alt="image-20200526235100981"></p><h2 id="贡献-Pull-Request-的流程"><a href="#贡献-Pull-Request-的流程" class="headerlink" title="贡献 Pull Request 的流程"></a>贡献 Pull Request 的流程</h2><p>再开始做出贡献之前，建议先去 antd 官网的参考一下项目的<a href="https://ant.design/docs/react/contributing-cn" target="_blank" rel="noopener">贡献流程</a>。</p><p>Ant-design 的代码目前全部开源在 <a href="https://github.com/ant-design/ant-design" target="_blank" rel="noopener">GitHub</a>,遵循 MIT 开源协议。如果想为 antd 贡献自己的代码需要做以下几方面的工作：</p><h3 id="1、拷贝-fork-过来的项目"><a href="#1、拷贝-fork-过来的项目" class="headerlink" title="1、拷贝 fork 过来的项目"></a>1、拷贝 fork 过来的项目</h3><p>先将antd的代码 fork 一份到自己的仓库，然后 clone 下来，并添加主代码库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将 fork 过来的仓库 <span class="built_in">clone</span> 到本地</span><br><span class="line">// <span class="built_in">clone</span> 速度太慢可以尝试配置代理</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/&#123;username&#125;/ant-design.git</span><br><span class="line"><span class="built_in">cd</span> ant-design</span><br><span class="line">// 添加主代码库</span><br><span class="line">git remote add upstream https://github.com/ant-design/ant-design.git</span><br></pre></td></tr></table></figure><h3 id="2、分支管理"><a href="#2、分支管理" class="headerlink" title="2、分支管理"></a>2、分支管理</h3><p>antd 的贡献流程里面有提过：<strong>修复 bug 反馈到 master 分支；新增 feature 反馈到 feature 分支</strong>。</p><p>基于我们之前有添加主仓库，如果我们想与主仓库对应的分支保持同步的话，使用 git rebase 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 拉去主仓库的代码</span><br><span class="line">git fetch upstream</span><br><span class="line">// 同步对应分支的代码</span><br><span class="line">git rebase upstream/master</span><br><span class="line">git rebase upstream/feature</span><br></pre></td></tr></table></figure><p>以我之前的一次 <a href="https://github.com/ant-design/ant-design/pull/24385" target="_blank" rel="noopener">pr</a> 作为例子: 这次 pr 因为是新增了 feature，因此我们从 feature 分支切一个分支出来即可:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先从 master 切换至 <span class="built_in">feature</span></span><br><span class="line">git checkout <span class="built_in">feature</span></span><br><span class="line">// 然后从 <span class="built_in">feature</span> 上切一个新的分支出来</span><br><span class="line">git checkout -b <span class="built_in">feature</span>-xxx</span><br></pre></td></tr></table></figure><p>然后我们在这个feature 分支完成开发即可，同步之前提交使用 git rebase 即可。</p><h3 id="3、提交-pr"><a href="#3、提交-pr" class="headerlink" title="3、提交 pr"></a>3、提交 pr</h3><p>我们先将自己的修改提交到自己 fork 过来的仓库相对应的分支上面去。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add 修改文件</span><br><span class="line">git commit -m <span class="string">"xxx"</span></span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">feature</span>-xxx</span><br></pre></td></tr></table></figure><p>这里要注意 commit 信息的规范，可以参考<a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰老师博客</a>。</p><p>在提交成功之后，我们直接到 github 上面提交这份 pr，antd 的 pr 是会<a href="https://github.com/ant-design/ant-design/blob/master/.github/PULL_REQUEST_TEMPLATE.md" target="_blank" rel="noopener">自动生成模版</a>的，跟着模块相关的信息去填写即可，注意这里 pr 给 antd 的分支时同样要注意是 master 还是 feature 分支。</p><h3 id="4、修改-pr"><a href="#4、修改-pr" class="headerlink" title="4、修改 pr"></a>4、修改 pr</h3><p>如果有大佬 review 了你的提交并给出了修改意见，因为很大部分的 pr 其实都会被指出意见，我们这里虚心去接受大佬的指导然后做出修改即可:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add 修改文件</span><br><span class="line">git commit -m <span class="string">"fix: xxxx"</span></span><br><span class="line">git fetch upstream</span><br><span class="line">// 这里注意分支</span><br><span class="line">git rebase upstream/<span class="built_in">feature</span></span><br><span class="line">// 然后将修改提交到之前到分支，这时候github会自动帮你把提交同步过去的</span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">feature</span>-xxx</span><br></pre></td></tr></table></figure><h2 id="贡献实战"><a href="#贡献实战" class="headerlink" title="贡献实战"></a>贡献实战</h2><p>这里结合我前几天自己的一次贡献经历来给大家实际展现一个具体的贡献流程是怎么样的～</p><h3 id="1-找到-issue-并分析"><a href="#1-找到-issue-并分析" class="headerlink" title="1. 找到 issue 并分析"></a>1. 找到 issue 并分析</h3><p>之前也有说过，antd 一般有两种 pr：修复一个 bug 或者贡献一个新的feature。第一次参加某个开源项目一般都是从这个项目的 <code>good First Issue</code>入手，同样在 antd 里面这样的 <a href="[https://github.com/ant-design/ant-design/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22](https://github.com/ant-design/ant-design/issues?q=is%3Aissue+is%3Aopen+label%3A&quot;good+first+issue&quot;">issue</a>) 可以提供给开发者去解决。同样也会有一些 <code>help wanted</code> 标签的 issue 给开发者去解决，这样的问题一般都会有用户提供复现的连接，我们可以从这方面来开始入手，于是我找到了这样的一个 issue:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527005736.png" alt="image-20200527005736401"></p><p>这是去年的一个issue，我看到这个 issue 问题的问题的时候，里面已经有大佬关于这个 issue 做了一些讨论。</p><p>实际上，我并没有使用过 Typography 这个组件，于是我去 ant-design 的官网查阅了相关的 <a href="https://ant.design/components/typography-cn/" target="_blank" rel="noopener">api 文档</a>，大概知道了这是个用于做文章排版的组件，报告人对当前改组件里面一个 Paragraph 设置的自动隐藏的按钮并不是特别满意，他希望能提供出一个 api 供他自己去定制这个省略的按钮。</p><p>这个时候我们就大概知道了报告人希望改善的地方在哪里了，然后参考了下面大佬的一些讨论，我需要在 Typography.Paragraph 里面提供一个 <code>symblol</code> 参数来让他去自定义省略展开按钮的样式。同时这个参数的类型应该是 <code>React.ReactNode</code>。</p><h3 id="2-编写代码并提交-pr"><a href="#2-编写代码并提交-pr" class="headerlink" title="2. 编写代码并提交 pr"></a>2. 编写代码并提交 pr</h3><p>于是按照上面的逻辑打开了 antd 的源码，从 feature  分支切出一个新的 feature-typography 分支。找到我们要修改的组件所在的文件夹，一般组件名都会在 components 下面有个对应的文件，找到这个文件即可，这里就是 <code>typography</code>。</p><p>这里我大概分析出来了我要加的地方之后，然后先在本地启动 antd。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装项目依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">// 本地开启端口访问</span></span><br><span class="line">npm <span class="built_in">run</span> start</span><br></pre></td></tr></table></figure><p> 一般项目都运行在本地的<code>8000</code> 端口上，我们直接去访问即可。我们在<code>typography</code>里面对应的代码逻辑里面添加了相应的逻辑之后，这时我们想看看自己的修改是否生效，这里就可以使用 <code>antd</code> 本地跑起来的官网上的 <code>demo</code> 来做测试用例。</p><p>我们可以看到：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527100031.png" alt="image-20200527100031436"></p><p>最开始的省略号是默认的“展开”字符，这里我们通过新增的 api 往里面传递我们自己的参数：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527100231.png" alt="image-20200527100231242"></p><p>那么这个地方就可以是用户自定义的了。看上去一切都大功告成了，于是我按照上面提交 pr 的逻辑开了 pr 到 antd 的主仓库。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527100522.png" alt="image-20200527100522037"></p><p>注意这里我提交pr的分支是 feature 分支，同时按照 antd 的 template 填好相关的信息。大概过一段时间之后就会有核心贡献者来 review 你的pr，不得不说 antd 的贡献者们都是极其活跃的，不一会儿 pr 就有人 review 了。</p><h3 id="3-代码-review-并做出修改"><a href="#3-代码-review-并做出修改" class="headerlink" title="3. 代码 review 并做出修改"></a>3. 代码 review 并做出修改</h3><p>没过多久 afc163 大佬就看到了我的 pr,然后做了review：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527101513.png" alt="image-20200527101513702"></p><p>因为是第一次提交，我只在本地跑过了 <code>Typography</code> 这个组件的测试就开了pr,发现有个 <code>lint</code> 检查是没有通过的。于是这里要注意的时，<strong>本地提交之前要先运行好 <code>npm run test</code> 和 <code>npm run lint</code> 以确保所有的代码检验都通过</strong>。</p><p>在本地修改了 <code>lint error</code> 的代码逻辑之后，我重新提交了代码，然后再次收到了 afc163 的建议：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527103746.png" alt="image-20200527103746439"></p><p>注意，<strong>加测试其实是一个很重要的步骤</strong>，尤其是对于这种组件库代码而言，之前我在修复<a href="https://github.com/react-component/input-number/pull/246" target="_blank" rel="noopener">另外一个bug</a>的时候,afc163 大佬也有给过建议。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527103936.png" alt="image-20200527103936510"></p><p>这里我们就直接去 <code>Typography</code> 组件下的<code>tests</code>目录去加上对应的测试用例:</p><p>然后加完之后确保测试用例通过运行可以使用：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span> <span class="comment">运行指定的</span> <span class="comment">Typography</span> <span class="comment">组件测试代码</span></span><br><span class="line"><span class="comment">npm</span> <span class="comment">test</span> -- --<span class="comment">watch</span> <span class="comment">Typography</span></span><br></pre></td></tr></table></figure><p>等样例都运行通过之后再去提交新一轮的代码。最后 afc163 大佬给了一个 api 文档的描述错误，我简单做了修改之后这次pr，就被成功的合并了。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527104506.png" alt="image-20200527104506319"></p><p>到这一步的时候，就已经成功成为一名 antd 的 contributor了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我看来，开源其实一直是一个重在参与、或者说是图一乐的事情。在我大二那年的时候，我发现了 github 这个世界最庞大的开源社区，便沉迷于此不可自拔，<strong>这真的是一件很有意义且有意思的事情</strong>，不过是阅读大佬的代码还是在社区修一些力所能及的bug。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200527105419.png" alt="image-20200527105419056"></p><p>希望能用这篇文章，给更多想参加开源却不知道从何下手的人做一个简单的入门讲解。开源并不是一件很困难的事情，入门也远没有你所想象的那么困难。一个项目的发展，抑或是一个生态的形成，项目的核心贡献者们固然起到了重要的作用，但同样也离不开像我们这样的使用项目并去给拓展项目生态的人，经过无数次的修改，一个真正能够造福使用者的项目或者是生态才能够成形。</p><p>让我们一起加入其中吧～</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://zhuanlan.zhihu.com/p/123367842" target="_blank" rel="noopener">如何快速的成为 Ant Design 的 contributor</a></p><p><a href="https://zhuanlan.zhihu.com/p/27932211" target="_blank" rel="noopener">为 Node.js 贡献你的力量</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好，我是 zoomdong，一名大三的学生，目前在北京实习。想给大家分享一下我最近给 Ant-design贡献代码的经历，同时也希望能引导大家来一起参与其中，一起为开源世界来贡献自己的力量！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口解题技巧</title>
    <link href="http://zoomdong.site/2020/05/26/siliding-window/"/>
    <id>http://zoomdong.site/2020/05/26/siliding-window/</id>
    <published>2020-05-26T03:20:59.000Z</published>
    <updated>2020-05-26T03:21:37.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>在字符串 S 中使用双指针的左右指针技巧，初始化 left = right = 0,索引闭区间 [left, right] 称为一个窗口</li><li>先不断增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符串）</li><li>此时，停止增加 right,转而不断增加 left 指针来缩小窗口 [left, right]，直到窗口中的字符串不再符合要求 (不包含 T 中的所有字符了)。同时，每次增加 left，都要更新一轮结果。</li><li>重复 2 - 3 ,直到 right 到达尽头。</li></ul><a id="more"></a><h3 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> res = s;</span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  window.add(s[right])</span><br><span class="line">  right ++;</span><br><span class="line">  <span class="comment">// 如果符合要求，移动left缩小窗口</span></span><br><span class="line">  <span class="keyword">while</span> (window 符合要求) &#123;</span><br><span class="line">    <span class="comment">// 如果这个窗口的子串更短，则更新res</span></span><br><span class="line">    res = minLen(res, window);</span><br><span class="line">    window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>那么我们要如何判断window即子串 <code>s[left...right]</code> 是否符合要求，是否包含 <code>t</code> 的所有字符呢？</p><p>可以用两个hash表来做计数器，一个记录t的字符以及出现次数，另一个window则记录当前窗口所包含的字符及出现的次数，如果window包含所有needs中的键，且这些键对应的值都大于等于needs中的值，那么就可以知道当前窗口符合要求了，可以开始移动<code>left</code>指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">stirng s, t;</span><br><span class="line"><span class="comment">// 在s中找t的最小覆盖子串</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> res = s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于两个计数器</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; needs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">  needs[c] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 window 中已经有多少字符符合要求了</span></span><br><span class="line"><span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="keyword">char</span> c1 = s[right];</span><br><span class="line">  <span class="keyword">if</span> (needs.count(c1)) &#123;</span><br><span class="line">    <span class="comment">// 加入window</span></span><br><span class="line">    window[c1] ++;</span><br><span class="line">    <span class="keyword">if</span> (window[c1] === needs[c1]) &#123;</span><br><span class="line">      <span class="comment">// 字符c1点出现符合次数了</span></span><br><span class="line">      match ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  right ++;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// window 中的字符已符合 needs 的要求了</span></span><br><span class="line">  <span class="keyword">while</span> (match === needs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 更新结果res</span></span><br><span class="line">    res = minLen(res, window);</span><br><span class="line">    <span class="keyword">char</span> c2 = s[left];</span><br><span class="line">    <span class="keyword">if</span> (needs.count(c2)) &#123;</span><br><span class="line">      <span class="comment">// 移出 window</span></span><br><span class="line">      window[c2] --;</span><br><span class="line">      <span class="keyword">if</span> (window[c2] &lt; needs[c2]) &#123;</span><br><span class="line">        <span class="comment">// 字符 c2 出现次数不再符合要求</span></span><br><span class="line">        match --;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h3 id="lc76-最小覆盖子串"><a href="#lc76-最小覆盖子串" class="headerlink" title="lc76 最小覆盖子串"></a>lc76 最小覆盖子串</h3><p>这题可以套一套我们上面的板子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// s中能覆盖t的最小子串</span></span><br><span class="line"><span class="comment">// s = "ADOBECODEBANC",t = "ABC"</span></span><br><span class="line"><span class="comment">// res = "BNAC"</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  s = s.split(<span class="string">''</span>)</span><br><span class="line">  t = t.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">let</span> tMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">window</span> = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">    tMap.set(t[i], tMap.has(t[i]) ? tMap.get(t[i]) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> match = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (r &lt; s.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> c1 = s[r]</span><br><span class="line">    <span class="keyword">if</span> (tMap.has(c1)) &#123;</span><br><span class="line">      <span class="built_in">window</span>.set(c1, <span class="built_in">window</span>.has(c1) ? <span class="built_in">window</span>.get(c1) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.get(c1) === tMap.get(c1)) &#123;</span><br><span class="line">        match++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r++</span><br><span class="line">    <span class="comment">// 如果window中的串已经符合要求了,开始移动左边，找符合条件的最小值</span></span><br><span class="line">    <span class="keyword">while</span> (match === tMap.size) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r - l &lt; min) &#123;</span><br><span class="line">        start = l</span><br><span class="line">        min = r - l</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  更新一下最短的字符串</span></span><br><span class="line">      <span class="keyword">let</span> c2 = s[l]</span><br><span class="line">      <span class="keyword">if</span> (tMap.has(c2)) &#123;</span><br><span class="line">        <span class="built_in">window</span>.set(c2, <span class="built_in">window</span>.get(c2) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.get(c2) &lt; tMap.get(c2)) &#123;</span><br><span class="line">          match--</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      l++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min === <span class="built_in">Number</span>.MAX_SAFE_INTEGER ? <span class="string">''</span> : s.join(<span class="string">''</span>).slice(start, start + min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(minWindow('ADOBECODEBANC', 'ABC'))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在字符串 S 中使用双指针的左右指针技巧，初始化 left = right = 0,索引闭区间 [left, right] 称为一个窗口&lt;/li&gt;
&lt;li&gt;先不断增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符串）&lt;/li&gt;
&lt;li&gt;此时，停止增加 right,转而不断增加 left 指针来缩小窗口 [left, right]，直到窗口中的字符串不再符合要求 (不包含 T 中的所有字符了)。同时，每次增加 left，都要更新一轮结果。&lt;/li&gt;
&lt;li&gt;重复 2 - 3 ,直到 right 到达尽头。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dp技巧学习</title>
    <link href="http://zoomdong.site/2020/05/26/dp-1/"/>
    <id>http://zoomdong.site/2020/05/26/dp-1/</id>
    <published>2020-05-26T03:16:12.000Z</published>
    <updated>2020-05-26T03:16:48.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最优子结构详解"><a href="#最优子结构详解" class="headerlink" title="最优子结构详解"></a>最优子结构详解</h3><p>最优子结构：从子问题的最优结果推出更大规模的问题的最优结果。</p><a id="more"></a><p>例如，假设学校有10个班级，已经每个班级的最高分，要求全校的最高分。</p><p>这个问题就符合最优子结构:可以从子问题的最优结果推出更大规模问题的最优结果。计算每个班的最高分就是子问题。</p><p>这么简单的问题都具有最优子结构，但是因为没有重叠子问题，因此不用动态规划来解决。</p><p>再例如，假设学校有10个班级，已经每个班级都最大分数差，求出全校学生的最大分差。这个问题可以想办法算，但是肯定不能根据已知的最大分差来进行推，因为10个班的最大分差就不一定是全校的最大分差，有可能是 3 班的最高分和 6 班的最低分之差。</p><p>那么这次的这个问题就<strong>不符合最优子结构</strong>。没办法根据每个班的最优值推出规模更大问题的最优值。因为要想满足最优子结构，那么子问题之间必须要相互独立。最大分差可能出现在两个班级，子问题并不独立，所以这个问题不符合。</p><p>遇到这种情况，我们就需要对问题进行一个改造。先写一段暴力代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Student a: school) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Student b: school) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a is b) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="built_in">max</span> (result, <span class="built_in">abs</span>(a - b))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把问题来一波等价转换：最大分数差等价于最高分数和最低分数的差，这样不就具备有最优子结构了吗？</p><p>再举一个常见的例子，求一颗二叉树的最大值(假设节点中都是非负数):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxVal</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  let left = maxVal(root.left);</span><br><span class="line">  let right = maxVal(root.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(root.val, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题其实也符合最优子结构，以 <code>root</code> 为根的树的最大值，可以通过两边子树(子问题)的最大值推导出来。</p><p>但这也不是dp问题，最优子结构并不是dp独有的一种性质，能求最值的问题大部分都具备这个性质；但是反过来，最优子结构性质作为dp问题的必要条件，一定是用来求最值的。</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以观察是否出现重复的子问题，有的话就优化。</p><h3 id="dp数组遍历的方向"><a href="#dp数组遍历的方向" class="headerlink" title="dp数组遍历的方向"></a>dp数组遍历的方向</h3><p>以二维dp作为例子，有时候是正向遍历:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="comment">// 计算dp[i][j]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候反向:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m- <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">    <span class="comment">// 计算dp[i][j]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以斜着遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l&lt;=n;l++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n-l;i++) &#123;</span><br><span class="line">   <span class="keyword">int</span> j = l + i - <span class="number">2</span>;</span><br><span class="line">    dp[i][j] = ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果仔细观察的话，只需要掌握以下两点即可:</p><ul><li>遍历过程中，所需要的状态已经被计算出来了</li><li>遍历的终点必须是存储结果的那个位置</li></ul><p>以编辑距离这个题目作为例子，对dp数组的定义，确定的base的数组值是<code>dp[...][0]</code>和<code>dp[o][...]</code>，最终的答案是<code>dp[m][n]</code>;而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>、<code>dp[i][j-1]</code>、<code>dp[i-1][j-1]</code>转移而来，如下图:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525165038.png" alt="image-20200525165037985"></p><p>参考之前的原则，那么这里我们肯定会去正向遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (let j = <span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">    <span class="comment">// 通过 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] -&gt; dp[i][j]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再参考回文子序列问题，可以参考前面的”子序列问题模版”，通过对dp数组的定义，确定了base case处于中间的对角线,<code>dp[i][j]</code> 需要从<code>dp[i+1][j]</code>、<code>dp[i][j-1]</code>、<code>dp[i+1][j-1]</code>转移而来。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525165748.png" alt="image-20200525165748819"></p><p>根据刚才的两个原则，就可以有两种正确的遍历方式:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525165901.png" alt="image-20200525165901880"></p><p>要么从左到右斜着遍历，要么从下到上从左到右遍历，这样才能保证每次<code>dp[i][j]</code>到左边、下边、左下角已经计算完成，得到了正确的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最优子结构详解&quot;&gt;&lt;a href=&quot;#最优子结构详解&quot; class=&quot;headerlink&quot; title=&quot;最优子结构详解&quot;&gt;&lt;/a&gt;最优子结构详解&lt;/h3&gt;&lt;p&gt;最优子结构：从子问题的最优结果推出更大规模的问题的最优结果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-从输入URL到页面渲染</title>
    <link href="http://zoomdong.site/2020/05/25/broswer-4/"/>
    <id>http://zoomdong.site/2020/05/25/broswer-4/</id>
    <published>2020-05-24T16:35:43.000Z</published>
    <updated>2020-05-24T16:36:28.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>完整示意图为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200524225634.png" alt></p><p>整个过程需要进程的配合。结合之前的浏览器进程架构以及上面的示意图，整个过程的大概描述如下:</p><ul><li>首先，浏览器进程接收用户输入的 <code>URL</code>请求，浏览器进程便将该 URL 转发给网络进程。</li><li>然后，在网络进程中发起真正的 URL 请求</li><li>接着网络进程接收到了响应头数据，解析响应头数据，将数据转发给网络进程。</li><li>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航(<code>CommitNavigation</code>)”消息到渲染进程</li><li>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道</li><li>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程:“已经准备好接受和解析页面数据”</li><li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态</li></ul><a id="more"></a><p>其中，用户发出 URL 请求到页面开始解析到这个过程，就叫做导航。</p><h2 id="输入-URL-到页面显示"><a href="#输入-URL-到页面显示" class="headerlink" title="输入 URL 到页面显示"></a>输入 URL 到页面显示</h2><h3 id="1-用户输入"><a href="#1-用户输入" class="headerlink" title="1.用户输入"></a>1.用户输入</h3><p>用户在地址栏中输入一个查询关键字时，地址栏会判断输入到关键字是搜索内容，还是<strong>请求的 URL</strong>。</p><ul><li>搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带关键字的 URL。</li><li>如果判断输入内容符合 URL 规则，比如输入 <code>time.geekbang.org</code>，地址栏会根据规则，把这段内容加上协议，合成完成的 URL。</li></ul><p>当用户输入关键字并键入回车之后，当前页面即将被替换为新的页面，不过在这个流程继续之前，浏览器还是给当前页面一次执行 <code>beforeunload</code> 事件的机会。</p><p><code>beforeunload</code>事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否离开当前页面，比如表单当前还未完成，用户可以通过 <code>beforeunload</code> 事件来取消导航，让浏览器不再执行任何后序工作。</p><p>当前页面没有监听 <code>beforeunload</code> 事件或者同意了继续后续流程，那么浏览器便进入了下面状态:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200524233018.png" alt="image-20200524233018101"></p><p>RT，浏览器刚开始加载一个地址之后，标签页上的图标就进入了加载状态。但此时图中页面显示的仍然是之前打开的页面内容，并没有立即替换掉。因为需要等待提交文档阶段，页面内容才会被替换。</p><h3 id="2-URL请求流程"><a href="#2-URL请求流程" class="headerlink" title="2. URL请求流程"></a>2. URL请求流程</h3><p>首先，网络线查找本地是否有缓存，如果有，返回缓存资源给浏览器进程;如果在缓存中没有该资源，那就进入网络请求流程，第一步是先进行 <code>DNS</code> 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p><p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行，请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头，然后向服务器发送构建的请求信息。</p><p>服务端收到后，会生成响应数据(包括响应头，响应行，响应体等信息)，并发给网络进程。网络进程接收后，就开始解析响应头内容。</p><h4 id="1-重定向"><a href="#1-重定向" class="headerlink" title="(1) 重定向"></a>(1) 重定向</h4><p>在接收到服务端返回响应头之后，网络进程开始解析响应头，如果返回到状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 <code>Location</code> 字符里读取重定向地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重新开始。</p><p>利用我们用<code>curl</code>去请求<code>http://time.geekbang.org/</code> 会发现极客时间会通过重定向的方式把所有的 <code>HTTP</code> 请求转换为 <code>HTTPS</code> 请求。也就是说你用 <code>HTTP</code> 向极客时间服务器做请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头 location 字段换成 HTTPS 请求的地址。</p><p>如果请求 https 的，就会直接返回200了。</p><p>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p><h4 id="2-响应数据类型处理"><a href="#2-响应数据类型处理" class="headerlink" title="(2)响应数据类型处理"></a>(2)响应数据类型处理</h4><p>处理完跳转信息之后，浏览器会根据 <code>Content-Type</code> 来区分返回的数据类型(下载类型或者html页面)。</p><p>例如<code>Content-Type</code>字段是<code>text/html</code>，告诉浏览器服务器返回的数据是 HTML 格式。</p><p>不同 <code>Content-Type</code> 的后续处理流程也截然不同。如果 <code>Content-Type</code> 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 <code>URL</code> 请求的导航流程就此结束。但如果是 <code>HTML</code>，那么浏览器则会继续进行导航流程。由于 <code>Chrome</code> 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h4 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="(3)准备渲染进程"></a>(3)准备渲染进程</h4><p><code>Chrome</code> 会为每个页面分配一个渲染进程，意味着每开一个新页面都会配套创建一个新的渲染进程。</p><p>比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的 Chrome 的任务管理器截图：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525000749.png" alt="image-20200525000749288"></p><p>打开这三个页面都是运行在同一个渲染进程，进程 ID 是23601。</p><p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p><p><code>Chrome</code>的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开另一个页面，并且这两个页面属于同一站点(协议和根域名都相同)的话，那么新页面就会复用父页面的渲染进程。官方把这个默认策略叫 :<code>process-per-site-instance</code></p><p>如果不属于同一个站点，那么新页面就会开一个新的渲染进程。</p><p>总结来说，打开一个新页面的渲染策略是:</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程</li><li>从A打开B,A、B同一站点，那么B复用A的渲染进程;如果是其他情况，浏览器会为B创建一个新的渲染进程</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态。因为文档还在网络进程中，还没提交给渲染进程。</p><h4 id="4-提交文档"><a href="#4-提交文档" class="headerlink" title="(4)提交文档"></a>(4)提交文档</h4><p>提交文档指的是，浏览器进程将网络进程收到的 <code>HTML</code>数据提交给渲染进程，具体流程 :</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据，会和网络进程建立传输数据的“管道”</li><li>渲染进程接收到传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程</li><li>览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>浏览器确认提交之后，更新的内容如下:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525002733.png" alt="image-20200525002733357"></p><h4 id="5-渲染阶段"><a href="#5-渲染阶段" class="headerlink" title="(5)渲染阶段"></a>(5)渲染阶段</h4><p>一旦文档被提交了，渲染进程便开始页面解析和子资源加载。一旦页面生成完成，渲染进程会发消息给浏览器进程，浏览器进程接收到消息后，会停止标签图标上的加载动画。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200525003001.png" alt="image-20200525003001342"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li><li>Chrome 默认采用每个标签对应一个渲染进程，但是两个页面为同一站点，就会用一个渲染进程</li><li>浏览器的导航过程覆盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;完整示意图为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200524225634.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;整个过程需要进程的配合。结合之前的浏览器进程架构以及上面的示意图，整个过程的大概描述如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，浏览器进程接收用户输入的 &lt;code&gt;URL&lt;/code&gt;请求，浏览器进程便将该 URL 转发给网络进程。&lt;/li&gt;
&lt;li&gt;然后，在网络进程中发起真正的 URL 请求&lt;/li&gt;
&lt;li&gt;接着网络进程接收到了响应头数据，解析响应头数据，将数据转发给网络进程。&lt;/li&gt;
&lt;li&gt;浏览器进程接收到网络进程的响应头数据之后，发送“提交导航(&lt;code&gt;CommitNavigation&lt;/code&gt;)”消息到渲染进程&lt;/li&gt;
&lt;li&gt;渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道&lt;/li&gt;
&lt;li&gt;最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程:“已经准备好接受和解析页面数据”&lt;/li&gt;
&lt;li&gt;浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Node.js,来一打 Cpp 拓展》学习笔记- Node 模块原理解析 &amp;&amp; Cpp 模块优点</title>
    <link href="http://zoomdong.site/2020/05/23/cpp-node-2/"/>
    <id>http://zoomdong.site/2020/05/23/cpp-node-2/</id>
    <published>2020-05-23T05:56:34.000Z</published>
    <updated>2020-05-23T05:58:24.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要写C-拓展模块"><a href="#为什么要写C-拓展模块" class="headerlink" title="为什么要写C++拓展模块"></a>为什么要写C++拓展模块</h3><h4 id="C-比-JS-解释器高效"><a href="#C-比-JS-解释器高效" class="headerlink" title="C++ 比 JS 解释器高效"></a>C++ 比 JS 解释器高效</h4><p>相同意思的代码，在 JavaScript 解析器中执行 JavaScript 代码的效率通常比直接执行一个 C++ 编译好后的二进制文件要低。（这里指那些非并行、计算密集型的代码，因为模型不用，单线程下实现 C++ 的 Web 请求处理和有着异步 I/O 优势的 Node.js 下实现的 Web 请求处理也是不能相提并论的 —— Node.js底层使用了别的线程）</p><p>有个 <code>NBody</code>的例子，相同的代码，使用C++ 大约只需要<code>6-7s</code>，但使用<code>Node.JS</code>却需要<code>20s</code>左右，具体代码可以参看书中例子。</p><p>C++效率虽然高，但是所需要的维护成本和开发效率和 <code>Node.js</code> 也不在一个层次上。因此偶尔在一个整体使用 <code>Node.js</code> 开发的项目中使用 C++ 写一两个拓展也是一种很奇妙的体验。</p><a id="more"></a><h4 id="已有的Cpp轮子"><a href="#已有的Cpp轮子" class="headerlink" title="已有的Cpp轮子"></a>已有的Cpp轮子</h4><p>还有一种比较常见的使用Cpp拓展的原因是市面上或者手头上已经有一套C++的轮子，而且使用<code>Node</code> 再次实现一遍非常麻烦且不现实，这时就可以基于这个轮子包裹一层C++的拓展了，当然前提是项目的主体本身就是 <code>Node</code>。</p><p>综合以上两点，使用C++来写Node.js原生拓展的两大理由——性能和开发成本</p><p>对于有显著性能提升的情况，使用CPP来完成是很爽的，而对于已经存在的C++类库，那些难以迁移或者无法迁移的项目又何苦迁移，使用 Cpp 拓展也是件很有意思的事情。</p><h3 id="什么是-C-拓展"><a href="#什么是-C-拓展" class="headerlink" title="什么是 C++ 拓展"></a>什么是 C++ 拓展</h3><p>因为 Node.js 本身是基于 Chrome V8  引擎和 libuv,使用 C++ 进行开发的，因此自然能够轻松的对使用了特定 API 进行开发的 C++ 代码进行拓展，使其能够在 Node.js 中被 <code>require</code> 之后能够像调用 JavaScript 函数一样被调用。</p><h4 id="C-模块本质"><a href="#C-模块本质" class="headerlink" title="C++ 模块本质"></a>C++ 模块本质</h4><p>Node是基于C++开发的，因此所有底层头文件暴露的 API 也都是适用于 C++ 的。</p><p>当我们在Node.js中 require 一个模块的时候，其运行时会依次枚举后缀名进行一个寻址，其中就有后缀名为<code>*.node</code>的模块，这是一个 C++ 模块的二进制文件。</p><p>实际上编译好的C++模块除了后缀名是<code>*.node</code>之外，它其实就是一个系统的动态链接库。说得直白一点，这就相当于 Windows 下的 <code>*.dll</code>、Linux下的<code>*.so</code>以及 macOS 下的<code>*.dylib</code>。</p><p><strong>在 Node.js 中引入一个 C++ 模块的过程，实际上就是 Node.js 在运行时引入一个动态链接库的过程。</strong>运行的时候接受 js 代码中的调用，解析出来具体是拓展中的哪个函数需要被调用，在调用完成之后获得结果再通过运行时返回给 js 代码。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521232522.png" alt="image-20200521232522393"></p><p>调用 Node 的原生 C++ 函数和调用 C++ 拓展函数的区别就在于前者的代码会直接编译进 Node 可执行文件中，而后者的代码则位于一个动态链接库中。</p><h4 id="Node-模块加载原理"><a href="#Node-模块加载原理" class="headerlink" title="Node 模块加载原理"></a>Node 模块加载原理</h4><p>在开发 node 的经验中，Node.js 载入一个源码文件或者一个 C++ 拓展文件是通过 Node 中的 <code>require()</code> 函数实现的。这些被在于的文件单位或者粒度就是模块(<code>modules</code>)了。C++模块也被称为C++拓展了。</p><p>该函数既能载入 Node 的内部模块，也能载入 JS 模块以及 C++ 拓展。 </p><h5 id="node-js-入口"><a href="#node-js-入口" class="headerlink" title="node.js 入口"></a>node.js 入口</h5><p>Node.js在 C++ 代码层面的入口在源码<code>src/node_main.cc</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Disable stdio buffering, it interacts poorly with printf()</span></span><br><span class="line">  <span class="comment">// calls elsewhere in the program (e.g., any logging from V8.)</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> node::Start(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明进入 C++ 主函数之后直接调用了 node 这个命名空间中的 Start 函数，而这个函数位于 <code>src/node.cc</code></p><p>通过 Start 函数去层层查找,里面会有个 LoadEnviroment 函数:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521234826.png" alt="image-20200521234826877"></p><p>由于 Node 现在的代码和作者当时版本的源码有挺多的差别，因此我们直接按照书中的分析。</p><p>Node 执行 <code>lib/internal/bootstrap_node.js</code>文件来进行初始化启动，这里还没有<code>require</code>的概念。文件中的源码没有经过 <code>require()</code> 函数进行闭包操作，所以执行该文件之后得到的 <code>f_value</code> 就是 <code>bootsrap_node.js</code>文件中所实现的那个函数对象。</p><p>由于 V8 的值(包括对象、函数等)均继承自 Value 基类，所以在得到函数的 Value 实例之后需要将其转换成能用的 Function 对象，然后以 <code>env-&gt;process_object()</code> 为参数执行这个从<code>bootstap_node.js</code>中得到的函数。</p><p>那么我们就大致知道了Node的入口启动流程。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521235513.png" alt="image-20200521235513947"> </p><h5 id="process对象"><a href="#process对象" class="headerlink" title="process对象"></a>process对象</h5><p>前面提到执行 node 初始化函数时会传入 <code>env-&gt;process_object()</code>，而对应的 <code>lib/internal/bootstrap_node.js</code>文件中这个参数的含义其实就是 process 对象。</p><p>这里的这个process对象就是Node中我们经常使用的全局对象 process。这个 <code>env-&gt;process_object()</code>一些内容就是在<code>src/node.cc</code>中实现的。我们很容易查找到这个文件中的 <code>SetupProcessObject</code>函数。<img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200522000636.png" alt="image-20200522000636091"></p><p>这些列举的方法以及属性其实都基本是 <code>Node</code>文档中原本列出的 process 对象中暴露的 API 内容。</p><h5 id="几种模块的具体加载过程"><a href="#几种模块的具体加载过程" class="headerlink" title="几种模块的具体加载过程"></a>几种模块的具体加载过程</h5><p>前面说了一些 node 的入口相关文件之后，接下来将模块分为四个类型，分别介绍加载过程：</p><ul><li>C++ 核心模块</li><li>Node.js 内置模块</li><li>用户源码模块</li><li>C++拓展</li></ul><ol><li><p>C++ 核心模块</p><p>该模块在 node 源码中其实就是采用纯 Cpp 编写的，是并没有经过任何 js 代码封装的原生模块，有点类似于 C++ 拓展，区别在于之前说过的前者位于 node 的源码中并且编译进 node 的可执行二进制文件中，后者则通过动态链接库的形式存在。</p></li></ol><p>在介绍 C++ 核心模块的加载过程之前，先提一下前面出现过的 <code>process.binding</code>函数。它对应 <code>src/node.cc</code>文件中的<code>Binding</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Binding(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">  Environment* env = Environment::GetCurrent(args);</span><br><span class="line"></span><br><span class="line">  Local&lt;<span class="built_in">String</span>&gt; <span class="built_in">module</span> = args[<span class="number">0</span>]-&gt;ToString(env-&gt;isolate());</span><br><span class="line">  node::Utf8Value module_v(env-&gt;isolate(), <span class="built_in">module</span>);</span><br><span class="line"></span><br><span class="line">  Local&lt;<span class="built_in">Object</span>&gt; cache = env-&gt;binding_cache_object();</span><br><span class="line">  Local&lt;<span class="built_in">Object</span>&gt; exports;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache-&gt;Has(env-&gt;context(), <span class="built_in">module</span>).FromJust()) &#123;</span><br><span class="line">    exports = cache-&gt;Get(<span class="built_in">module</span>)-&gt;ToObject(env-&gt;isolate());</span><br><span class="line">    args.GetReturnValue().Set(exports);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append a string to process.moduleLoadList</span></span><br><span class="line">  <span class="comment">// 将一个字符串附加在 process.moduleLoadList 后面</span></span><br><span class="line">  char buf[<span class="number">1024</span>];</span><br><span class="line">  snprintf(buf, sizeof(buf), <span class="string">"Binding %s"</span>, *module_v);</span><br><span class="line"></span><br><span class="line">  Local&lt;<span class="built_in">Array</span>&gt; modules = env-&gt;module_load_list_array();</span><br><span class="line">  uint32_t l = modules-&gt;Length();</span><br><span class="line">  modules-&gt;<span class="built_in">Set</span>(l, OneByteString(env-&gt;isolate(), buf));</span><br><span class="line"></span><br><span class="line">  node_module* mod = get_builtin_module(*module_v);</span><br><span class="line">  <span class="keyword">if</span> (mod != nullptr) &#123;</span><br><span class="line">    exports = <span class="built_in">Object</span>::New(env-&gt;isolate());</span><br><span class="line">    <span class="comment">// Internal bindings don't have a "module" object, only exports.</span></span><br><span class="line">    <span class="comment">// 内置模块没有 module 对象，只有 exports</span></span><br><span class="line">    CHECK_EQ(mod-&gt;nm_register_func, nullptr);</span><br><span class="line">    CHECK_NE(mod-&gt;nm_context_register_func, nullptr);</span><br><span class="line">    Local&lt;Value&gt; unused = Undefined(env-&gt;isolate());</span><br><span class="line">    mod-&gt;nm_context_register_func(exports, unused,</span><br><span class="line">      env-&gt;context(), mod-&gt;nm_priv);</span><br><span class="line">    cache-&gt;<span class="built_in">Set</span>(<span class="built_in">module</span>, exports);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcmp(*module_v, <span class="string">"constants"</span>)) &#123;</span><br><span class="line">    exports = <span class="built_in">Object</span>::New(env-&gt;isolate());</span><br><span class="line">    DefineConstants(env-&gt;isolate(), exports);</span><br><span class="line">    cache-&gt;<span class="built_in">Set</span>(<span class="built_in">module</span>, exports);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcmp(*module_v, <span class="string">"natives"</span>)) &#123;</span><br><span class="line">    exports = <span class="built_in">Object</span>::New(env-&gt;isolate());</span><br><span class="line">    DefineJavaScript(env, exports);</span><br><span class="line">    cache-&gt;<span class="built_in">Set</span>(<span class="built_in">module</span>, exports);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    char errmsg[<span class="number">1024</span>];</span><br><span class="line">    snprintf(errmsg,</span><br><span class="line">             sizeof(errmsg),</span><br><span class="line">             <span class="string">"No such module: %s"</span>,</span><br><span class="line">             *module_v);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;ThrowError(errmsg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  args.GetReturnValue().Set(exports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>Local&lt;String&gt; module = args[0]-&gt;Tostring(env -&gt; isolate());</code>和<code>node::Utf8Value module_v(env-&gt;isolate(), module);</code> 表示从参数中获得文件标识符(或者文件名)的字符串并赋值给<code>module-v</code>。</p><p>在得到标识符字符串之后,node.js通过<code>node_module* mod = get_builtin_module(*module_v);</code> 这句代码获取<code>C++</code>核心模块，例如未经源码<code>lib</code> 目录下的 js 文件封装的<code>file</code>模块。我们注意到这里获取核心模块用的是一个<code>get_builtin_module</code>函数，这个函数的内部工作就是在一个名为<code>modlist_buildin</code>的<code>C++</code>核心模块链表上对比文件标识，从而返回相对应的模块。</p><p>追根溯源，这些 <code>C++</code> 核心模块则是在<code>node_module_register</code>函数中被逐一注册进链表的，可以参考下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> = <span class="title">reinterpret_cast</span>&lt;struct node_module*&gt;(<span class="title">m</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_BUILTIN) &#123;</span><br><span class="line">    mp-&gt;nm_link = modlist_builtin;</span><br><span class="line">    modlist_builtin = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123;</span><br><span class="line">    <span class="comment">// "Linked" modules are included as part of the node project.</span></span><br><span class="line">    <span class="comment">// Like builtins they are registered *before* node::Init runs.</span></span><br><span class="line">    mp-&gt;nm_flags = NM_F_LINKED;</span><br><span class="line">    mp-&gt;nm_link = modlist_linked;</span><br><span class="line">    modlist_linked = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    modpending = mp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct node_module* <span class="title">get_builtin_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mp = modlist_builtin; mp != <span class="literal">nullptr</span>; mp = mp-&gt;nm_link) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mp-&gt;nm_modname, name) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CHECK(mp == <span class="literal">nullptr</span> || (mp-&gt;nm_flags &amp; NM_F_BUILTIN) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>node_module_register</code>函数清晰表达了，如果传入待注册模块标示位是内置模块<code>(mp-&gt;nm_flags &amp; NM_F_BUILTIN)</code>，就将其加入 <code>C++</code>核心模块的链表中；否则认为是其他模块。</p><p>在<code>src/node.h</code>中有一个宏是用于注册 <code>C++</code>核心模块的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="string">"C"</span> &#123;                                                        \</span><br><span class="line">    <span class="keyword">static</span> node::node_module _module =                                \</span><br><span class="line">    &#123;                                                                 \</span><br><span class="line">      NODE_MODULE_VERSION,                                            \</span><br><span class="line">      flags,                                                          \</span><br><span class="line">      <span class="literal">NULL</span>,                                                           \</span><br><span class="line">      __FILE__,                                                       \</span><br><span class="line">      <span class="literal">NULL</span>,                                                           \</span><br><span class="line">      (node::addon_context_register_func) (regfunc),                  \</span><br><span class="line">      NODE_STRINGIFY(modname),                                        \</span><br><span class="line">      priv,                                                           \</span><br><span class="line">      <span class="literal">NULL</span>                                                            \</span><br><span class="line">    &#125;;                                                                \</span><br><span class="line">    NODE_C_CTOR(_register_ ## modname) &#123;                              \</span><br><span class="line">      node_module_register(&amp;_module);                                 \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE(modname, regfunc)                                 \</span></span><br><span class="line">  NODE_MODULE_X(modname, regfunc, <span class="literal">NULL</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE(modname, regfunc)                   \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, <span class="literal">NULL</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_BUILTIN(modname, regfunc)           \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, <span class="literal">NULL</span>, NM_F_BUILTIN)   \</span><br></pre></td></tr></table></figure><p>结合之前<code>node_module_register</code>函数和这个<code>src/node.h</code>中的宏定义，我们发现只要<code>Node.js</code>在<code>C++</code>源码中调用<code>NODE_MODULE_CONTEXT_AWARE_BUILTIN</code>这个宏，就有一个模块会被注册进 <code>Node.js</code> 的 <code>C++</code> 核心模块链表。</p><p>那么什么时候会调用这个宏呢？在 <code>src/node.cc</code>中会给出结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_MODULE_CONTEXT_AWARE_BUILTIN(fs, node::InitFs)</span><br></pre></td></tr></table></figure><p>这个宏展开后的结果就是 <code>NODE_MODULE_CONTEXT_AWARE_X</code></p><p>至此我们就能明白，基本上在每个 <code>C++</code> 核心模块的源码末尾都会有一个宏调用将该模块注册进 <code>C++</code> 核心模块的链表中，以供执行 <code>process.binding</code> 时获取。</p><ol start="2"><li>Node.js 内置模块</li></ol><p><code>node</code> 内置模块基本上等同于官方文档中放出的那些文档。这些模块大多是在源码 <code>lib</code> 目录下以同名 <code>JavaScript</code> 代码的形式被实现，而且很多 <code>node.js</code> 内置模块实际上都是对 <code>C++</code> 核心模块的一个封装。</p><blockquote><p>例如 <code>lib/crypto.js</code> 中就有一段 <code>const binding = process.binding(&#39;crypto&#39;);</code> 这样的代码，它里面很多内容都是基于 <code>C++</code> 核心模块中的 <code>crypto</code> 进行实现的。</p></blockquote><p>接下来先看<code>Node.js</code>的启动脚本，<code>lib/internal/bootstrap_node.js</code>中。代码最下面有一个 <code>NativeModule</code> 类的声明。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130136.png" alt="image-20200523130136554"></p><p>这个<code>NativeModule</code>类就是<code>Node.js</code>内置模块的相关处理类了，他有一个叫做<code>require</code> 的静态函数，当其参数 id 值为 ‘native_module’ 时返回的是它本身，否则进入 <code>nativeModule.compile</code> 进行编译。</p><p>进而目光转向 <code>compile</code>函数，第一行代码就是获取该模块的源码:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130535.png" alt="image-20200523130535026"> </p><p>源码是通过<code>NativeModule.getSource</code>获取的，<code>NativeModule.getSource</code>函数返回的是<code>NativeModule._source</code> 数组中的相应内容。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130647.png" alt="image-20200523130647750"></p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130727.png" alt="image-20200523130727713"></p><p>而<code>_source</code>则是通过<code>process.binging</code>这个函数获取(<code>Binding</code> 这个函数在<code>node.cc</code>中)过来的。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523130900.png" alt="image-20200523130900236"></p><p>执行<code>process.binging(&#39;natives&#39;)</code>会返回<code>DefineJavaScript</code>函数中的处理内容。</p><p>而这个<code>DefineJavaScript</code>函数会遍历一遍<code>natives</code>数组中的内容，然后加入到一个对象中，对象名的 <code>key</code> 为源码文件标识符，<code>value</code>是源码本体字符串。这里我们会发现整个项目都找不到<code>natives</code> 数组。</p><p><strong>这里其实就可以知道，node中的内置模块本来在 lib 目录下，但是加载的时候却在 C++ 源码中以 natives 变量的形式存在，那么可以证明中间多了一个编译层的过程。</strong></p><p>打开<code>node-gyp</code>文件夹下面的<code>node.gyp</code>配置文件。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523132014.png" alt="image-20200523132014859"></p><p>其中有一步的目标配置是<code>node_js2c</code>，然后去看<code>js2c.py</code>文件。</p><p>这是一个 <code>py</code>脚本，主要作用是把<code>lib</code>下的<code>js</code>文件转成<code>src/node_natives.h</code>文件。</p><p>这个<code>src/node_natives.h</code>文件会在<code>node</code>编译之前完成，这样在编译到<code>src/node_javascript.cc</code>时他需要的<code>src/node_natives.h</code>有头文件就有了。</p><p><code>src/node_natives.h</code>源文件经过<code>js2c.py</code>转换后，会以一种之前说过的 <code>natives</code>对象存在。</p><p><strong>在node中调用NativeModule.require的时候，会根据传入的文件标识来返回响应的 JavaScript 源文件内容，例如<code>dgram</code> 对应<code>lib/dgram.js</code>中的js代码字符串</strong></p><p>解决了 编译进 node 二进制文件中的 js 代码的问题之后，重新回到<code>NativeModule.compile</code>函数中来，<img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200523132837.png" alt="image-20200523132837343"></p><p>他会在刚获取到的内置模块js源码字符串前后用<code>(function (exports, require, module, __filename, _dirname)) {</code> 和 <code>});</code> 包裹 从而形成一段闭包代码，放在<code>vm</code>(<code>vm</code>模块用于创建独立运行的沙箱体制，通过<code>vm</code>，js源码可以被编译后立即执行或者编译保存下来稍后执行。是<code>node</code>中的核心模块，支撑了 <code>require</code>方法和<code>node</code>的运行机制。)中执行，并传入事先准备好的<code>module</code>和<code>exports</code>对象供其导出。</p><p>如此一来，内置模块就完成了加载。</p><ol start="3"><li>用户源码模块</li></ol><p>用户源码模块指用户在项目中的 node 源码，以及所使用的第三方包中的模块。<strong>非node内置模块的js源码模块话就是用户源码模块</strong></p><p>这些模块被使用时需要被<code>require()</code>函数加载。</p><p>与内置模块类似，每个用户源码模块都会被加上一个闭包的头尾，然后<code>node.js</code>执行这个闭包产生的结果。</p><p>其载入流程大概是:</p><ul><li>开发者调用<code>require()</code>(某种意义上等同于调用<code>Module._load</code>)</li><li>闭包化对应文件的源码，并传入相关参数执行(有缓存就直接返回)</li><li>通常在执行过程中<code>module.exports</code>或者<code>exports</code>会被赋值</li><li><code>Module.prototype._load</code>在最后返回这个模块的<code>exports</code>给上游</li></ul><ol start="4"><li>C++拓展</li></ol><p>​    To be continued…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要写C-拓展模块&quot;&gt;&lt;a href=&quot;#为什么要写C-拓展模块&quot; class=&quot;headerlink&quot; title=&quot;为什么要写C++拓展模块&quot;&gt;&lt;/a&gt;为什么要写C++拓展模块&lt;/h3&gt;&lt;h4 id=&quot;C-比-JS-解释器高效&quot;&gt;&lt;a href=&quot;#C-比-JS-解释器高效&quot; class=&quot;headerlink&quot; title=&quot;C++ 比 JS 解释器高效&quot;&gt;&lt;/a&gt;C++ 比 JS 解释器高效&lt;/h4&gt;&lt;p&gt;相同意思的代码，在 JavaScript 解析器中执行 JavaScript 代码的效率通常比直接执行一个 C++ 编译好后的二进制文件要低。（这里指那些非并行、计算密集型的代码，因为模型不用，单线程下实现 C++ 的 Web 请求处理和有着异步 I/O 优势的 Node.js 下实现的 Web 请求处理也是不能相提并论的 —— Node.js底层使用了别的线程）&lt;/p&gt;
&lt;p&gt;有个 &lt;code&gt;NBody&lt;/code&gt;的例子，相同的代码，使用C++ 大约只需要&lt;code&gt;6-7s&lt;/code&gt;，但使用&lt;code&gt;Node.JS&lt;/code&gt;却需要&lt;code&gt;20s&lt;/code&gt;左右，具体代码可以参看书中例子。&lt;/p&gt;
&lt;p&gt;C++效率虽然高，但是所需要的维护成本和开发效率和 &lt;code&gt;Node.js&lt;/code&gt; 也不在一个层次上。因此偶尔在一个整体使用 &lt;code&gt;Node.js&lt;/code&gt; 开发的项目中使用 C++ 写一两个拓展也是一种很奇妙的体验。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Node.js,来一打 Cpp 拓展》学习笔记-环境安装</title>
    <link href="http://zoomdong.site/2020/05/22/cpp-node-1/"/>
    <id>http://zoomdong.site/2020/05/22/cpp-node-1/</id>
    <published>2020-05-21T16:16:01.000Z</published>
    <updated>2020-05-23T07:41:09.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><ul><li><p>电脑环境: macOS 10.15.4</p></li><li><p>安装好<code>xcode</code></p></li><li>安装<code>node-gyp</code></li><li>自带<code>node</code></li></ul><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521220817.png" alt="image-20200521220817431"></p><a id="more"></a><h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><ol><li><p><code>node-gyp install</code>将 <code>Node.js</code> 源码的一些头文件下载到本地目录。</p></li><li><p>目录结构为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521221347.png" alt="image-20200521221347878"></p></li></ol><p>然后找到官方的 <a href="https://github.com/XadillaX/nyaa-nodejs-demo" target="_blank" rel="noopener">repo</a></p><p>进到<code>1.first build</code> 目录中去，可以在目录下执行下面的命令:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521221950.png" alt="image-20200521221950469"></p><ul><li><code>node-gyp configure</code>生成一些构建源码的项目文件。这一步会生成一个<code>build</code>目录出来里面有<code>Makefile</code>文件和一些必要的配置文件</li><li><code>node-gyp build</code>用于将当前所在目录的模块进行重构，将Cpp代码编译成二进制文件。这时会在<code>build/Release/</code> 目录下生成一个<code>first.node</code>文件出来</li></ul><p>然后可以在命令行工具里面使用<code>node</code>环境来引入我们构建出来的模块:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521222531.png" alt="image-20200521222531450"></p><ul><li><code>node-gyp clean</code> 用于清理生成的构建文件 &amp; <code>out</code>目录。</li></ul><p>当然有个懒人命令 <code>node-gyp rebuild</code> 能够依次去执行<code>node-gyp clean</code>、<code>node-gyp configure</code>、<code>node-gyp build</code>。</p><p><strong><code>node-gyp</code>的构建原理:在安装  C++ 原生模块时，使用 <code>GYP</code> 通过一个<code>binding.gyp</code>文件来构建各系统所需要的<code>C++</code>项目文件(mac下面是<code>makefile</code>文件)</strong>。</p><p> 基于上面的原理，其实nodejs里面其他的cpp的构建工具都大同小异，只不过<code>node-gyp</code> 是官方支持，所以不需要嵌入任何的脚本，其他构建工具需要在<code>package.json</code>的<code>scripts</code>中加入一些脚本使其在包安装阶段能够执行构建。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础环境&quot;&gt;&lt;a href=&quot;#基础环境&quot; class=&quot;headerlink&quot; title=&quot;基础环境&quot;&gt;&lt;/a&gt;基础环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;电脑环境: macOS 10.15.4&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装好&lt;code&gt;xcode&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;node-gyp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自带&lt;code&gt;node&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200521220817.png&quot; alt=&quot;image-20200521220817431&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的回溯模板题目</title>
    <link href="http://zoomdong.site/2020/05/20/dfs-template/"/>
    <id>http://zoomdong.site/2020/05/20/dfs-template/</id>
    <published>2020-05-20T04:00:00.000Z</published>
    <updated>2020-05-24T16:34:50.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法解题框架"><a href="#回溯算法解题框架" class="headerlink" title="回溯算法解题框架"></a>回溯算法解题框架</h2><p>解决一个回溯问题，需要考虑以下三个问题:</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表：当前能做的选择</li><li>结束条件：达到决策树的底层无法在做出选择</li></ul><p>代码框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrap(路径，选择列表):</span><br><span class="line">  if 满足结束条件:</span><br><span class="line">    result.add(路径)</span><br><span class="line">    return</span><br><span class="line">  for 选择 in 选择列表:</span><br><span class="line">    做选择</span><br><span class="line">    backtrap(路径,选择列表)</span><br><span class="line">    撤销选择</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>核心其实就是for循环里面的递归，在递归调用之前“做出一个选择”，在递归调用之后”撤销选择“</strong>。</p><p>通过题目来做一些理解吧</p><p>明人不说暗话，直接上全排列:</p><h2 id="lc46"><a href="#lc46" class="headerlink" title="lc46"></a>lc46</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><p>这题就是一个很典型的回溯板子</p><p>因为这里我们需要撤销一下之前的走过的选项，所以<strong>就需要递归前选元素，递归之后再撤销刚才的选择</strong>。</p><p>直接看一波代码吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> temp = []</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">temp, nums</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (temp.length === nums.length) &#123;</span><br><span class="line">          res.push([...temp])</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">          <span class="keyword">if</span>(temp.includes(item)) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 做出选择</span></span><br><span class="line">          temp.push(item)</span><br><span class="line">          <span class="comment">// 回溯一波</span></span><br><span class="line">          dfs(temp, nums)</span><br><span class="line">          <span class="comment">// 回溯走完之后把选择的元素pop走</span></span><br><span class="line">          temp.pop()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], nums)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc784"><a href="#lc784" class="headerlink" title="lc784"></a>lc784</h2><p>题目链接:<a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-case-permutation/</a></p><p>这题其实也是个回溯。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">var letterCasePermutation = <span class="keyword">function</span>(S) &#123;</span><br><span class="line">   let res = []</span><br><span class="line">   S = S.split(<span class="string">''</span>)</span><br><span class="line">   let <span class="keyword">temp</span> = []</span><br><span class="line">   const dfs = (<span class="keyword">temp</span>, S,<span class="keyword">index</span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">index</span> === S.length) &#123;</span><br><span class="line">           res.push(S.<span class="keyword">join</span>(<span class="string">''</span>))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果当前字符是英文字母，那么就进行一波回溯操作</span><br><span class="line">       <span class="keyword">if</span>((<span class="string">'A'</span> &lt;=S[<span class="keyword">index</span>]&amp;&amp; S[<span class="keyword">index</span>] &lt;= <span class="string">'Z'</span>) || (<span class="string">'a'</span> &lt;= S[<span class="keyword">index</span>] &amp;&amp; S[<span class="keyword">index</span>] &lt;=<span class="string">'z'</span>)) &#123;</span><br><span class="line">           S[<span class="keyword">index</span>] = S[<span class="keyword">index</span>].toLowerCase()</span><br><span class="line">           dfs(<span class="keyword">temp</span>, S, <span class="keyword">index</span> + <span class="number">1</span>)</span><br><span class="line">           S[<span class="keyword">index</span>] = S[<span class="keyword">index</span>].toUpperCase()</span><br><span class="line">           dfs(<span class="keyword">temp</span>, S, <span class="keyword">index</span> + <span class="number">1</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           // 如果是数字，直接去递归就好了</span><br><span class="line">           dfs(<span class="keyword">temp</span>, S, <span class="keyword">index</span> + <span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   dfs(<span class="keyword">temp</span>, S, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="lc51-n皇后问题"><a href="#lc51-n皇后问题" class="headerlink" title="lc51 n皇后问题"></a>lc51 n皇后问题</h3><p>题目链接:<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><p>规则:有个 N * N 的棋盘，让你放置 N 个皇后，使他们不能互相攻击。</p><p>PS: 攻击的规则是皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上是和全排列差不多的，决策树的每一层表示棋盘上的每一行;每个节点都可以做出的选择是，在该行的任意一列放置一个皇后:</p><p>先写一波伪代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> solve = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// . 表示空盘，Q表示皇后，初始化空棋盘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">      board[i][j] = <span class="string">'.'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> backtrap = <span class="function">(<span class="params">board, row</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row === board.length) &#123;</span><br><span class="line">      res.push(board)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> n = board[row].length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">      <span class="comment">// 不符合规定的选择直接pass掉</span></span><br><span class="line">      <span class="keyword">if</span> (!isValid(board, row, col)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 做出选择</span></span><br><span class="line">      board[row][col] = <span class="string">'Q'</span></span><br><span class="line">      <span class="comment">// 进入下一行决策</span></span><br><span class="line">      backtrap(board, row + <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 撤销掉之前的选择</span></span><br><span class="line">      board[row][col] = <span class="string">'.'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backtrap(board, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要部分的代码其实和全排列差不多，<code>isValid</code>函数的实现为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isvalid = <span class="function">(<span class="params">board, row, col</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = board.length</span><br><span class="line">  <span class="comment">// 检查当前列是否有皇后</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(board[i][col] === <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查右上是否有皇后</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col + <span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n;i--;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j] === <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查左上是否有皇后</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = row - <span class="number">1</span>,j=col - <span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>;i--,j--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j] === <span class="string">'Q'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lc-水域大小"><a href="#lc-水域大小" class="headerlink" title="lc 水域大小"></a>lc 水域大小</h2><p>这题其实是个典型的dfs找联通块的题目，有8个方向:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">land</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pondSizes = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = grid.length</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> n = grid[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">grid, i, j, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = res</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, res)</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, res)</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j + <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j - <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j + <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j - <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, res)</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, res)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(grid, i, j, res--)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        hash.set(grid[i][j], hash.has(grid[i][j]) ? hash.get(grid[i][j]) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ret = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> hash) &#123;</span><br><span class="line">    ret.push(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(</span></span><br><span class="line"><span class="comment">//   pondSizes([</span></span><br><span class="line"><span class="comment">//     [0, 2, 1, 0],</span></span><br><span class="line"><span class="comment">//     [0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">//     [1, 1, 0, 1],</span></span><br><span class="line"><span class="comment">//     [0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">//   ]),</span></span><br><span class="line"><span class="comment">// )</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回溯算法解题框架&quot;&gt;&lt;a href=&quot;#回溯算法解题框架&quot; class=&quot;headerlink&quot; title=&quot;回溯算法解题框架&quot;&gt;&lt;/a&gt;回溯算法解题框架&lt;/h2&gt;&lt;p&gt;解决一个回溯问题，需要考虑以下三个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径：也就是已经做出的选择&lt;/li&gt;
&lt;li&gt;选择列表：当前能做的选择&lt;/li&gt;
&lt;li&gt;结束条件：达到决策树的底层无法在做出选择&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码框架：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def backtrap(路径，选择列表):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if 满足结束条件:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result.add(路径)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for 选择 in 选择列表:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    做选择&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    backtrap(路径,选择列表)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    撤销选择&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-http请求流程</title>
    <link href="http://zoomdong.site/2020/05/19/broswer-3/"/>
    <id>http://zoomdong.site/2020/05/19/broswer-3/</id>
    <published>2020-05-19T12:27:08.000Z</published>
    <updated>2020-05-20T15:06:05.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-请求流程"><a href="#http-请求流程" class="headerlink" title="http 请求流程"></a>http 请求流程</h2><p>HTTP协议，正是建立在 TCP 连接的基础之上。HTTP是一种允许浏览器上服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件。http也是浏览器使用最多的最广的协议。</p><h2 id="浏览器端发起http请求"><a href="#浏览器端发起http请求" class="headerlink" title="浏览器端发起http请求"></a>浏览器端发起http请求</h2><p>如果你在浏览器里面输入一个url，浏览器会完成哪些动作呢？</p><h3 id="1-构建请求"><a href="#1-构建请求" class="headerlink" title="1.构建请求"></a>1.构建请求</h3><p>首先，浏览器构建请求行信息，构建好后浏览器发起请求。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> /<span class="keyword">index</span>.html HTTP1<span class="number">.1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-查找缓存"><a href="#2-查找缓存" class="headerlink" title="2.查找缓存"></a>2.查找缓存</h3><p>在真正发起请求之前，浏览器会先在浏览器缓存中查询是否有需要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</strong></p><p>浏览器发现请求的资源已经有缓存的副本，它会直接拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器里面去下载。这样的好处有：</p><ul><li>缓解服务端压力，提升性能(获取资源的耗时更短了)</li><li>对于网站来说，缓存时实现快速资源加载的重要组成部分</li></ul><p>如果缓存失败，就会进入网络请求过程了。</p><h3 id="3-准备-IP-地址和端口"><a href="#3-准备-IP-地址和端口" class="headerlink" title="3.准备 IP 地址和端口"></a>3.准备 IP 地址和端口</h3><p>浏览器使用HTTP作为应用层协议，用来封装请求的文本信息；并使用<strong>TCP/IP 做传输层协议</strong>将它发到网络上去</p><p>，所以在HTTP开始工作之前，浏览器需要通过TCP与服务器先建立连接。HTTP 的内容是通过TCP的<strong>传输数据阶段来实现的</strong>。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519095343.png" alt="image-20200519095343595"></p><p>在上一节中，有讲到数据包都是通过 IP 地址传输给接受方。由于 IP 地址是数学标识，比较难记，使用域名就会容易记忆，所以基于域名和IP的映射关系又出现了一套服务，负责把域名和IP地址做一一映射的关系。这套服务就叫做“域名系统”，简称<code>DNS</code>。</p><p>所以这样推导下来，<strong>第一步浏览器会请求 DNS 返回域名对应的IP。</strong>浏览器也提供DNS数据缓存服务，如果某个域名解析过了，那么浏览器就会缓存解析的结果，下次查询的时候可以直接使用。</p><p>拿到IP之后，就会去获取端口号，一般在没有指明端口的情况下，HTTP默认端口号是80。</p><h3 id="4-等待TCP队列"><a href="#4-等待TCP队列" class="headerlink" title="4.等待TCP队列"></a>4.等待TCP队列</h3><p>IP地址和端口都准备好的情况下，也不会直接建立 TCP 链接，根据<code>Chrome</code>的机制，同一个域名同时最多只能建立 6 个 TCP 连接。如果同一域名下同时有 10 个请求，其中 4 个请求就会进入排队等待状态，直到进行中的请求结束。</p><p>如果当前请求数量小于 6，就会直接进入下一步连接。</p><h3 id="5-建立TCP连接"><a href="#5-建立TCP连接" class="headerlink" title="5.建立TCP连接"></a>5.建立TCP连接</h3><p>排队等待结束之后，就可和服务器快乐握手了。过程参考上一篇文章。</p><h3 id="6-发送HTTP请求"><a href="#6-发送HTTP请求" class="headerlink" title="6.发送HTTP请求"></a>6.发送HTTP请求</h3><p>一旦建立了 TCP 链接，浏览器就可以和服务器通信了。而 HTTP 中的数据正是在这个通信过程中完成。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519200612.png" alt="image-20200519200612664"></p><p>浏览器会向服务器发送<strong>请求头</strong>，它包含了<strong>请求方法、请求 URI 和 HTTP 协议版本</strong></p><p>具体参数含义可自行百度。</p><h3 id="7-服务端处理-HTTP-请求流程"><a href="#7-服务端处理-HTTP-请求流程" class="headerlink" title="7.服务端处理 HTTP 请求流程"></a>7.服务端处理 HTTP 请求流程</h3><h4 id="1-返回请求"><a href="#1-返回请求" class="headerlink" title="1. 返回请求"></a>1. 返回请求</h4><p>服务器处理结束之后，就会把数据返回给浏览器。可以通过工具软件 <code>curl</code> 来查看返回的请求数据，具体使用方法是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">curl</span> <span class="selector-tag">-i</span> <span class="selector-tag">baidu</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>返回的数据格式为:</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519201116.png" alt="image-20200519201116461"></p><p>首先会返回响应行。包括有协议版本和状态码。</p><p>服务器会通过状态码告诉浏览器处理结果。</p><p>发送完响应头之后，服务器就可以继续发送响应体数据，一般里面会包括 HTML 的实际内容。</p><h4 id="2-断开连接"><a href="#2-断开连接" class="headerlink" title="2.断开连接"></a>2.断开连接</h4><p>一般情况下，服务端返回了数据后，就会关闭 TCP 连接。不过浏览器或者服务器在其头信息中加入了:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Connection</span>: <span class="meta">keep</span>-Alive</span><br></pre></td></tr></table></figure><p>这样在发送之后就仍然可以保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。<strong>保持 TCP 连接可以省去下次请求时需要连接的时间，提升资源加载速度。 </strong></p><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3.重定向"></a>3.重定向</h3><p>到这里请求流程似乎就结束了，不过还有种情况时需要考虑的，例如我们打开<code>geekbang.org</code>之后，最终的页面地址是<code>https://www.geekbang.org</code></p><p>两个url不同的原因是因为会有个重定向的操作。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -<span class="literal">I</span> geekbang.org // 大写 <span class="literal">I</span> 表示只需要响应头和响应行数据，不需要响应体</span><br></pre></td></tr></table></figure><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200519202211.png" alt="image-20200519202211622"></p><p>极客时间上还有个问题解答，可以去看一看:<a href="https://time.geekbang.org/column/article/116588" target="_blank" rel="noopener">https://time.geekbang.org/column/article/116588</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http-请求流程&quot;&gt;&lt;a href=&quot;#http-请求流程&quot; class=&quot;headerlink&quot; title=&quot;http 请求流程&quot;&gt;&lt;/a&gt;http 请求流程&lt;/h2&gt;&lt;p&gt;HTTP协议，正是建立在 TCP 连接的基础之上。HTTP是一种允许浏览器上服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件。http也是浏览器使用最多的最广的协议。&lt;/p&gt;
&lt;h2 id=&quot;浏览器端发起http请求&quot;&gt;&lt;a href=&quot;#浏览器端发起http请求&quot; class=&quot;headerlink&quot; title=&quot;浏览器端发起http请求&quot;&gt;&lt;/a&gt;浏览器端发起http请求&lt;/h2&gt;&lt;p&gt;如果你在浏览器里面输入一个url，浏览器会完成哪些动作呢？&lt;/p&gt;
&lt;h3 id=&quot;1-构建请求&quot;&gt;&lt;a href=&quot;#1-构建请求&quot; class=&quot;headerlink&quot; title=&quot;1.构建请求&quot;&gt;&lt;/a&gt;1.构建请求&lt;/h3&gt;&lt;p&gt;首先，浏览器构建请求行信息，构建好后浏览器发起请求。&lt;/p&gt;
&lt;figure class=&quot;highlight pgsql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;GET&lt;/span&gt; /&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;.html HTTP1&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-网络数据包的传输</title>
    <link href="http://zoomdong.site/2020/05/18/broswer-2/"/>
    <id>http://zoomdong.site/2020/05/18/broswer-2/</id>
    <published>2020-05-18T06:23:54.000Z</published>
    <updated>2020-05-18T06:24:59.682Z</updated>
    
    <content type="html"><![CDATA[<p>衡量 Web 页面性能有个重要的指标叫做:<code>FP</code>(First Paint),是指从<strong>页面加载到首次开始绘制的时长</strong>。更少的FP意味着更多的PV，更高的参与度、以及转换率。影响其的一个很重要的因素就是<strong>网络加载速度</strong>。</p><p>想要优化网页的加载速度，需要对网络有一个深入的认识。</p><h2 id="数据包的传输过程"><a href="#数据包的传输过程" class="headerlink" title="数据包的传输过程"></a>数据包的传输过程</h2><p><strong>互联网实际是一套理论和协议组成的体系架构。</strong>其中，因为有了协议这一众所周知的规则和标准，各方都同意使用 的前提下，那么它们的通信之间将变得毫无障碍。</p><p>互联网中的数据是通过数据包来传输的。发送的数据很大的话，会被拆成很多小的包来传输。例如音频数据就并不是一个大的文件。</p><a id="more"></a><h3 id="1-IP-数据包送往目标主机"><a href="#1-IP-数据包送往目标主机" class="headerlink" title="1.IP:数据包送往目标主机"></a>1.IP:数据包送往目标主机</h3><p>如果想把数据包从主机 A 发送给 B，在传输之前，数据包会有B的IP地址信息，这样在传输过程中才能正确寻址。数据包上还会附加上A的IP信息，有了这些信息B才可以回复信息给主机A。这些信息都会放在一个叫IP头都数据结构里面，它是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等。<a href="[https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE](https://zh.wikipedia.org/wiki/传输控制协议">具体了解</a>)</p><p>为了便于理解，可以把网络简单分成三层结构：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518093817.png" alt="image-20200518093817351"></p><p>过程是这样的：</p><ul><li>上层将有“极客时间”的数据交给网络层</li><li>网络层再将IP头附加到数据包上，组成新的<strong>IP数据包</strong>，交给底层</li><li>底层通过物理网络将数据包传给B</li><li>数据包被传输到主机B的网络层，主机B拆开数据包的IP信息，并把拆开的数据部分交给上层</li><li>最后，数据就到主机B的上层了</li></ul><h3 id="UDP-数据包送到应用层序"><a href="#UDP-数据包送到应用层序" class="headerlink" title="UDP:数据包送到应用层序"></a>UDP:数据包送到应用层序</h3><p>IP是底层的协议，它只负责传送数据包到对方的电脑，但是对方电脑不知道把数据包交给哪一个程序。因此有了基于IP之上开发能和应用打交道的协议，最常见的就是<strong>“用户数据协议”(User Datagram Protocol)</strong>,简称<strong>UDP</strong>。</p><p>UDP中最重要的信号是<strong>端口号</strong>，每个想访问网络的应用程序都得绑定一个端口号。通过端口号就能把指定的数据包发给指定的应用程序，<strong>IP通过地址信息来发包到主机，UDP根据端口号来发包到应用程序。</strong>和IP头一样，端口号会被装进UDP头里面，UDP头再和原始的数据包合并成新的UDP数据包。UDP同时也包括源端口号和目标端口号。</p><p>为了支持UDP，现在的网络的三层传输结构可以扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518094858.png" alt="image-20200518094858296"></p><p>现在的过程就成了:</p><ul><li>上层将含有传输信息的数据包给传输层</li><li>传输层会在数据包上加上UDP头，组成一个UDP的数据包，再将UDP包交给网络层</li><li>网络层附加IP头，组成IP数据包给底层</li><li>数据包传输到主机B的网络层并被解析，部分数据被丢（IP）</li><li>传输层中，数据包中的UDP头被拆开，被根据UDP中提供的端口信息，把数据给应用程序</li><li>最后数据包到了B的上层应用程序</li></ul><p>使用UDP发送数据的时候，有各种因素会导致数据包出错，UDP可以校验数据是否正确，但错误的包并不会提供重发的机制，只是丢弃当前包，而且在发送之后也不知道能否达到目的地。</p><p><strong>UDP不能保证数据可靠，但是传输速度却很快。</strong></p><h3 id="TCP：数据完整送达应用程序"><a href="#TCP：数据完整送达应用程序" class="headerlink" title="TCP：数据完整送达应用程序"></a>TCP：数据完整送达应用程序</h3><p>对于一些要求数据传输可靠的应用程序，例如邮件和浏览器请求，UDP带来的问题:</p><ul><li>数据包在传输过程中容易丢失</li><li>大文件被拆成许多小的数据包来传输，小的数据包过不同的路由，不同时间到接收端，UDP协议不知道怎么组装这些数据包，从而将数据包还原成完整的组件</li></ul><p>为了解决这些问题，TCP(传输控制协议)就出现了。他是一种面向连接的、可靠的、基于字节流的传输层通信协议。优点相较于TCP有：</p><ul><li>对于数据包丢失的情况，TCP提供重传机制</li><li>TCP引入数据包排序机制，保证将乱序的数据包组合成一个完整的文件</li></ul><p>和UDP头一样，TCP头除了包含目标端口和本机端口之外，还提供了排序序列号来重排数据包。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518100357.png" alt="image-20200518100357594"></p><p>TCP 的传输模型整体上来看是和UDP差不多的。不同的地方在于，通过TCP头的信息保证了一块大的数据大传输完整性。</p><p>完成的TCP连接生命周期包括：<strong>建立连接</strong>、<strong>传输数据</strong>、<strong>断开连接</strong>。</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200518141751.png" alt="image-20200518141751565"></p><ul><li>建立连接。这个阶段通过“三次握手”来建立client 和server之间的通信。TCP提供面向连接的通信传输。<strong>面向连接</strong>是在数据通信开始之前先做好两端之间的准备工作。<strong>三次握手</strong>指在建立TCP，客户端和服务端要发送三个数据包以确认连接。</li><li>传输数据。这个阶段，接收端要对每个数据包进行确认操作。会返回给发送端一个确认消息，发送端没收到的话，就会启动重发机制。大的文件包也会根据TCP头中的序列号去进行一个拼接。</li><li>断开连接。数据传输完成之后，来一波四次挥手。</li></ul><p>TCP为了保证数据传输的可靠性和稳定性，牺牲了传输速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;衡量 Web 页面性能有个重要的指标叫做:&lt;code&gt;FP&lt;/code&gt;(First Paint),是指从&lt;strong&gt;页面加载到首次开始绘制的时长&lt;/strong&gt;。更少的FP意味着更多的PV，更高的参与度、以及转换率。影响其的一个很重要的因素就是&lt;strong&gt;网络加载速度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;想要优化网页的加载速度，需要对网络有一个深入的认识。&lt;/p&gt;
&lt;h2 id=&quot;数据包的传输过程&quot;&gt;&lt;a href=&quot;#数据包的传输过程&quot; class=&quot;headerlink&quot; title=&quot;数据包的传输过程&quot;&gt;&lt;/a&gt;数据包的传输过程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;互联网实际是一套理论和协议组成的体系架构。&lt;/strong&gt;其中，因为有了协议这一众所周知的规则和标准，各方都同意使用 的前提下，那么它们的通信之间将变得毫无障碍。&lt;/p&gt;
&lt;p&gt;互联网中的数据是通过数据包来传输的。发送的数据很大的话，会被拆成很多小的包来传输。例如音频数据就并不是一个大的文件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 加速 git clone</title>
    <link href="http://zoomdong.site/2020/05/17/mbp%E5%8A%A0%E9%80%9Fgit-clone/"/>
    <id>http://zoomdong.site/2020/05/17/mbp加速git-clone/</id>
    <published>2020-05-17T10:32:11.000Z</published>
    <updated>2020-05-17T10:32:34.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置-shadowsocks-代理"><a href="#配置-shadowsocks-代理" class="headerlink" title="配置 shadowsocks 代理"></a>配置 shadowsocks 代理</h2><p>即小飞机</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200517175437.png" alt="image-20200517175437615"></p><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200517175503.png" alt="image-20200517175502982"></p><p>点击高级配置一波代理：</p><p><img src="https://zoomdong.oss-cn-beijing.aliyuncs.com/img/20200517181844.png" alt="image-20200517181844309"></p><p>然后在命令行里面使用如下的命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global http.proxy <span class="string">'socks5://127.0.0.1:1086'</span></span><br><span class="line">git<span class="built_in"> config </span>--global https.proxy <span class="string">'socks5://127.0.0.1:1086'</span></span><br></pre></td></tr></table></figure><p>然后就可以加速处理了。</p><h2 id="取消加速代理"><a href="#取消加速代理" class="headerlink" title="取消加速代理"></a>取消加速代理</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global --unset http.proxy</span><br><span class="line">git<span class="built_in"> config </span>--global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置-shadowsocks-代理&quot;&gt;&lt;a href=&quot;#配置-shadowsocks-代理&quot; class=&quot;headerlink&quot; title=&quot;配置 shadowsocks 代理&quot;&gt;&lt;/a&gt;配置 shadowsocks 代理&lt;/h2&gt;&lt;p&gt;即小飞机&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的 BFS 模板题目</title>
    <link href="http://zoomdong.site/2020/05/14/bfs-template/"/>
    <id>http://zoomdong.site/2020/05/14/bfs-template/</id>
    <published>2020-05-14T05:39:54.000Z</published>
    <updated>2020-05-23T13:29:28.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bfs解题框架"><a href="#bfs解题框架" class="headerlink" title="bfs解题框架"></a>bfs解题框架</h2><p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener">参考文章</a></p><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p>bfs题目出现的常见场景：<strong>问题的本质实际上是在一张图里面找从 start 到 end 的最近距离</strong></p><p>广义的描述有很多的题目变形:例如走迷宫、有的格子不能走、起点到终点的最短路？有瞬间传送的门？</p><a id="more"></a><p>参考 labuladong算法笔记是可以有一个bfs的算法迭代框架的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span> <span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">  Queue&lt;Node&gt; q;</span><br><span class="line">  <span class="comment">// 用来去重的数据结构</span></span><br><span class="line">  Set&lt;Node&gt; visited;</span><br><span class="line">  <span class="comment">// 起点进入队列</span></span><br><span class="line">  q.offer(start);</span><br><span class="line">  <span class="comment">// 标记</span></span><br><span class="line">  visited.add(start);</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (q <span class="keyword">not</span> empty) &#123;</span><br><span class="line">    <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 将队列中的节点四周扩散</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">      Node cur = q.poll()</span><br><span class="line">      <span class="comment">// 边界条件，如果这个点到了终点，就返回路径的值</span></span><br><span class="line">      <span class="keyword">if</span> (cur === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不满足则将周围的点加到队列里面来</span></span><br><span class="line">      <span class="keyword">for</span> (Node x in cur.adj()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">not</span> in visited) &#123;</span><br><span class="line">          q.offer(x);</span><br><span class="line">          visited.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次走完之后更新一下路径</span></span><br><span class="line">  <span class="built_in">step</span> ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面 <code>cur.adj()</code> 就代表cur附近相邻的节点;visited的作用主要是为了防止走回头路，但一般的二叉树结构，没有子节点到父节点到指针，不会走回头路就不需要<code>visited</code>。</p><p>下面可以找一些具体的题目来使用这些框架:</p><h3 id="lc-111"><a href="#lc-111" class="headerlink" title="lc#111"></a>lc#111</h3><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">题目链接</a></p><p>这题因为是找最小的深度其实也是可以用<code>bfs</code>板子写的，其实还挺简单的hhh<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">1</span>;</span><br><span class="line">  queue.push(root)</span><br><span class="line">  <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">      <span class="keyword">if</span> (!cur.left &amp;&amp; !cur.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      cur.left &amp;&amp; queue.push(cur.left)</span><br><span class="line">      cur.right &amp;&amp; queue.push(cur.right)</span><br><span class="line">    &#125;</span><br><span class="line">    step ++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> step;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="lc-752"><a href="#lc-752" class="headerlink" title="lc#752"></a>lc#752</h3><p><a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">题目链接</a></p><p>这题虽然看上去不是很容易发现是bfs（就我自己而言不知道怎么去搜索），实际上我们以’0000’为起点去进行一个搜索，把所有的情况用bfs搜一遍，就可以了，具体思路可以参考代码里面的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">deadends</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> openLock = <span class="function"><span class="keyword">function</span> (<span class="params">deadends, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理锁的情况</span></span><br><span class="line">  <span class="keyword">const</span> plusOne = <span class="function">(<span class="params">str, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (s[index] === <span class="string">'9'</span>) &#123;</span><br><span class="line">      s[index] = <span class="string">'0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s[index] = <span class="built_in">String</span>.fromCharCode(s[index].charCodeAt() + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> minusOne = <span class="function">(<span class="params">str, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> (s[index] === <span class="string">'0'</span>) &#123;</span><br><span class="line">      s[index] = <span class="string">'9'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s[index] = <span class="built_in">String</span>.fromCharCode(s[index].charCodeAt() - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录边界值</span></span><br><span class="line">  <span class="keyword">let</span> deads = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> deadends) &#123;</span><br><span class="line">    deads.set(item, deads.get(item) ? deads.get(item) + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录已经走过的密码情况</span></span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  queue.push(<span class="string">'0000'</span>)</span><br><span class="line">  visited.set(<span class="string">'0000'</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">while</span> (queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">      <span class="comment">// 走重了</span></span><br><span class="line">      <span class="keyword">if</span> (deads.has(cur)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 到了</span></span><br><span class="line">      <span class="keyword">if</span> (cur === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理一下节点的遍历</span></span><br><span class="line">      <span class="comment">// 这题不好处理的地方就在这个地方。开始没有想到可以这样去访问周围的情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> up = plusOne(cur, j)</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(up)) &#123;</span><br><span class="line">          queue.push(up)</span><br><span class="line">          visited.set(up, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> down = minusOne(cur, j)</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(down)) &#123;</span><br><span class="line">          queue.push(down)</span><br><span class="line">          visited.set(down, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(queue);</span></span><br><span class="line">    step++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(openLock(['0201', '0101', '0102', '1212', '2002'], '0202'))</span></span><br></pre></td></tr></table></figure><h3 id="lc279"><a href="#lc279" class="headerlink" title="lc279"></a>lc279</h3><p>这题其实可以dp,也可以bfs,因为就相当于要找到一个类似于最短路径的概念，这里也要明白bfs这个过程是怎么进行的(这里还是使用bfs模版来搞一搞):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  queue.push(n)</span><br><span class="line">  visited.set(n, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">      <span class="comment">// 处理一下下一轮队列的情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = cur - j * j</span><br><span class="line">        <span class="keyword">if</span> (now === <span class="number">0</span>) &#123;</span><br><span class="line">          step++</span><br><span class="line">          <span class="keyword">return</span> step</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果now这个值没有被标记，送进下一轮bfs</span></span><br><span class="line">        <span class="keyword">if</span> (!visited.has(now)) &#123;</span><br><span class="line">          queue.push(now)</span><br><span class="line">          visited.set(now, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numSquares(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><h3 id="lc1284-转化为全零矩阵的最少反转次数"><a href="#lc1284-转化为全零矩阵的最少反转次数" class="headerlink" title="lc1284 转化为全零矩阵的最少反转次数"></a>lc1284 转化为全零矩阵的最少反转次数</h3><p>这题每次bfs存每次数组转换之后的状态就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">mat</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 反转指的是能够将 0-&gt; 1 1-&gt; 0 每次反转相邻边上的单元格也被翻转</span></span><br><span class="line"><span class="comment">// 求最小反转次数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1,1,1</span></span><br><span class="line"><span class="comment"> * 1,0,1 -&gt;</span></span><br><span class="line"><span class="comment"> * 0 0 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 直接使用js的map来对每一次对状态进行一个存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> minFlips = <span class="function"><span class="keyword">function</span> (<span class="params">mat</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = mat.length,</span><br><span class="line">    n = mat[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> first = <span class="built_in">JSON</span>.stringify(mat)</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  queue.push(first)</span><br><span class="line">  visited.set(first, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> judge = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用来改变单元格当前的值</span></span><br><span class="line">  <span class="keyword">const</span> changeArr = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">      arr[i][j] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[i][j] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变单元格及其周围单元格的值</span></span><br><span class="line">  <span class="keyword">const</span> change = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    arr = changeArr(arr, i, j)</span><br><span class="line">    <span class="keyword">let</span> dir = [</span><br><span class="line">      [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">      [<span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">      [<span class="number">-1</span>, <span class="number">0</span>],</span><br><span class="line">      [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        i + dir[k][<span class="number">0</span>] &lt; <span class="number">0</span> ||</span><br><span class="line">        i + dir[k][<span class="number">0</span>] &gt;= m ||</span><br><span class="line">        j + dir[k][<span class="number">1</span>] &lt; <span class="number">0</span> ||</span><br><span class="line">        j + dir[k][<span class="number">1</span>] &gt;= n</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr = changeArr(arr, i + dir[k][<span class="number">0</span>], j + dir[k][<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bfs直接搜一波的</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = queue.shift()</span><br><span class="line">      <span class="keyword">let</span> item2 = <span class="built_in">JSON</span>.parse(item)</span><br><span class="line">      <span class="comment">// bfs的终点条件</span></span><br><span class="line">      <span class="keyword">if</span> (judge(item2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 直接去搜所有的状态，然后放进去队列里面</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; m; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">          item3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(item2))</span><br><span class="line">          <span class="keyword">let</span> changeArr = <span class="built_in">JSON</span>.stringify(change(item3, x, y))</span><br><span class="line">          <span class="keyword">if</span> (visited.has(changeArr)) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.push(changeArr)</span><br><span class="line">            visited.set(changeArr, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lc301-删除无效的括号"><a href="#lc301-删除无效的括号" class="headerlink" title="lc301 删除无效的括号"></a>lc301 删除无效的括号</h3><p>这题也是一个很有意思的bfs，其实想法挺简单的，每一层都只删一个括号，然后往下去找，直到某一层有结果了直接把这一层符合条件的结果收集起来输出出去就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">var</span> removeInvalidParentheses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isvalid = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    str = str.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === <span class="string">'('</span>) &#123;</span><br><span class="line">        stack.push(item)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(item === <span class="string">')'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> item1 = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> (item1 !== <span class="string">'('</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="comment">// 直接遍历去删</span></span><br><span class="line">  visited.set(s, <span class="number">1</span>)</span><br><span class="line">  queue.push(s)</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = queue.shift()</span><br><span class="line">      <span class="keyword">if</span> (isvalid(item) &amp;&amp; item) &#123;</span><br><span class="line">        res.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; item.length; k++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item3 = <span class="string">''</span></span><br><span class="line">        <span class="comment">// 只用删括号</span></span><br><span class="line">        <span class="keyword">if</span> (item[k] === <span class="string">'('</span> || item[k] === <span class="string">')'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (k === <span class="number">0</span>) &#123;</span><br><span class="line">            item3 = item.slice(<span class="number">1</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k === item.length - <span class="number">1</span>) &#123;</span><br><span class="line">            item3 = item.slice(<span class="number">0</span>, k)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            item3 = item.slice(<span class="number">0</span>, k) + item.slice(k + <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited.has(item3)) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          visited.set(item3, <span class="number">1</span>)</span><br><span class="line">          queue.push(item3)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step++</span><br><span class="line">    <span class="keyword">if</span> (res.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(removeInvalidParentheses('()())()'))</span></span><br><span class="line"><span class="comment">// console.log(removeInvalidParentheses("(a)())()"))</span></span><br></pre></td></tr></table></figure><p>但是注意里面字符还有不是括号的，做好特判就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;bfs解题框架&quot;&gt;&lt;a href=&quot;#bfs解题框架&quot; class=&quot;headerlink&quot; title=&quot;bfs解题框架&quot;&gt;&lt;/a&gt;bfs解题框架&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法框架&quot;&gt;&lt;a href=&quot;#算法框架&quot; class=&quot;headerlink&quot; title=&quot;算法框架&quot;&gt;&lt;/a&gt;算法框架&lt;/h3&gt;&lt;p&gt;bfs题目出现的常见场景：&lt;strong&gt;问题的本质实际上是在一张图里面找从 start 到 end 的最近距离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广义的描述有很多的题目变形:例如走迷宫、有的格子不能走、起点到终点的最短路？有瞬间传送的门？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器原理学习笔记-Chrome架构演变</title>
    <link href="http://zoomdong.site/2020/05/14/broswer-1/"/>
    <id>http://zoomdong.site/2020/05/14/broswer-1/</id>
    <published>2020-05-13T16:23:44.000Z</published>
    <updated>2020-05-13T16:31:52.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="chrome-架构"><a href="#chrome-架构" class="headerlink" title="chrome 架构"></a>chrome 架构</h2><p>一般我们使用chrome浏览器打开一个网页的时候，打开浏览器的任务管理器可以发现会发现chrome在这个时候会启用多个进程窗口。(同windows一样，chrome任务管理器也是用来展示运行中chrome使用进程信息的。)</p><p>这里就会涉及到chrome的<strong>多进程架构</strong>。</p><h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>计算机的并行处理就是指在同一时刻处理多个任务，性能是要高于正常情况下用单线程来处理的。</p><h2 id="线程-and-进程"><a href="#线程-and-进程" class="headerlink" title="线程 and 进程"></a>线程 and 进程</h2><p>多线程可以并行处理任务，但是<strong>线程不能存在的，还需要进程来启动和管理</strong>。</p><p>进程指的是一个程序的运行实例：启动一个程序时，OS会为程序创建一块内存，用来存放代码、运行中的数据、和一个执行任务的主线程，这样的一个环境就可以叫做<strong>进程</strong>。</p><p><img src="/2020/05/14/broswer-1/image-20200513225045754.png" alt="image-20200513225045754"></p><p>如图所示，线程是依附于进程的，进程中使用多线程并行处理是能够提升运行效率。</p><a id="more"></a><p>进程和线程的关系有以下几个特点:</p><ul><li>进程中的任一线程执行出错，都会导致整个进程的崩溃</li><li><p>线程之间共享进程的数据</p><ul><li>线程之间可以对进程的公共数据进行读写操作</li></ul></li><li><p>当一个进程关闭之后，操作系统会回收进程所占用的内存</p><ul><li>当一个进程关闭的时候，操作系统会回收该进程所申请的所有资源;即使线程导致的内存泄漏都会在进程退出之后进行回收</li></ul></li><li>进程之间的内容相互隔离<ul><li>进程隔离是为了保护OS中进程互不干扰的技术，每个进程都只能访问自己占有的数据</li><li>一个进程挂了，是不会影响其他进程的</li><li>进程之间进行数据通信，需要依赖IPC机制</li></ul></li></ul><h2 id="浏览器的单进程时代"><a href="#浏览器的单进程时代" class="headerlink" title="浏览器的单进程时代"></a>浏览器的单进程时代</h2><p><img src="/2020/05/14/broswer-1/image-20200513225930714.png" alt="image-20200513225930714"></p><p>RT,单进程浏览器是指浏览器所有的功能模块都运行在同一个进程里面。这些模块包括网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p><p>缺点:功能都运行在一个进程里面，会导致浏览器不稳定、不流畅、不安全的一个主要因素。</p><h3 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h3><p>浏览器的插件 &amp;&amp; 渲染引擎模块的渲染都是导致浏览器不稳定的一个因素之一。如果这些东西崩溃了，那么浏览器也会跟着崩溃。</p><h3 id="不流畅"><a href="#不流畅" class="headerlink" title="不流畅"></a>不流畅</h3><p>从上面架构图可以看出，如果写一个类似于下面的无限循环脚本:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> freeze = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'freeze'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">freeze()</span><br></pre></td></tr></table></figure><p>如果让这个脚本在单进程浏览器里面运行了，它会独占整个浏览器的运行线程，从而导致其他的模块机制没有机会去被执行。这样就会使浏览器变得卡顿。</p><p>除了上面的<strong>脚本</strong>和<strong>插件</strong>会让浏览器变得卡顿，其实<strong>页面的内存泄漏</strong>也是使得单进程变慢的一个重要的原因。</p><h3 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h3><ul><li>插件，当你的页面运行一个插件的时候，这个时候插件能够完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取账号密码、引发安全性问题</li><li>脚本，类似于XSS攻击</li></ul><p>类似于这样一个场景，一个页面的崩溃，导致了你所有的浏览器页面的崩溃。</p><h2 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h2><h3 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h3><p><img src="/2020/05/14/broswer-1/image-20200513231511743.png" alt="image-20200513231511743"></p><h3 id="不稳定？"><a href="#不稳定？" class="headerlink" title="不稳定？"></a>不稳定？</h3><p>由于进程之间是彼此相互隔离的，所以当一个页面崩溃的时候，只会影响当前的页面进程和插件进程。并不会影响到浏览器和其他页面。</p><h3 id="不流畅？"><a href="#不流畅？" class="headerlink" title="不流畅？"></a>不流畅？</h3><p>因为JS也是在渲染进程中进行渲染的，所以即使其阻塞了渲染进程，影响到的也只是当前的渲染页面。并不会影响浏览器和其他页面。</p><p>对于内存泄漏的改进: 当整个页面关闭的时候，渲染进程也会被关闭，误操作泄漏的内存也会包括在进程占有的内存中被系统回收回去。</p><h3 id="不安全？"><a href="#不安全？" class="headerlink" title="不安全？"></a>不安全？</h3><p>多进程架构的额外好处是可以使用<strong>安全沙箱</strong>，沙箱相当于是OS给进程上了一把锁，沙箱里面的程序可以运行，但不能在硬盘上写入数据，也不能在敏感位置读取任何数据，例如获取你的文档读写权限。Chrome把插件和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件里面执行了恶意程序，它也无法突破沙箱去获取系统权限。</p><h3 id="改进的多进程架构"><a href="#改进的多进程架构" class="headerlink" title="改进的多进程架构"></a>改进的多进程架构</h3><p> 随着时间的发展。目前的Chrome架构也有了许多新的变化:</p><p><img src="/2020/05/14/broswer-1/image-20200513232500284.png" alt="image-20200513232500284"></p><p>目前的 Chrome 浏览器包括:1个浏览器(Broswer)主进程、1个GPU进程、1个网络(NetWork)进程、多个渲染进程和多个插件进程。</p><ul><li>浏览器进程。负责界面显示、用户交互、子进程管理、同时提供存储功能(localstorage等)</li><li>渲染进程。核心任务是将HTML、CSS 和 JavaScript 转换成用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程里面，默认情况下，Chrome 会给每个Tab标签创建一个渲染进程。且渲染进程运行在sandbox里面。</li><li><strong>GPU进程</strong>。GPU使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的UI界面都选择采用GPU来绘制，然后GPU就成了浏览器的普遍需求。最后Chrome也在多进程架构里面引入了 GPU 进程。</li><li>网络进程。主要负责网页资源的加载。之前是作为一个模块运行在浏览器进程里面的，直到最近才独立出来，成为一个单独的进程。</li><li>插件进程。主要是负责插件的运行，因插件容易崩溃，所以需要插件进程来隔离从而保证其崩溃不会对浏览器和页面造成影响。</li></ul><p>带来的问题:</p><ul><li>更高的资源占用。因为每个结构都会包含公共基础结构的副本，意味着浏览器会消耗更多的内存资源。所以mbp在没有充电器的情况下写前端是一件非常耗电的事情。</li><li>更复杂的体系架构。各模块之间的耦合性高、拓展性差的问题，会导致现在的架构很难以适应新的需求了。</li></ul><h2 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="headerlink" title="未来面向服务的架构"></a>未来面向服务的架构</h2><p>为了解决这些问题，16年，Chrome官方使用了“面向服务的架构”(Service Oriented Architecture,简称<code>SOA</code>)的思想设计了新的Chrome架构。之后整体的架构都会往这一方面进行迁移:原来所有的模块都会被重构成独立的服务(Service)，每个服务(Service)都可在独立的进程中运行，访问服务(Service)必须使用定义好的接口，通过IPC来进行通信。最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似于OS的底层服务。</p><p>具体资料可以可以Google搜索。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从Chrome浏览器的进化视角来看，浏览器的进化历史大概可以分为:</p><p>单进程架构 -&gt; 多进程结构(早期)-&gt;多进程架构(现在)-&gt;面向服务的架构(未来)</p><p>个人认为之所以会有这方面的进化，起初可能仅仅是因为性能的问题。后面随着技术的进步与发展浏览器架构需要考虑到的问题也越来越多，例如安全，隐私，稳定，流畅等问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;chrome-架构&quot;&gt;&lt;a href=&quot;#chrome-架构&quot; class=&quot;headerlink&quot; title=&quot;chrome 架构&quot;&gt;&lt;/a&gt;chrome 架构&lt;/h2&gt;&lt;p&gt;一般我们使用chrome浏览器打开一个网页的时候，打开浏览器的任务管理器可以发现会发现chrome在这个时候会启用多个进程窗口。(同windows一样，chrome任务管理器也是用来展示运行中chrome使用进程信息的。)&lt;/p&gt;
&lt;p&gt;这里就会涉及到chrome的&lt;strong&gt;多进程架构&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;并行处理&quot;&gt;&lt;a href=&quot;#并行处理&quot; class=&quot;headerlink&quot; title=&quot;并行处理&quot;&gt;&lt;/a&gt;并行处理&lt;/h2&gt;&lt;p&gt;计算机的并行处理就是指在同一时刻处理多个任务，性能是要高于正常情况下用单线程来处理的。&lt;/p&gt;
&lt;h2 id=&quot;线程-and-进程&quot;&gt;&lt;a href=&quot;#线程-and-进程&quot; class=&quot;headerlink&quot; title=&quot;线程 and 进程&quot;&gt;&lt;/a&gt;线程 and 进程&lt;/h2&gt;&lt;p&gt;多线程可以并行处理任务，但是&lt;strong&gt;线程不能存在的，还需要进程来启动和管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进程指的是一个程序的运行实例：启动一个程序时，OS会为程序创建一块内存，用来存放代码、运行中的数据、和一个执行任务的主线程，这样的一个环境就可以叫做&lt;strong&gt;进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/14/broswer-1/image-20200513225045754.png&quot; alt=&quot;image-20200513225045754&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，线程是依附于进程的，进程中使用多线程并行处理是能够提升运行效率。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ts一些技巧总结</title>
    <link href="http://zoomdong.site/2020/05/03/ts-higher-1/"/>
    <id>http://zoomdong.site/2020/05/03/ts-higher-1/</id>
    <published>2020-05-03T14:51:26.000Z</published>
    <updated>2020-05-12T16:05:38.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些学习资料"><a href="#一些学习资料" class="headerlink" title="一些学习资料"></a>一些学习资料</h2><p>一本不错的 TS 书籍，已经买了实体书:</p><ul><li><a href="https://github.com/jkchao/typescript-book-chinese" target="_blank" rel="noopener">深入理解 TypeScript</a><br>一个不错的TS练习repo:</li><li><a href="https://github.com/mdevils/typescript-exercises" target="_blank" rel="noopener">typescript exercise</a></li></ul><h2 id="interface-amp-amp-type"><a href="#interface-amp-amp-type" class="headerlink" title="interface &amp;&amp; type"></a>interface &amp;&amp; type</h2><p>两者几乎没有区别,但是 <code>interface</code> 可以合并多个相同的 <code>interface</code>,而 <code>type</code> 只能使用 <code>&amp;</code> 进行连接。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: A = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><code>typeof</code> 可以取某个值的 <code>type</code>:<br>具体使用方法:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equal to const b: number = 4</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="keyword">typeof</span> a = <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>在一些服务端项目里面，我们可以把一些需要的工具塞在<code>context</code>里面去，这个时候就需要<code>typeof</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">'./lo'</span></span><br></pre></td></tr></table></figure><h2 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h2><p><code>keyof</code> 和 <code>Object.keys</code> 有些类似，不过 <code>keyof</code> 取的是<code>interface</code>里面的键。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type keys = 'x' | 'y'</span></span><br><span class="line"><span class="comment">// 这里keys会成为一个联合类型</span></span><br><span class="line"><span class="keyword">type</span> keys = keyof Point;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>keyof</code>来实现一个<code>get</code>函数来获取它的属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  hello: <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能同时兼具以下几个优点:</p><ol><li>能够确认结果的返回类型</li><li>能够对<code>key</code>值进行一个约束</li></ol><h2 id="keyof-in"><a href="#keyof-in" class="headerlink" title="keyof, in"></a>keyof, in</h2><p><code>keyof</code> 能够产生一个联合类型，<code>in</code>能够遍历枚举类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T -&gt; "name" | "age"</span></span><br><span class="line"><span class="keyword">type</span> T = keyof Foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> keys = <span class="string">'a'</span> | <span class="string">'b'</span></span><br><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj -&gt; &#123; a: any, b: any &#125;</span></span><br></pre></td></tr></table></figure></p><p>那么可以写一个将传入的属性变成可选项的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br></pre></td></tr></table></figure><p>那么使用的时候就可以这样:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = Partial&lt;Foo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能定义 name, age 中的属性，当然也可以不定义</span></span><br><span class="line"><span class="keyword">const</span> a: A = &#123;</span><br><span class="line">  name: <span class="string">'1'</span>,</span><br><span class="line">  age: <span class="string">'3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>in</code>的主要作用是取联合类型的值。主要用于数组和对象的构造。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name = <span class="string">'firstName'</span> | <span class="string">'lastName'</span></span><br><span class="line"><span class="keyword">type</span> IName = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> name]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是<code>in</code>是不能用在<code>interface</code>上面，否则会出错。</p><h2 id="ts定义函数"><a href="#ts定义函数" class="headerlink" title="ts定义函数"></a>ts定义函数</h2><p><code>ts</code>中类型系统中的函数为<code>泛型操作符</code>，最简单的方式就是使用<code>type</code>关键字:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a simple operator</span></span><br><span class="line"><span class="keyword">type</span> foo&lt;T&gt; = T;</span><br></pre></td></tr></table></figure><p>上面的代码转成<code>JavaScript</code>之后会成这个样子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的类型系统中的函数还支持对入参对约束:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 T 进行约束</span></span><br><span class="line"><span class="keyword">type</span> foo&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T;</span><br></pre></td></tr></table></figure><p>这里就类似于这样的<code>ts</code>代码:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">T: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是能够设置默认值的:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">'hello xyx'</span>&gt; = T</span><br></pre></td></tr></table></figure><p>同理:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">T: <span class="built_in">string</span> = 'hello xyx'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里是不能像<code>JS</code>里的函数一样支持剩余参数的，但是我们可以通过一些操作模拟出来。</p><h2 id="类型支持条件判断"><a href="#类型支持条件判断" class="headerlink" title="类型支持条件判断"></a>类型支持条件判断</h2><p>可以使用<code>extends</code>关键字来完成这一操作:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>结合之前的<code>type</code>这里可以用来模拟一下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> str = <span class="string">'hello xyx'</span></span><br><span class="line"><span class="keyword">type</span> INumber = N <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'yeah'</span> : <span class="string">'no'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> res1 = INumber&lt;num&gt; <span class="comment">// yeah</span></span><br><span class="line"><span class="keyword">type</span> res2 = INumber&lt;str&gt; <span class="comment">// no</span></span><br></pre></td></tr></table></figure><p>这里我们就相当于实现了一个简单的带判断逻辑的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些学习资料&quot;&gt;&lt;a href=&quot;#一些学习资料&quot; class=&quot;headerlink&quot; title=&quot;一些学习资料&quot;&gt;&lt;/a&gt;一些学习资料&lt;/h2&gt;&lt;p&gt;一本不错的 TS 书籍，已经买了实体书:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jkchao/typescript-book-chinese&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解 TypeScript&lt;/a&gt;&lt;br&gt;一个不错的TS练习repo:&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mdevils/typescript-exercises&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;typescript exercise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;interface-amp-amp-type&quot;&gt;&lt;a href=&quot;#interface-amp-amp-type&quot; class=&quot;headerlink&quot; title=&quot;interface &amp;amp;&amp;amp; type&quot;&gt;&lt;/a&gt;interface &amp;amp;&amp;amp; type&lt;/h2&gt;&lt;p&gt;两者几乎没有区别,但是 &lt;code&gt;interface&lt;/code&gt; 可以合并多个相同的 &lt;code&gt;interface&lt;/code&gt;,而 &lt;code&gt;type&lt;/code&gt; 只能使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 进行连接。&lt;br&gt;&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; B = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;区别:&lt;br&gt;&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; a: A = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
